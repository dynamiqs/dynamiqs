{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"community/index.html","title":"Community","text":""},{"location":"community/index.html#community","title":"Community","text":"<p>Welcome to the Dynamiqs community! You can get involved in the project by:</p> <ul> <li>Opening issues in the GitHub repository, see GitHub Issues.</li> <li>Contributing to the codebase, see Contributing.</li> <li>Reaching out to us, see Let's talk.</li> <li>Joining the Dynamiqs community on Slack.</li> <li>Citing Dynamiqs in your research, see Citing Dynamiqs.</li> </ul> <p>We always welcome issue raisers, contributors, and quantum physics lovers. Come and help us make Dynamiqs better!</p>"},{"location":"community/citing.html","title":"Citing Dynamiqs","text":""},{"location":"community/citing.html#citing-dynamiqs","title":"Citing Dynamiqs","text":"<p>If you have found this library useful in your academic research, you can cite:</p> <pre><code>@unpublished{guilmin2025dynamiqs,\n  title  = {Dynamiqs: an open-source Python library for GPU-accelerated and differentiable simulation of quantum systems},\n  author = {Pierre Guilmin and Adrien Bocquet and {\\'{E}}lie Genois and Daniel Weiss and Ronan Gautier},\n  year   = {2025},\n  url    = {https://github.com/dynamiqs/dynamiqs}\n}\n</code></pre> <p>P. Guilmin, A. Bocquet, E. Genois, D. Weiss, R. Gautier. Dynamiqs: an open-source Python library for GPU-accelerated and differentiable simulation of quantum systems (2025), in preparation.</p>"},{"location":"community/contributing.html","title":"Contributing","text":""},{"location":"community/contributing.html#contributing-to-dynamiqs","title":"Contributing to Dynamiqs","text":"<p>We warmly welcome all contributions. If you're a junior developer or physicist, you can start with a small utility function, and move on to bigger problems as you discover the library's internals. If you're more experienced and want to implement more advanced features, don't hesitate to get in touch to discuss what would suit you.</p> <p>To contribute efficiently, a few guidelines are compiled below.</p>"},{"location":"community/contributing.html#1-requirements","title":"1. Requirements","text":"<p>The project was written using Python 3.10+, you must have a compatible version of Python (i.e. &gt;= 3.10) installed on your computer.</p>"},{"location":"community/contributing.html#2-setup","title":"2. Setup","text":"<p>Clone the repository and dive in:</p> <pre><code>git clone git@github.com:dynamiqs/dynamiqs.git\ncd dynamiqs\n</code></pre> <p>To install the library with all its dependencies, as well as the developer dependencies:</p> <ul> <li>If you use <code>uv</code>, just run:   <pre><code>uv sync --extra dev\n</code></pre></li> <li>If you use <code>pip</code>, we strongly recommend creating a virtual environment to install the project dependencies. You can follow this guide to set one up. You can then install the library in editable mode:   <pre><code>pip install -e \".[dev]\"\n</code></pre></li> </ul>"},{"location":"community/contributing.html#3-workflow","title":"3. Workflow","text":""},{"location":"community/contributing.html#github-flow","title":"Github flow","text":"<p>We use the GitHub flow branch-based workflow to collaborate on the library. If you're unfamiliar with open-source development, you can follow the GitHub flow tutorial Briefly, to add a change you should: fork the repository, create a branch, make and commit your changes, create a pull request (PR), address review comments, and merge the PR.</p>"},{"location":"community/contributing.html#planning-your-change","title":"Planning your change","text":"<p>If you are planning a large change (more than one hundred lines of code), it is usually more efficient to discuss it with us beforehand. This way, we can agree on the API and the main logic. For structural or significant changes, we typically write and iterate on small RFCs (Requests for Comments). For large change, please separate the logical building blocks of your change into distinct pull requests as much as possible. Long PRs are harder to review, and breaking them down will make everyone's life easier.</p> <p>If the proposed change is necessary for your work and has not been reviewed within three days, don\u2019t hesitate to ping the main developers directly on the PR.</p>"},{"location":"community/contributing.html#developer-tools","title":"Developer tools","text":"<p>We use a variety of modern formatting and linting tools, as well as automated tests, to ensure high code quality and to identify bugs early in the development process. These tests can be run either together or individually using the <code>task</code> CLI tool, which is installed as part of the development dependencies.</p> <p>Typically you should ensure all tasks run smoothly before submitting a new PR:</p> <pre><code>task all\n</code></pre> <p>Here is a list of available tasks:</p> <pre><code>&gt; task --list\nlint         lint the code (ruff)\nformat       auto-format the code (ruff)\ncodespell    check for misspellings (codespell)\nclean        clean the code (ruff + codespell)\ntest         run the unit tests suite (pytest)\ndoctest-code check code docstrings examples (doctest)\ndoctest-docs check documentation examples (doctest)\ndoctest      check all examples (doctest)\ndocbuild     build the documentation website\ndocserve     preview documentation website with hot-reloading\nall          run all tasks before a commit (ruff + codespell + pytest + doctest)\nci           run all the CI checks\n</code></pre>"},{"location":"community/contributing.html#run-tasks-automatically-before-each-commit","title":"Run tasks automatically before each commit","text":"<p>Alternatively, you can use <code>pre-commit</code> to automatically run the cleaning tasks (ruff + codespell) before each commit:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"community/contributing.html#build-the-documentation","title":"Build the documentation","text":"<p>The documentation is built using MkDocs and the Material for MkDocs theme. MkDocs generates a static website based on the markdown files in the <code>docs/</code> directory.</p> <p>To preview the changes to the documentation as you edit the docstrings or the markdown files in <code>docs/</code>, we recommend starting a live preview server, which will automatically rebuild the website upon modifications:</p> <pre><code>task docserve\n</code></pre> <p>Open http://localhost:8000/ in your web browser to preview the documentation website.</p> <p>You can build the static documentation website locally with:</p> <pre><code>task docbuild\n</code></pre> <p>This will create a <code>site/</code> directory with the contents of the documentation website. You can then simply open <code>site/index.html</code> in your web browser to view the documentation website.</p>"},{"location":"community/contributing.html#4-style-guide","title":"4. Style guide","text":"<p>This project adheres to PEP 8 guidelines. The maximum line length is 88 characters, and we recommend setting this limit in your IDE. Generally, our automatic cleaning task (<code>task clean</code>) will address most basic styling issues. If you have any remaining doubts, you can follow the conventions used throughout the library by looking at various files.</p> <p>We strive to keep the codebase as maintainable, readable, and unified as possible. We would appreciate your help by following these guidelines in your next PR.</p>"},{"location":"community/contributing.html#writing-a-pr","title":"Writing a PR","text":"<p>The main goal to keep in mind is that if someone reads a past PR, they should quickly gain a clear understanding of what the change was.</p> <ul> <li>Use a lower case name for your branch name.</li> <li>Choose a clear and precise title for your PR. We use the squash and merge strategy to incorporate changes, so the title of your PR will become the commit title in the <code>main</code> branch history. Refer to the commit history of the <code>main</code> branch for inspiration.</li> <li>If, after multiple reviews and iterations, the content of the PR no longer corresponds to the original description, please update the description.</li> </ul>"},{"location":"community/contributing.html#adding-a-new-function","title":"Adding a new function","text":"<p>When writing your function:</p> <ul> <li>Type all arguments of your function, and its return type.</li> <li>When typing a public function, use <code>QArrayLike</code> for qarray inputs, <code>asqarray()</code> to convert to a proper qarray, and <code>QArray</code> for qarray outputs. Use <code>ArrayLike</code> for array inputs, <code>jnp.asarray()</code> to convert to a proper array, and <code>Array</code> for array outputs. See related JAX typing best practices.</li> <li>Ensure you run <code>task docserve</code> to verify how the documentation for your function appears, and correct any issues with rendering.</li> <li>To type a qarray or an array shape, use <code>...</code> to denote possible batch dimensions, use <code>n</code> for the Hilbert space dimension.</li> <li>To add an axis to a qarray or an array, favor <code>[None, ...]</code> over <code>unsqueeze</code>.</li> <li>Favor <code>(...).sum(0)</code> over <code>jnp.sum(..., 0)</code>.</li> </ul> <p>Make sure to add your function:</p> <ol> <li>to the <code>__all__</code> variable at the top of the file (this is how we control namespaces to have everything available under <code>dq.*</code>),</li> <li>to the <code>dynamiqs/mkdocs.yml</code> file (so it appears in the documentation and navigation),</li> <li>to the <code>dynamiqs/docs/python_api/index.md</code> file (so it appears on the Python API page, which lists all the functions of the library).</li> </ol>"},{"location":"community/contributing.html#writing-a-docstring","title":"Writing a docstring","text":"<p>We use Google-style docstrings (see examples here) with a few quirks.</p> <ul> <li>Headers can include (in this order and with these names): <code>Args</code>, <code>Returns</code>, <code>Raises</code>, <code>Examples</code>, <code>See also</code>.</li> <li>You can use the admonitions (colored blocks in the documentation) <code>Note</code> and <code>Warning</code> if relevant.</li> <li>Avoid using <code>The</code> in arguments description, for example change <code>x: The quantum state.</code> to <code>x: Quantum state.</code>.</li> <li>Specify arguments type in <code>(...)</code> after the argument name and only if it is necessary. Adding a type can for example be useful to add a shape information for a qarray or an array, or because the argument typing in the function signature is opaque.</li> </ul>"},{"location":"community/contributing.html#documentation","title":"Documentation","text":"<ul> <li>For internal links, use <code>[dq.Options][dynamiqs.Options]</code> for a class, <code>[dq.sesolve()][dynamiqs.sesolve]</code> for a function (explicitely include <code>()</code> in the function name), and <code>(doc page)(relative/path/to/file.md)</code> for another documentation page (note the parentheses instead of brackets).</li> <li>If you want to add an icon somewhere, use one of the <code>:material-*</code> (search the list here).</li> </ul>"},{"location":"community/contributing.html#exceptions-message","title":"Exceptions message","text":"<ul> <li>Use one or multiple sentences starting with a capital letter and ending with a period.</li> <li>Use backticks <code>`</code> to refer to a variable name or a function. Use <code>'</code> to refer to a string.</li> <li>Many exceptions arise from incorrect argument input; they should typically follow the format: <code>\"Argument ... must ..., but ...\"</code>.</li> </ul> <p>Examples:</p> <pre><code>raise ValueError(f'Argument `H` must have shape (n, n), but has shape H.shape={H.shape}.')\nraise ValueError(\n    \"Argument `matmul_precision` should be a string 'low', 'high', or\"\n    f\" 'highest', but is '{matmul_precision}'.\"\n)\n</code></pre>"},{"location":"community/lets-talk.html","title":"Let's talk!","text":""},{"location":"community/lets-talk.html#lets-talk","title":"Let's talk!","text":"<p>If you're curious, have questions or suggestions, wish to contribute or simply want to say hello, please don't hesitate to engage with us, we're always happy to chat! You can join the community on Slack via this invite link, open an issue on GitHub, or contact the lead developer via email at pierreguilmin@gmail.com.</p>"},{"location":"documentation/index.html","title":"Documentation","text":""},{"location":"documentation/index.html#documentation","title":"Documentation","text":"<p>Welcome to the Dynamiqs documentation! This page will guide you through learning Dynamiqs, from installation and basic examples to advanced tutorials. You can also find a list of available functions and classes in the Python API.</p>"},{"location":"documentation/index.html#getting-started","title":"Getting started","text":"<p>First time using Dynamiqs? Get to know the library and run your first simulations.</p> <ul> <li>What is Dynamiqs?</li> <li>Installation</li> <li>Basic examples</li> <li>The sharp bits \ud83d\udd2a</li> </ul>"},{"location":"documentation/index.html#learn-the-basics","title":"Learn the basics","text":"<p>Familiarize yourself with Dynamiqs. Learn how to simulate quantum systems, define time-dependent operators, run multiple simulations concurrently, and compute gradients.</p> <ul> <li>Workflow in Dynamiqs</li> <li>Time-dependent operators</li> <li>Closed systems</li> <li>Open systems</li> <li>Batching simulations</li> <li>Computing gradients</li> <li>Floquet integration</li> </ul>"},{"location":"documentation/index.html#advanced-examples","title":"Advanced examples","text":"<p>Explore advanced examples and tutorials to deepen your understanding of Dynamiqs.</p> <ul> <li>Driven-dissipative Kerr oscillator</li> <li>Continuous jump measurement</li> <li>Continuous diffusive measurement</li> </ul>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html","title":"Continuous diffusive measurement","text":""},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#continuous-diffusive-measurement","title":"Continuous diffusive measurement","text":"<p>Work in progress.</p> <p>This tutorial is under construction, this is a draft version.</p> <p>In this example, we simulate stochastic trajectories of quantum systems that are continuously measured by a diffusive detector. We explain how to use <code>dq.dssesolve()</code> to simulate trajectories modelled by the diffusive SSE, and <code>dq.dsmesolve()</code> to simulate trajectories modelled by the diffusive SME.</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport dynamiqs as dq\n\ndq.plot.mplstyle(dpi=150)  # set custom matplotlib style\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#qubit","title":"Qubit","text":"<p>We consider a qubit starting from \\(\\ket{\\psi_0}=\\ket+_x=(\\ket0+\\ket1)/\\sqrt2\\), with no unitary dynamic \\(H=0\\) and a single loss operator \\(L=\\sigma_z\\) which is continuously measured by a diffusive detector. We expect stochastic trajectories to project the qubit onto either of the \\(\\sigma_z\\) eigenstates.</p> <p>Let's begin with a perfectly efficient detector. We start with a pure state, and we measure all loss channels with perfect efficiency, so we don't loose any information about the system's state. As a result, it remains pure at all times. We use <code>dq.dssesolve()</code> to simulate these quantum trajectories.</p>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#simulation","title":"Simulation","text":"<pre><code># define Hamiltonian, jump operators, initial state\nH = dq.zeros(2)\njump_ops = [dq.sigmaz()]\npsi0 = (dq.ground() + dq.excited()).unit()\n\n# define save times\ntsave = np.linspace(0, 1.0, 101)\ndelta_t = tsave[1] - tsave[0]\n\n# define a certain number of PRNG key, one for each trajectory\nkey = jax.random.PRNGKey(20)\nntrajs = 5\nkeys = jax.random.split(key, ntrajs)\n\n# simulate trajectories\nmethod = dq.method.EulerMaruyama(dt=1e-3)\nresult = dq.dssesolve(H, jump_ops, psi0, tsave, keys, method=method)\nprint(result)\n</code></pre> Output<pre><code>==== DSSESolveResult ====\nMethod       : EulerMaruyama\nInfos        : 1000 steps | infos shape (5,)\nStates       : QArray complex64 (5, 101, 2, 1) | 7.9 Kb\nMeasurements : Array float32 (5, 1, 100) | 2.0 Kb\n</code></pre> <pre><code>&gt;&gt;&gt; result.states.shape  # (ntrajs, ntsave, n, 1)\n(5, 101, 2, 1)\n&gt;&gt;&gt; result.measurements.shape  # (ntrajs, nLm, ntsave-1)\n(5, 1, 100)\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#individual-trajectories","title":"Individual trajectories","text":"<pre><code>Iks = result.measurements[:, 0]\n</code></pre> <pre><code>for Ik in Iks:\n    plt.plot(tsave[:-1], Ik, lw=1.5)\n\nplt.gca().set(\n    title=rf'Simulated measurements for 5 trajectories',\n    xlabel=r'$t$',\n    ylabel=r'$I^{[t,t+\\Delta t)}$',\n)\n\nrenderfig('diffusive-monitored-qubit-trajs')\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#cumulative-measurements","title":"Cumulative measurements","text":"<pre><code>for Ik in Iks:\n    cumsum_Ik = jnp.cumsum(Ik)\n    plt.plot(tsave[1:], cumsum_Ik, lw=1.5)\n\nplt.axhline(0, ls='--', lw=1.0, color='gray')\nplt.gca().set(\n    title=r'Integral of the measurement record',\n    xlabel=r'$t$',\n    ylabel=r'$Y_t=\\int_0^t \\mathrm{d}Y_s$',\n)\n\nrenderfig('monitored-qubit-cumsum-trajs')\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#projection-onto-sigma_z-eigenstate","title":"Projection onto \\(\\sigma_z\\) eigenstate","text":"<pre><code>expects_all = dq.expect(dq.sigmaz(), result.states).real\n\nfor expects in expects_all:\n    plt.plot(tsave, expects, lw=1.5)\n\nplt.axhline(-1, ls='--', lw=1.0, color='gray')\nplt.axhline(1, ls='--', lw=1.0, color='gray')\nplt.gca().set(\n    title=r'Time evolution of $\\sigma_z$ expectation value',\n    xlabel=r'$t$',\n    ylabel=r'$\\langle \\sigma_z \\rangle_t=\\langle \\psi_t | \\sigma_z | \\psi_t \\rangle$',\n    ylim=(-1.1, 1.1),\n)\n\nrenderfig('monitored-qubit-sigmaz')\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#imperfect-detection","title":"Imperfect detection","text":"<p>If the detection is imperfect, the system state is a density matrix. We use <code>dq.dsmesolve()</code> to simulate these quantum trajectories.</p> <pre><code># define efficiencies\netas = [0.2]\n\n# simulate trajectories\nresult = dq.dsmesolve(H, jump_ops, etas, psi0, tsave, keys, method=method)\nprint(result)\n</code></pre> Output<pre><code>==== DSMESolveResult ====\nMethod       : EulerMaruyama\nInfos        : 1000 steps | infos shape (5,)\nStates       : QArray complex64 (5, 101, 2, 2) | 7.9 Kb\nMeasurements : Array float32 (5, 1, 100) | 2.0 Kb\n</code></pre> <pre><code>&gt;&gt;&gt; result.states.shape  # (ntrajs, ntsave, n, n)\n(5, 101, 2, 2)\n&gt;&gt;&gt; result.measurements.shape  # (ntrajs, nLm, ntsave-1)\n(5, 1, 100)\n</code></pre> <pre><code>expects_all = dq.expect(dq.sigmaz(), result.states).real\n\nfor expects in expects_all:\n    plt.plot(tsave, expects, lw=1.5)\n\nplt.axhline(-1, ls='--', lw=1.0, color='gray')\nplt.axhline(1, ls='--', lw=1.0, color='gray')\nplt.gca().set(\n    title=r'Time evolution of $\\sigma_z$ expectation value',\n    xlabel=r'$t$',\n    ylabel=r'$\\langle \\sigma_z \\rangle_t = \\mathrm{Tr}[\\sigma_z\\rho_t]$',\n    ylim=(-1.1, 1.1),\n)\n\nrenderfig('monitored-qubit-sigmaz-eta')\n</code></pre> <p></p>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#quantum-harmonic-oscillator","title":"Quantum harmonic oscillator","text":"<p>We consider a quantum harmonic oscillator starting from the coherent state \\(\\ket\\alpha\\), with Hamiltonian \\(H=\\omega a^\\dagger a\\) and a single loss operator \\(L=\\sqrt\\kappa a\\) which is continuously measured by heterodyne detection along the \\(X\\) and \\(P\\) quadratures with efficiency \\(\\eta\\), resulting in two a diffusive measurement records \\(I_X\\) and \\(I_P\\). For this example the measurement backaction is null.</p>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#simulation_1","title":"Simulation","text":"<pre><code># define Hamiltonian, jump operators, efficiencies, initial state\nn = 16\na = dq.destroy(n)\nkappa = 1.0\nomega = 10.0\nalpha0 = 2.0\nH = omega * a.dag() @ a\njump_ops = [jnp.sqrt(kappa/2) * a, jnp.sqrt(kappa/2) * (-1j * a)]\netas = [1.0, 1.0]\npsi0 = dq.coherent(n, alpha0)\n\n# define save times\ntsave = np.linspace(0, 1 / kappa, 101)\ndelta_t = tsave[1] - tsave[0]\n\n# define a certain number of PRNG key, one for each trajectory\nkey = jax.random.PRNGKey(42)\nntrajs = 1000\nkeys = jax.random.split(key, ntrajs)\n\n# simulate trajectories\nmethod = dq.method.EulerMaruyama(dt=1e-3)\noptions = dq.Options(save_states=False)\nresult = dq.dsmesolve(H, jump_ops, etas, psi0, tsave, keys, method=method, options=options)\nprint(result)\n</code></pre> Output<pre><code>==== SMESolveResult ====\nMethod       : Euler\nInfos        : 1000 steps | infos shape (1000,)\nStates       : QArray complex64 (1000, 16, 16) | 2.0 Mb\nMeasurements : Array float32 (1000, 2, 100) | 781.2 Kb\n</code></pre> <pre><code>&gt;&gt;&gt; result.measurements.shape  # (ntrajs, nLm, ntsave-1)\n(1000, 2, 100)\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#individual-trajectories_1","title":"Individual trajectories","text":"<pre><code>Iks_x = result.measurements[:, 0]\nIks_p = result.measurements[:, 1]\n</code></pre> <pre><code>fig, axs = dq.plot.grid(2, 2, w=6, h=2, sharexy=True)\nax0, ax1 = list(axs)\n\nfor Ik_x in Iks_x[:3]:\n    ax0.plot(tsave[:-1], Ik_x / np.sqrt(2), lw=1.5)\n\nax0.set(\n    title=rf'Simulated measurements for 3 trajectories',\n    ylabel=r'$I_X^{[t,t+\\Delta t)}/\\sqrt{2}$',\n)\n\nfor Ik_p in Iks_p[:3]:\n    ax1.plot(tsave[:-1], Ik_p / np.sqrt(2), lw=1.5)\n\nax1.set(\n    xlabel=r'$t$',\n    ylabel=r'$I_P^{[t,t+\\Delta t)}/\\sqrt{2}$',\n)\n\nrenderfig('monitored-oscillator-IxIp')\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-diffusive-measurement.html#averaged-trajectories","title":"Averaged trajectories","text":"<pre><code>plt.figure()\nplt.plot(tsave[:-1], jnp.mean(Iks_x / np.sqrt(2), axis=0), label=r'$\\mathbb{E}[I_X/\\sqrt{2}]$')\nplt.plot(tsave[:-1], jnp.mean(Iks_p / np.sqrt(2), axis=0), label=r'$\\mathbb{E}[I_P/\\sqrt{2}]$')\n\nalpha = alpha0 * jnp.exp(-kappa / 2 * tsave) * jnp.exp(-1j * omega * tsave)\nplt.plot(tsave, alpha.real, label=rf'$\\mathrm{{Tr}}[X\\rho_t]$', ls='--', color='gray')\nplt.plot(tsave, alpha.imag, label=rf'$\\mathrm{{Tr}}[P\\rho_t]$', ls='--', color='gray')\n\nplt.gca().set(\n    title=r'Measurement averaged over all trajectories and theory prediction',\n    xlabel=r'$t$',\n    ylim=(-2.5, 2.5),\n)\nplt.legend()\nrenderfig('monitored-oscillator-mean')\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-jump-measurement.html","title":"Continuous jump measurement","text":""},{"location":"documentation/advanced_examples/continuous-jump-measurement.html#continuous-jump-measurement","title":"Continuous jump measurement","text":"<p>Work in progress.</p> <p>This tutorial is under construction, this is a draft version.</p> <p>In this example, we simulate stochastic trajectories of quantum systems that are continuously measured by a jump detector. We explain how to use <code>dq.jssesolve()</code> to simulate trajectories modelled by the jump SSE, and <code>dq.jsmesolve()</code> to simulate trajectories modelled by the jump SME.</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport dynamiqs as dq\n\ndq.plot.mplstyle(dpi=150)  # set custom matplotlib style\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-jump-measurement.html#qubit","title":"Qubit","text":"<p>We consider a qubit starting from \\(\\ket{\\psi_0}=\\ket1\\), with no unitary dynamic \\(H=0\\) and two loss operators \\(L_-=\\sigma_-\\) and \\(L_+=\\sigma_+\\) which are continuously measured by jump detectors. We expect stochastic trajectories jumping between the excited and ground state.</p> <p>Let's begin with a perfectly efficient detector. We start with a pure state, and we measure all loss channels with perfect efficiency, so we don't loose any information about the system's state. As a result, it remains pure at all times. We use <code>dq.jssesolve()</code> to simulate these quantum trajectories.</p>"},{"location":"documentation/advanced_examples/continuous-jump-measurement.html#simulation","title":"Simulation","text":"<pre><code># define Hamiltonian, jump operators, initial state\nH = dq.zeros(2)\njump_ops = [dq.sigmam(), dq.sigmap()]\npsi0 = dq.excited()\n\n# define save times\ntsave = np.linspace(0, 2.0, 101)\n\n# define a certain number of PRNG key, one for each trajectory\nkey = jax.random.PRNGKey(42)\nntrajs = 3\nkeys = jax.random.split(key, ntrajs)\n\n# simulate trajectories\nmethod = dq.method.EulerJump(dt=1e-3)\nresult = dq.jssesolve(H, jump_ops, psi0, tsave, keys, method=method)\nprint(result)\n</code></pre> Output<pre><code>==== JSSESolveResult ====\nMethod     : EulerJump\nInfos      : 1000 steps | infos shape (3,)\nStates     : QArray complex64 (3, 101, 2, 1) | 7.9 Kb\nClicktimes : Array float32 (3, 2, 10000) | 390.6 Kb\n</code></pre> <pre><code>&gt;&gt;&gt; result.states.shape  # (ntrajs, ntsave, n, 1)\n(3, 101, 2, 1)\n&gt;&gt;&gt; result.clicktimes.shape  # (ntrajs, nLm, nmaxclick)\n(3, 2, 10000)\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-jump-measurement.html#individual-state-trajectories","title":"Individual state trajectories","text":"<pre><code>_, axs = dq.plot.grid(ntrajs, ntrajs, w=5, h=3, sharexy=True)\n\nfor i in range(ntrajs):\n    ax = next(axs)\n    dq.plot.xyz(result.states[i], times=tsave, ax=ax)\n    ax.set(\n        title=f'Trajectory {i+1}: {result.nclicks[i].sum()} clicks',\n        xlabel=r'time $t$',\n        ylabel='Pauli expectation values',\n    )\n\nrenderfig('jump-monitored-qubit-trajs')\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-jump-measurement.html#imperfect-detection","title":"Imperfect detection","text":"<p>If the detection is imperfect, the system state is a density matrix. We use <code>dq.jsmesolve()</code> to simulate these quantum trajectories. For jump measurement we can model two classes of imperfections: false clicks (accounted by the dark count rate \\(\\theta\\)) and missed clicks (accounted by the efficiency \\(\\eta\\)).</p> <pre><code># define dark count rates\nthetas = [0.0, 0.0]\n# define efficiencies\netas = [0.5, 0.5]\n\n# simulate trajectories\nresult = dq.jsmesolve(H, jump_ops, thetas, etas, psi0, tsave, keys, method=method)\nprint(result)\n</code></pre> Output<pre><code>==== JSMESolveResult ====\nMethod     : EulerJump\nInfos      : 1000 steps | infos shape (3,)\nStates     : QArray complex64 (3, 101, 2, 2) | 9.5 Kb\nClicktimes : Array float32 (3, 2, 10000) | 234.4 Kb\n</code></pre> <pre><code>&gt;&gt;&gt; result.states.shape  # (ntrajs, ntsave, n, n)\n(3, 101, 2, 2)\n&gt;&gt;&gt; result.clicktimes.shape  # (ntrajs, nLm, nmaxclick)\n(3, 2, 10000)\n</code></pre> <pre><code>_, axs = dq.plot.grid(ntrajs, ntrajs, w=5, h=3, sharexy=True)\n\nfor i in range(ntrajs):\n    ax = next(axs)\n    dq.plot.xyz(result.states[i], times=tsave, ax=ax)\n    ax.set(\n        title=f'Trajectory {i+1}: {result.nclicks[i].sum()} clicks',\n        xlabel=r'time $t$',\n        ylabel='Pauli expectation values',\n    )\n\nrenderfig('jump-monitored-qubit-eta-trajs')\n</code></pre> <p></p>"},{"location":"documentation/advanced_examples/continuous-jump-measurement.html#quantum-harmonic-oscillator","title":"Quantum harmonic oscillator","text":"<p>We consider a quantum harmonic oscillator starting from the Fock state \\(\\ket{n_0}\\), with Hamiltonian \\(H=0\\) and a single loss operator \\(L=\\sqrt\\kappa a\\) which is continuously measured by photodetection.</p>"},{"location":"documentation/advanced_examples/continuous-jump-measurement.html#simulation_1","title":"Simulation","text":"<pre><code># define Hamiltonian, jump operators, initial state\nn = 16\na = dq.destroy(n)\nkappa = 1.0\nn0 = 10\nH = dq.zeros(n)\njump_ops = [jnp.sqrt(kappa) * a]\npsi0 = dq.fock(n, n0)\n\n# define save times\ntsave = np.linspace(0, 2.0, 101)\n\n# define a certain number of PRNG key, one for each trajectory\nkey = jax.random.PRNGKey(42)\nntrajs = 100\nkeys = jax.random.split(key, ntrajs)\n\n# simulate trajectories\nmethod = dq.method.EulerJump(dt=1e-3)\noptions = dq.Options(save_states=False)\nexp_ops = [a.dag() @ a]\nresult = dq.jssesolve(H, jump_ops, psi0, tsave, keys, method=method, options=options, exp_ops=exp_ops)\nprint(result)\n</code></pre> Output<pre><code>==== JSMESolveResult ====\nMethod     : EulerJump\nInfos      : 1000 steps | infos shape (1000,)\nStates     : QArray complex64 (100, 16, 1) | 2.0 Mb\nExpects    : Array complex64 (100, 1, 101) | 789.1 Kb\nClicktimes : Array float32 (100, 1, 10000) | 38.1 Mb\n</code></pre>"},{"location":"documentation/advanced_examples/continuous-jump-measurement.html#individual-trajectories-vs-average-trajectory-vs-lindblad-solution","title":"Individual trajectories vs average trajectory vs Lindblad solution","text":"<pre><code>exps_adaga = result.expects[:, 0, :].real\n</code></pre> <pre><code>kw = dict(lw=1.5, alpha=0.8)\n\n# individual trajectories\nfor i, exp in enumerate(exps_adaga[:4]):\n    plt.plot(tsave, exp, label=f'Trajectory {i+1}', **kw)\n\n# average trajectory\nplt.plot(tsave, exps_adaga.mean(0), label=f'Average trajectory', color='gray', **kw)\n\n# Lindblad solution\nresult_lindblad = dq.mesolve(H, jump_ops, psi0, tsave, options=options, exp_ops=exp_ops)\nplt.plot(tsave, result_lindblad.expects[0].real, ls='--', label=f'Lindblad', color='gray', **kw)\n\nplt.gca().set(\n    xlabel=r'time $t$',\n    ylabel=r'$\\langle a^\\dagger a \\rangle_t$',\n)\nplt.legend()\n\nrenderfig('jump-monitored-oscillator-trajs')\n</code></pre>"},{"location":"documentation/advanced_examples/kerr-oscillator.html","title":"Driven-dissipative Kerr oscillator","text":""},{"location":"documentation/advanced_examples/kerr-oscillator.html#driven-dissipative-kerr-oscillator","title":"Driven-dissipative Kerr oscillator","text":"<p>In this example, we show how to simulate a driven-dissipative Kerr oscillator in Dynamiqs. It is a simple example of a non-linear quantum harmonic oscillator with dissipative coupling to its environment. In the appropriate rotating frame, it is described by the master equation $$     \\frac{\\dd\\rho}{\\dt} = -i [H(t), \\rho] + \\kappa \\mathcal{D}[a] (\\rho), $$ with Hamiltonian $$     H(t) = -K a^{\\dagger 2} a^2 + \\epsilon(t) a^\\dagger + \\epsilon^*(t) a, $$ with \\(\\kappa\\) the rate of single-photon dissipation, \\(K\\) the Kerr non-linearity, and \\(\\epsilon(t)\\) the driving field.</p> <pre><code>import dynamiqs as dq\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\ndq.plot.mplstyle(dpi=150)  # set custom matplotlib style\n</code></pre>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#basic-time-evolution","title":"Basic time evolution","text":"<p>Let us begin with a simple simulation of the time evolution of this system, assuming that the driving field is constant and the system is initially in a coherent state.</p> <pre><code># simulation parameters\nn = 32         # Hilbert space size\nK = 1.0        # Kerr non-linearity\nepsilon = 3.0  # driving field\nkappa = 1.5    # dissipation rate\nalpha0 = 2.0   # initial coherent state amplitude\nT = 5.0        # simulation time\nntsave = 201   # number of saved states\n\n# operators\na = dq.destroy(n)\nH = -K * a.dag() @ a.dag() @ a @ a + epsilon * (a + a.dag())\njump_ops = [jnp.sqrt(kappa) * a]\n\n# initial state\npsi0 = dq.coherent(n, alpha0)\n\n# save times\ntsave = jnp.linspace(0.0, T, ntsave)\n\n# run simulation\nresult = dq.mesolve(H, jump_ops, psi0, tsave)\n</code></pre> <p>From this simulation, we can extract any property of the evolved state at any saved time. We can for instance access the number of photons in the final state using</p> <pre><code>&gt;&gt;&gt; dq.expect(a.dag() @ a, result.states[-1])\nArray(1.434+0.j, dtype=complex64)\n</code></pre> <p>Alternatively, we can also plot the Wigner function of the evolved state.</p> <pre><code>gif = dq.plot.wigner_gif(result.states, ymax=3.0, gif_duration=10.0)\nrendergif(gif, 'wigner-kerr-oscillator')\n</code></pre> <p></p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#periodic-revival-of-a-coherent-state","title":"Periodic revival of a coherent state","text":""},{"location":"documentation/advanced_examples/kerr-oscillator.html#time-evolution-of-the-cavity-field","title":"Time evolution of the cavity field","text":"<p>One of the most striking features of the Kerr oscillator is the periodic revival of the initial coherent state. This phenomenon is a direct consequence of the non-linear interaction between the photons in the cavity. We can observe this effect by plotting the absolute value of the cavity field as a function of time, for a simulation time over several units of Kerr, and as long as photon loss is not too important.</p> <pre><code># simulation parameters\nn = 32\nK = 1.0\nkappa = 0.02\nalpha0 = 2.0\nntsave = 201\n\n# operators\na = dq.destroy(n)\nH = -K * a.dag() @ a.dag() @ a @ a\njump_ops = [jnp.sqrt(kappa) * a]\n\n# initial state\npsi0 = dq.coherent(n, alpha0)\n\n# save times\nT = 5 * jnp.pi / K\ntsave = jnp.linspace(0.0, T, ntsave)\n\n# expectation operator\nexp_ops = [a]\n\n# run simulation\nresult = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops)\n\n# plot cavity field\nplt.plot(tsave * K / jnp.pi, jnp.abs(result.expects[0]))\nplt.xlabel(r'Time, $tK / \\pi$')\nplt.ylabel(r'$|\\langle a(t) \\rangle|$')\nrenderfig('photon-number-kerr-oscillator')\n</code></pre> <p></p> <p>We indeed observe a periodic revival of the coherent state, with a period of \\(\\pi / K\\). These revivals have a reduced amplitude due to the presence of photon loss.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#study-of-revivals","title":"Study of revivals","text":"<p>We can further investigate these periodic revivals by plotting the amplitude of the first revival as a function of the photon loss \\(\\kappa\\), and as a function of the initial coherent state amplitude. To do so, we make use of a powerful feature of Dynamiqs: the ability to batch simulations concurrently. Here, we can batch over both a jump operator and the initial state.</p> <pre><code># parameters to sweep\nkappas = jnp.linspace(0.0, 0.1, 11)\nnbar0s = jnp.linspace(0.4, 4.0, 10)\nalpha0s = jnp.sqrt(nbar0s)\n\n# redefine jump operators and initial states\njump_ops = [jnp.sqrt(kappas[:, None, None]) * a] # using numpy broadcasting\npsi0 = dq.coherent(n, alpha0s) # dq.coherent accepts a batched input\n\n# save times\nT = jnp.pi / K  # a single revival\ntsave = jnp.linspace(0.0, T, 100)\n\n# run batched simulation\nresult = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops)\namp_revivals = jnp.abs(result.expects[:, :, 0, -1] / result.expects[:, :, 0, 0])\n\n# plot a 2D map of the normalized amplitude revivals\ncontour = plt.pcolormesh(nbar0s, kappas / K, amp_revivals)\ncbar = plt.colorbar(contour, label=r'$|\\langle a(T) \\rangle / \\langle a(0) \\rangle |$')\nplt.xlabel(r'Initial coherent state amplitude, $\\bar{n}_0 = |\\alpha_0|^2$')\nplt.ylabel(r'Loss rate, $\\kappa / K$')\nplt.grid(False)\nrenderfig('amplitude-revivals-kerr-oscillator')\n</code></pre> <p></p> <p>We observe that the amplitude of the first revival decreases monotically with the photon loss rate \\(\\kappa\\), and with the initial coherent state amplitude \\(\\bar{n}\\). This behavior is consistent with the expected behavior of the Kerr oscillator. Remarkably, thanks to batching, such a set of hundreds of simulations can be run in a few seconds.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#the-transmon-regime","title":"The transmon regime","text":"<p>In this section, we investigate the driven-dissipative Kerr oscillator in the transmon regime, where the Kerr non-linearity is much larger than the driving field and the dissipation rate, \\(K \\gg |\\epsilon| \\gg \\kappa\\). In this regime, the two lowest-energy Fock states are frequency-detuned and thus decoupled from the rest of the system, allowing for quantum information processing.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#rabi-oscillations","title":"Rabi oscillations","text":"<p>Because this regime describes an effective two-level system, we can observe Rabi oscillations. These can be simulated by constant driving the system initialized in vacuum.</p> <pre><code># simulation parameters\nn = 8\nK = 200.0\nepsilon = 40.0\nkappa = 1.0\nT = 10 * jnp.pi / epsilon\nntsave = 401\n\n# operators\na = dq.destroy(n)\nH = -K * a.dag() @ a.dag() @ a @ a + epsilon * (a + a.dag())\njump_ops = [jnp.sqrt(kappa) * a]\n\n# initial state\npsi0 = dq.basis(n, 0)\n\n# save times\ntsave = jnp.linspace(0.0, T, ntsave)\n\n# expectation operator\nexp_ops = [dq.proj(dq.basis(n, 0)), dq.proj(dq.basis(n, 1))]\n\n# run simulation and extract observables\nresult = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops)\npop_0 = result.expects[0].real # population of |0&gt;\npop_1 = result.expects[1].real # population of |1&gt;\n\n# plot Rabi oscillations\nplt.plot(tsave * epsilon / jnp.pi, pop_0, label=r'$|0\\rangle$')\nplt.plot(tsave * epsilon / jnp.pi, pop_1, label=r'$|1\\rangle$')\nplt.plot(tsave * epsilon / jnp.pi, 1 - (pop_0 + pop_1), color='black', label=r'$|2\\rangle$, $|3\\rangle$, $\\ldots$')\nplt.xlabel(r'Time, $t\\epsilon / \\pi$')\nplt.ylabel('Population')\nplt.ylim(0, 1)\nplt.xlim(0, T * epsilon / jnp.pi)\nplt.legend(frameon=True)\nrenderfig('rabi-oscillations-kerr-oscillator')\n</code></pre> <p></p> <p>We indeed find Rabi oscillations between Fock states \\(|0\\rangle\\) and \\(|1\\rangle\\), with a period of \\(\\pi / \\epsilon\\). However, these oscillations are damped due to the presence of photon loss. In addition, we observe that a small fraction of the total population is periodically leaked to higher Fock states. This is because the Kerr oscillator is not a perfect two-level system, and the driving field is too large compared to the Kerr non-linearity.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#a-gaussian-pi-pulse","title":"A gaussian pi-pulse","text":"<p>We now study the optimization of a single-qubit gate for this effective two-level system, a crucial step in quantum information processing. More precisely, we aim to find the best parameters to maximize the fidelity of a \\(\\pi\\)-pulse, i.e., a pulse that swaps the populations of the two lowest-energy Fock states. To do so, we need to balance the amplitude damping due to photon loss with the leakage to higher excited states due to finite pulse duration.</p> <p>We define a pulse ansatz and optimize the \\(\\pi\\)-pulse fidelity by sweeping the parameters of this ansatz. The ansatz we study is that of a truncated gaussian, of the form</p> \\[     \\epsilon_{T, \\sigma}(t) = \\frac{\\pi}{2}\\frac{1}{\\sqrt{2\\pi}\\sigma T \\mathrm{erf}\\left(\\frac{1}{2\\sqrt{2} \\sigma}\\right)} \\exp\\left(-\\frac{1}{2}\\frac{(t - T/2)^2}{\\sigma^2 T^2}\\right), \\] <p>where \\(T\\) the gate duration, and \\(\\sigma\\) the normalized pulse width. One can easily check that the pulse area condition is satisfied, i.e.,</p> \\[     2\\int_0^T \\epsilon(t) \\dd t = \\pi. \\] <p>We begin by defining the pulse ansatz: </p><pre><code>from jax.scipy.special import erf\n\ndef pulse(t, T, sigma):\n    \"\"\"Gaussian pulse ansatz.\"\"\"\n    angle = jnp.pi / 2\n    norm = jnp.sqrt(2 * jnp.pi) * sigma * T * erf(1 / (2 * jnp.sqrt(2) * sigma))\n    gaussian = jnp.exp(-(t - T / 2)**2 / (2 * T**2 * sigma**2))\n    return angle * gaussian / norm\n</code></pre><p></p> <p>Then, we can define our sweeping parameters, and run the simulation by combining batching over <code>dq.modulated</code> to batch over the pulse width, and a <code>jax.vmap</code> to batch over the gate duration. </p><pre><code>from functools import partial\n\n# simulation parameters\nn = 8\nK = 200.0\nkappa = 1.0\nntsave = 401\n\n# parameters to sweep\nTs = jnp.linspace(0.05, 0.5, 24)\nsigmas = jnp.linspace(0.05, 0.2, 14)\n\n# operators, initial state, and expectation operator\na = dq.destroy(n)\nH0 = -K * a.dag() @ a.dag() @ a @ a\njump_ops = [jnp.sqrt(kappa) * a]\npsi0 = dq.basis(n, 0)\nexp_ops = [dq.proj(dq.basis(n, 0)), dq.proj(dq.basis(n, 1))]\n\n@jax.vmap\ndef compute_fidelity(T):\n    \"\"\"Compute the fidelity of a pi-pulse for a given gate duration.\"\"\"\n    # time-dependent Hamiltonian, defined with functools.partial and broadcasting\n    # `f` has signature (t: float) -&gt; Array of shape (len(sigmas),)\n    f = partial(pulse, T=T, sigma=sigmas)\n    H = H0 + dq.modulated(f, a + a.dag())\n\n    # save times\n    tsave = jnp.linspace(0.0, T, ntsave)\n\n    # run simulation\n    result = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops)\n\n    # fidelity is roughly estimated as the largest overlap with |1&gt;\n    # in a proper study, we would need to compute a full process tomography\n    return jnp.max(result.expects[:, 1, :].real, axis=-1)\n\n# run simulation\nfidelities = compute_fidelity(Ts)\n\n# plot results\nplt.pcolormesh(sigmas, Ts, jnp.log10(1-fidelities), cmap='Blues_r')\nplt.xlabel('Pulse width')\nplt.ylabel('Gate duration')\nplt.colorbar(label='log10(1 - Fidelity)')\nplt.grid(False)\nrenderfig('pipulse-kerr-oscillator')\n</code></pre><p></p> <p></p> <p>We observe that the fidelity of the \\(\\pi\\)-pulse is maximized over a band of pulse widths and gate durations. In practice, one wants to reduce the gate duration as much as possible, but this corresponds to large pulse widths. However, such large-width truncated gaussians are not physical because they do not verify \\(\\epsilon(0) = \\epsilon(T) = 0\\), and similarly for higher derivatives. This is a limitation of our gaussian ansatz, and one would need to consider more complex pulse shapes to optimize this \\(\\pi\\)-pulse in a realistic setting.</p>"},{"location":"documentation/advanced_examples/kerr-oscillator.html#optimization-with-grape","title":"Optimization with GRAPE","text":"<p>In this section, we turn to the numerical optimization of the \\(\\pi\\)-pulse using gradient ascent pulse engineering (GRAPE). This method consists of parametrizing the input pulse through a piece-wise constant function, and optimizing each parameter through gradient descent.</p> <p>To do so, we use the <code>optax</code> library for optimization, which provides a simple interface to various gradient descent algorithms. We define a loss function to minimize, which is the negative fidelity of the \\(\\pi\\)-pulse, and a smoothness loss to penalize sharp variations in the pulse. We then run the optimization loop.</p> <pre><code>import optax\n\n# simulation parameters\nn = 8\nK = 200.0\nkappa = 1.0\nT = 0.2\nntsave = 401\n\n# optimization parameters\nntpulse = 101       # number of pieces in the parametrized pulse\nnepochs = 300       # number of optimization epochs\nlearning_rate = 0.2 # gradient descent learning rate\n\n# operators, initial state, and expectation operator\na = dq.destroy(n)\nH0 = -K * a.dag() @ a.dag() @ a @ a\njump_ops = [jnp.sqrt(kappa) * a]\npsi0 = dq.basis(n, 0)\nexp_ops = [dq.proj(dq.basis(n, 0)), dq.proj(dq.basis(n, 1))]\n\n# save times and pulse times (not necessarely the same)\ntsave = jnp.linspace(0.0, T, ntsave)\ntpulse = jnp.linspace(0.0, T, ntpulse)\n\n# function to optimize\ndef compute_fidelity(amps):\n    # time-dependent Hamiltonian\n    # (sum of two piece-wise constant Hamiltonians and of the static Hamiltonian)\n    Hx = dq.pwc(tpulse, jnp.real(amps), a + a.dag())\n    Hp = dq.pwc(tpulse, jnp.imag(amps), 1j * (a - a.dag()))\n    H = H0 + Hx + Hp\n\n    # run simulation\n    options = dq.Options(progress_meter=False) # disable progress meter\n    result = dq.mesolve(H, jump_ops, psi0, tsave, exp_ops=exp_ops, options=options)\n\n    # fidelity is now defined as the overlap with |1&gt; at the final time only\n    return result.expects[1, -1].real\n\n# losses to minimize\n@jax.jit\ndef compute_fidelity_loss(amps, weight=1.0):\n    return weight * (1 - compute_fidelity(amps))\n\n@jax.jit\ndef compute_smoothness_loss(amps, weight=1e-4):\n    return weight * jnp.sum(jnp.abs(jnp.diff(jnp.pad(amps, 1)))**2)\n\n# seed amplitudes\namps_seed = 0.5 * jnp.pi / T * jnp.ones(ntpulse - 1) + 1j * jnp.zeros(ntpulse - 1)\n\n# optimization loop\noptimizer = optax.adam(learning_rate)\namps = amps_seed\nopt_state = optimizer.init(amps)\nlosses = []\nfor _ in range(nepochs):\n    # compute losses and their gradients with `jax.value_and_grad`\n    fidelity_loss, fidelity_grad = jax.value_and_grad(compute_fidelity_loss)(amps)\n    smoothness_loss, smoothness_grad = jax.value_and_grad(compute_smoothness_loss)(amps)\n    grads = fidelity_grad + smoothness_grad\n\n    # update amplitudes with optimizer\n    updates, opt_state = optimizer.update(grads.conj(), opt_state)\n    amps = optax.apply_updates(amps, updates)\n\n    # store losses\n    losses.append([fidelity_loss, smoothness_loss])\n\n# plot optimized pulse\ndq.plot.pwc_pulse(tpulse, amps)\nrenderfig('optimized-pulse-kerr-oscillator')\n</code></pre> <p></p> <p>We indeed find a smooth pulse, with a small contribution on the imaginary part corresponding to a drive on the conjugate quadrature. This is typical of an optimal transmon pulse, in which leakage is minimized through this additional drive in a process known as Derivative Removal by Adiabatic Gate (DRAG).</p> <p>We can also plot the evolution of the fidelity and smoothness losses during the optimization process.</p> <pre><code>losses = jnp.asarray(losses)\nplt.plot(losses[:, 0], label=\"Fidelity loss\")\nplt.plot(losses[:, 1], label=\"Smoothness loss\")\nplt.plot(losses[:, 0] + losses[:, 1], c='k', label=\"Total loss\")\nplt.ylim(0)\nplt.xlim(0, nepochs)\nplt.ylabel(\"Loss\")\nplt.xlabel(\"Epoch\")\nplt.legend()\nrenderfig('losses-kerr-oscillator')\n</code></pre> <p></p> <p>We find that the overall loss decreases monotonically, with a smoothness loss kept relatively low compared to the fidelity loss. We also find convergence of the loss function, indicating that the optimization process is successful. Of course, the hyper parameters such as the relative weight of each loss, the number of pulse time steps, the learning rate, or the number of epochs, could be further tuned.</p> <p>For optimal control applications, we also recommend checking out <code>qontrol</code> which is build on top of Dynamiqs, and provides a more advanced interface for pulse optimization.</p>"},{"location":"documentation/basics/batching-simulations.html","title":"Batching simulations","text":""},{"location":"documentation/basics/batching-simulations.html#batching-simulations","title":"Batching simulations","text":"<p>Batching allows running many independent simulations concurrently. It can dramatically speedup simulations, especially on GPUs. In this tutorial, we explain how to batch quantum simulations in Dynamiqs.</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport timeit\n</code></pre>"},{"location":"documentation/basics/batching-simulations.html#batching-in-short","title":"Batching in short","text":"<p>Batching in Dynamiqs is achieved by passing a list of Hamiltonians, initial states, or jump operators to the simulation functions. The result of a batched simulation is a single qarray that contains all the individual simulations results. For example, let's simulate the Schr\u00f6dinger equation for all combinations of the three Hamiltonians \\(\\{\\sigma_x, \\sigma_y, \\sigma_z\\}\\) and the four initial states \\(\\{\\ket{g}, \\ket{e}, \\ket{+}, \\ket{-}\\}\\):</p> <pre><code># define three Hamiltonians\nH = [dq.sigmax(), dq.sigmay(), dq.sigmaz()]  # (3, 2, 2)\n\n# define four initial states\ng = dq.basis(2, 0)\ne = dq.basis(2, 1)\nplus = (g + e).unit()\nminus = (g - e).unit()\npsi = [g, e, plus, minus]  # (4, 2, 1)\n\n# run the simulation\ntsave = jnp.linspace(0.0, 1.0, 11)  # (11,)\nresult = dq.sesolve(H, psi, tsave)\nprint(f'Shape of result.states: {result.states.shape}')\n</code></pre> Output<pre><code>Shape of result.states: (3, 4, 11, 2, 1)\n</code></pre> <p>The returned states is a qarray with shape (3, 4, 11, 2, 1), where 3 is the number of Hamiltonians, 4 is the number of initial states, 11 is the number of saved states, and (2, 1) is the shape of a single state.</p> <p>Note</p> <p>All relevant <code>result</code> attributes are batched. For example if you specified <code>exp_ops</code>, the resulting expectation values <code>result.expects</code> will be an array with shape (3, 4, len(exp_ops), 11).</p> <p>Importantly, batched simulations are not run sequentially in a <code>for</code> loop. What is meant by batching is that instead of evolving from initial to final time a single state with shape (2, 1) for each combination of argument, the whole batched state (3, 4, 2, 1) is evolved once from initial to final time, which is much more efficient.</p>"},{"location":"documentation/basics/batching-simulations.html#batching-modes","title":"Batching modes","text":"<p>There are two ways to batch simulations in Dynamiqs: cartesian batching and flat batching.</p>"},{"location":"documentation/basics/batching-simulations.html#cartesian-batching","title":"Cartesian batching","text":"<p>The simulation runs for all possible combinations of Hamiltonians, jump operators and initial states. This is the default mode.</p> <code>dq.sesolve</code><code>dq.mesolve</code> <p>For <code>dq.sesolve</code>, the returned qarray has shape: </p><pre><code>result.states.shape = (...H, ...psi0, ntsave, n, 1)\n</code></pre> where <code>...x</code> indicates the batching shape of <code>x</code>, i.e. its shape without the last two dimensions.<p></p> <p>Example: Cartesian batching with <code>dq.sesolve</code></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>psi0</code> has shape (4, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, ntsave, n, 1).</p> <p>For <code>dq.mesolve</code>, the returned qarray has shape: </p><pre><code>result.states.shape = (...H, ...L0, ...L1,  (...), ...rho0, ntsave, n, n)\n</code></pre> where <code>...x</code> indicates the batching shape of <code>x</code>, i.e. its shape without the last two dimensions.<p></p> <p>Example: Cartesian batching with <code>dq.mesolve</code></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(4, 5, n, n), (6, n, n)],</li> <li><code>rho0</code> has shape (7, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, 5, 6, 7, ntsave, n, n).</p>"},{"location":"documentation/basics/batching-simulations.html#flat-batching","title":"Flat batching","text":"<p>The simulation runs for each set of Hamiltonians, jump operators and initial states using broadcasting. This mode can be activated by passing <code>options=dq.Options(cartesian_batching=False)</code>. In particular for <code>dq.mesolve()</code>, each jump operator can be batched independently from the others.</p> What is broadcasting? <p>JAX and NumPy broadcasting semantics are very powerful and allow you to write concise and efficient code. For more information, see the NumPy documentation on broadcasting.</p> <code>dq.sesolve</code><code>dq.mesolve</code> <p>For <code>dq.sesolve</code>, the returned qarray has shape: </p><pre><code>result.states.shape = (..., ntsave, n, 1)\n</code></pre> where <code>... = jnp.broadcast_shapes(H, psi0)</code> is the broadcasted shape of all arguments.<p></p> <p>Example: Flat batching with <code>dq.sesolve</code></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>psi0</code> has shape (3, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntsave, n, 1).</p> <p>For <code>dq.mesolve</code>, the returned qarray has shape: </p><pre><code>result.states.shape = (..., ntsave, n, n)\n</code></pre> where <code>... = jnp.broadcast_shapes(H, L0, L1, ..., rho0)</code> is the broadcasted shape of all arguments.<p></p> <p>Example: Flat batching with <code>dq.mesolve</code></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(3, n, n), (2, 1, n, n)],</li> <li><code>rho0</code> has shape (3, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntsave, n, n).</p> <p>Note</p> <p>Any batch shape is valid as input as long as it is broadcastable with other arguments.</p> <p>For example for <code>dq.sesolve()</code> with <code>H</code> of shape (2, 3, n, n), <code>psi0</code> can be of shape: (n, 1), (3, n, 1), (2, 1, n, 1), (2, 3, n, 1), (..., 2, 3, n, 1), etc. By playing with the arguments shape, you have complete freedom over the simulation you want to run.</p>"},{"location":"documentation/basics/batching-simulations.html#creating-batched-arguments","title":"Creating batched arguments","text":""},{"location":"documentation/basics/batching-simulations.html#single-dimensional-batching","title":"Single-dimensional batching","text":"<p>There are multiple ways to create a batched argument.</p> Using listsUsing JAX broadcastingUsing Dynamiqs functions <p>The most straightforward way is to pass a list of values: </p><pre><code># define several Hamiltonians\nHx, Hy, Hz = dq.sigmax(), dq.sigmay(), dq.sigmaz()\nH = [Hx, Hy, Hz]  # (3, 2, 2)\n</code></pre><p></p> <p>It is often useful to sweep a parameter: </p><pre><code># define several Hamiltonians\nomega = jnp.linspace(0.0, 1.0, 21)\nH = omega[:, None, None] * dq.sigmaz()  # (21, 2, 2)\n</code></pre><p></p> <p>Or you can use Dynamiqs utility functions directly: </p><pre><code># define several initial states\nalpha = [1.0, 2.0, 3.0]\npsis = dq.coherent(16, alpha)  # (3, 16, 1)\n</code></pre><p></p>"},{"location":"documentation/basics/batching-simulations.html#multi-dimensional-batching","title":"Multi-dimensional batching","text":"<p>The previous examples illustrate batching over one dimension, but you can batch over as many dimensions as you want:</p> Using listsUsing JAX broadcastingUsing Dynamiqs functions <pre><code># define several Hamiltonians\nH = [\n    [Hx, 2 * Hx, 3 * Hx, 4 * Hx],\n    [Hy, 2 * Hy, 3 * Hy, 4 * Hy],\n    [Hz, 2 * Hz, 3 * Hz, 4 * Hz]\n]  # (3, 4, 2, 2)\n</code></pre> <pre><code># define several Hamiltonians\nomega = jnp.linspace(0.0, 1.0, 21)[:, None, None, None]\neps = jnp.linspace(0.0, 10.0, 11)[:, None, None]\nH = omega * dq.sigmaz() + eps * dq.sigmaz()  # (21, 11, 2, 2)\n</code></pre> <pre><code># define several initial states\nalpha_real = jnp.linspace(0, 1.0, 5)\nalpha_imag = jnp.linspace(0, 1.0, 6)\nalpha = alpha_real[:, None] + 1j * alpha_imag  # (5, 6)\npsis = dq.coherent(16, alpha)  # (5, 6, 16, 1)\n</code></pre>"},{"location":"documentation/basics/batching-simulations.html#batching-over-a-timeqarray","title":"Batching over a timeqarray","text":"<p>We have seen how to batch over time-independent objects, but how about time-dependent ones? It's essentially the same, you have to pass a batched <code>TimeQArray</code>, in short:</p> For a <code>PWCTimeQArray</code>For a <code>ModulatedTimeQArray</code>For a <code>CallableTimeQArray</code> <p>The batching of the returned timeqarray is specified by <code>values</code>. For example, to define a PWC operator batched over a parameter \\(\\theta\\): </p><pre><code>&gt;&gt;&gt; thetas = jnp.linspace(0.0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; times = [0.0, 1.0, 2.0]\n&gt;&gt;&gt; values = thetas[:, None] * jnp.array([3.0, -2.0])  # (11, 2)\n&gt;&gt;&gt; qarray = dq.sigmaz()\n&gt;&gt;&gt; H = dq.pwc(times, values, qarray)\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre><p></p> <p>The batching of the returned timeqarray is specified by the qarray returned by <code>f</code>. For example, to define a modulated Hamiltonian \\(H(t)=\\cos(\\omega t)\\sigma_x\\) batched over the parameter \\(\\omega\\): </p><pre><code>&gt;&gt;&gt; omegas = jnp.linspace(0.0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; f = lambda t: jnp.cos(omegas * t)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre><p></p> <p>The batching of the returned timeqarray is specified by the qarray returned by <code>f</code>. For example, to define an arbitrary time-dependent operator batched over a parameter \\(\\theta\\): </p><pre><code>&gt;&gt;&gt; thetas = jnp.linspace(0.0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; f = lambda t: thetas[:, None, None] * dq.asqarray([[t, 0], [0, 1 - t]])\n&gt;&gt;&gt; H = dq.timecallable(f)\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre><p></p>"},{"location":"documentation/basics/batching-simulations.html#why-batching","title":"Why batching?","text":"<p>When batching multiple simulations, the state is not a 2-D qarray that evolves in time but a N-D qarray which holds all independent simulations. This allows running multiple simulations simultaneously with great efficiency, especially on GPUs. Moreover, it usually simplifies the simulation code and also the subsequent analysis of the results, because they are all gathered in a single large qarray.</p> <p>Common use cases for batching include:</p> <ul> <li>simulating a system with different values of a parameter (e.g. a drive amplitude),</li> <li>simulating a system with different initial states (e.g. for gate tomography),</li> <li>performing an optimisation using multiple starting points with random initial guesses (for parameters fitting or quantum optimal control).</li> </ul>"},{"location":"documentation/basics/batching-simulations.html#quick-benchmark","title":"Quick benchmark","text":"<p>To illustrate the performance gain of batching, let us compare the total run time between using a for loop vs using a batched simulation. We will simulate a set of 3,000 Hamiltonians on a two-level system:</p> <pre><code># define 3000 Hamiltonians\nomega = jnp.linspace(0.0, 10.0, 100)[:, None, None]\nepsilon = jnp.linspace(0.0, 1.0, 30)[:, None, None, None]\nH = omega * dq.sigmaz() + epsilon * dq.sigmax()  # (100, 30, 2, 2)\n\n# other simulation parameters\npsi0 = dq.basis(2, 0)\ntsave = jnp.linspace(0.0, 1.0, 50)\noptions = dq.Options(progress_meter=False)\n\n# running the simulations successively\ndef run_unbatched():\n    results = []\n    for i in range(len(omega)):\n        for j in range(len(epsilon)):\n            result = dq.sesolve(H[i, j], psi0, tsave, options=options)\n            results.append(result)\n    return results\n\n# running the simulations simultaneously\ndef run_batched():\n    return dq.sesolve(H, psi0, tsave, options=options)\n\n# exclude JIT time from benchmarking by running each function once first\n%timeit -n1 -r1 -q run_unbatched()\n%timeit -n1 -r1 -q run_batched()\n\n# time functions\n%timeit run_unbatched()\n%timeit run_batched()\n</code></pre> Output<pre><code>2.59 s \u00b1 52.8 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n44.1 ms \u00b1 2.66 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</code></pre> <p>As we can see, the batched simulation is much faster than the unbatched one. In this simple example, it is about 60 times faster. The gain in performance will be even more significant for larger simulations, or when using a GPU.</p>"},{"location":"documentation/basics/closed-systems.html","title":"Closed systems","text":""},{"location":"documentation/basics/closed-systems.html#closed-systems","title":"Closed systems","text":"<p>This tutorial introduces the quantum state for a closed quantum system, describes its evolution with the Schr\u00f6dinger equation, and explains two common numerical methods to simulate the evolution: computing the propagator or solving the ODE iteratively.</p>"},{"location":"documentation/basics/closed-systems.html#the-quantum-state","title":"The quantum state","text":"<p>The quantum state that describes a closed quantum system is a state vector \\(\\ket\\psi\\), i.e. a column vector of size \\(n\\)(1): $$     \\ket\\psi=     \\begin{pmatrix}     \\alpha_0\\\\     \\vdots\\\\     \\alpha_{n-1}     \\end{pmatrix}, $$ with \\(\\alpha_0,\\dots,\\alpha_{n-1}\\in\\mathbb{C}\\) and such that \\(\\sum |\\alpha_i|^2=1\\) (the state is a unit vector).</p> <ol> <li>Where \\(n\\) is the dimension of the finite-dimensional complex Hilbert space of the system.</li> </ol> <p>Example for a two-level system</p> <p>For a two-level system, \\(\\ket\\psi=\\begin{pmatrix}\\alpha_0\\\\\\alpha_1\\end{pmatrix}\\) with \\(|\\alpha_0|^2+|\\alpha_1|^2=1\\).</p> <p>Numerically, each coefficient of the state is stored as a complex number represented by two real numbers (the real and the imaginary parts), stored either</p> <ul> <li>in single precision: the <code>complex64</code> type which uses two <code>float32</code>,</li> <li>in double precision: the <code>complex128</code> type which uses two <code>float64</code>.</li> </ul> <p>A greater precision will give a more accurate result, but will also take longer to calculate.</p>"},{"location":"documentation/basics/closed-systems.html#the-schrodinger-equation","title":"The Schr\u00f6dinger equation","text":"<p>The state evolution is described by the Schr\u00f6dinger equation: $$     i\\hbar\\frac{\\dd\\ket{\\psi(t)}}{\\dt}=H\\ket{\\psi(t)}, $$ where \\(H\\) is a linear operator called the Hamiltonian, a matrix of size \\(n\\times n\\). This equation is a first-order (linear and homogeneous) ordinary differential equation (ODE). To simplify notations, we set \\(\\hbar=1\\). In this tutorial we consider a constant Hamiltonian, but note that it can also be time-dependent \\(H(t)\\).</p> <p>Example for a two-level system</p> <p>The Hamiltonian of a two-level system with energy difference \\(\\omega\\) is \\(H=\\frac{\\omega}{2}\\sigma_z=\\begin{pmatrix}\\omega/2&amp;0\\\\0&amp;-\\omega/2\\end{pmatrix}\\).</p>"},{"location":"documentation/basics/closed-systems.html#solving-the-schrodinger-equation-numerically","title":"Solving the Schr\u00f6dinger equation numerically","text":"<p>There are two common ideas for solving the Schr\u00f6dinger equation.</p>"},{"location":"documentation/basics/closed-systems.html#computing-the-propagator","title":"Computing the propagator","text":"<p>The state at time \\(t\\) is given by \\(\\ket{\\psi(t)}=e^{-iHt}\\ket{\\psi(0)}\\), where \\(\\psi(0)\\) is the state at time \\(t=0\\). The operator \\(U(t)=e^{-iHt}\\) is called the propagator, a matrix of size \\(n\\times n\\).</p> Solution for a time-dependent Hamiltonian <p>For a time-dependent Hamiltonian \\(H(t)\\), the solution at time \\(t\\) is $$     \\ket{\\psi(t)} = \\mathscr{T}\\exp\\left(-i\\int_0^tH(t')\\dt'\\right)\\ket{\\psi(0)}, $$ where \\(\\mathscr{T}\\) is the time-ordering symbol, which indicates the time-ordering of the Hamiltonians upon expansion of the matrix exponential (Hamiltonians at different times do not commute).</p> <p>The first idea is to explicitly compute the propagator to evolve the state up to time \\(t\\). There are various ways to compute the matrix exponential, such as exact diagonalization of the Hamiltonian or approximate methods such as truncated Taylor series expansions.</p> <p>Space complexity: \\(O(n^2)\\) (storing the Hamiltonian).</p> <p>Time complexity: \\(O(n^3)\\) (complexity of computing the matrix exponential(1)).</p> <ol> <li>Computing a matrix exponential requires a few matrix multiplications, and the time complexity of multiplying two dense matrices of size \\(n\\times n\\) is \\(\\mathcal{O(n^3)}\\).</li> </ol> <p>Example for a two-level system</p> <p>For \\(H=\\frac{\\omega}{2}\\sigma_z\\), the propagator is straightforward to compute: $$     U(t) = e^{-iHt} = \\begin{pmatrix}e^{-i\\omega t/2} &amp; 0 \\\\ 0 &amp; e^{i\\omega t/2}\\end{pmatrix}. $$</p>"},{"location":"documentation/basics/closed-systems.html#integrating-the-ode","title":"Integrating the ODE","text":"<p>The Schr\u00f6dinger equation is an ODE, for which a wide variety of methods have been developed. The simplest approach is the Euler method, a first-order ODE method with a fixed step size which we describe shortly. Let us write the Taylor series expansion of the state at time \\(t+\\dt\\) up to first order: $$     \\begin{aligned}         \\ket{\\psi(t+\\dt)} &amp;= \\ket{\\psi(t)}+\\dt\\frac{\\dd\\ket{\\psi(t)}}{\\dt}+\\mathcal{O}(\\dt^2) \\\\         &amp;\\approx \\ket{\\psi(t)}-iH\\dt\\ket{\\psi(t)},     \\end{aligned} $$ where we used the Schr\u00f6dinger equation to replace the time derivative of the state. By choosing a sufficiently small step size \\(\\dt\\) and starting from \\(\\ket{\\psi(0)}\\), the state is then iteratively evolved to a final time using the previous equation.</p> <p>There are two main types of ODE methods:</p> <ul> <li>Fixed step size: as with the Euler method, the step size \\(\\dt\\) is fixed during the simulation. The best known higher order methods are the Runge-Kutta methods. It is important for all these methods that the time step is sufficiently small to ensure the accuracy of the solution.</li> <li>Adaptive step size: the step size is automatically adjusted during the simulation, at each time step. A well-known method is the Dormand-Prince method.</li> </ul> <p>Space complexity: \\(O(n^2)\\) (storing the Hamiltonian).</p> <p>Time complexity: \\(O(n^2\\times\\text{number of time steps})\\) (complexity of the matrix-vector product at each time step).</p>"},{"location":"documentation/basics/closed-systems.html#using-dynamiqs","title":"Using Dynamiqs","text":"<p>You can create the state and Hamiltonian using any qarray-like. Let's take the example of a two-level system with a simple Hamiltonian:</p> <pre><code>import jax.numpy as jnp\nimport dynamiqs as dq\n\njnp.set_printoptions(precision=3, suppress=True)  # set custom array print style\n\npsi0 = dq.ground()                # initial state\nH = dq.sigmaz()                   # Hamiltonian\ntsave = jnp.linspace(0, 1.0, 11)  # saving times\nres = dq.sesolve(H, psi0, tsave)  # run the simulation\nprint(res.states[-1])             # print the final state\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 2.52ms \u25c6 remaining 0.00ms\nQArray: shape=(2, 1), dims=(2,), dtype=complex64, layout=dense\n[[0.  +0.j   ]\n [0.54+0.841j]]\n</code></pre> <p>If you want to know more about the available methods or the different options, head to the <code>dq.sesolve()</code> API documentation.</p> <p>You can also directly compute the propagator with the <code>dq.sepropagator()</code> solver. Continuing the last example:</p> <pre><code>res = dq.sepropagator(H, tsave)\nprint(res.propagators[-1])  # print the final propagator\n</code></pre> Output<pre><code>QArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[0.54-0.841j 0.  +0.j   ]\n [0.  +0.j    0.54+0.841j]]\n</code></pre>"},{"location":"documentation/basics/computing-gradients.html","title":"Computing gradients","text":""},{"location":"documentation/basics/computing-gradients.html#computing-gradients","title":"Computing gradients","text":"<p>Work in progress.</p> <p>This tutorial is under construction. In the meantime, you can check out this example that shows how to differentiate an expectation value obtained with <code>dq.mesolve()</code> with respect to simulation parameters.</p>"},{"location":"documentation/basics/floquet-integration.html","title":"Floquet integration","text":""},{"location":"documentation/basics/floquet-integration.html#floquet-integration","title":"Floquet Integration","text":"<p>This tutorial introduces Floquet integration, why it is useful and how it is implemented numerically.</p>"},{"location":"documentation/basics/floquet-integration.html#floquets-theorem","title":"Floquet's Theorem","text":"<p>Consider a Hamiltonian that is periodic with period \\(T\\), \\(H(t+T)=H(t)\\). Floquet's theorem states that solutions to the corresponding Schr\u00f6dinger equation can be written as $$     |\\Psi_{m}(t)\\rangle = e^{-i\\epsilon_{m}t}|\\phi_{m}(t)\\rangle $$ where \\(m\\) indexes the states, \\(\\epsilon_m\\) is the so-called quasienergy with Floquet modes \\(|\\phi_{m}(t)\\rangle\\) and Floquet states \\(|\\Psi_{m}(t)\\rangle\\). The Floquet modes \\(|\\phi_{m}(t)\\rangle\\) are also time periodic, \\(|\\phi_{m}(t+T)\\rangle=|\\phi_{m}(t)\\rangle\\). Floquet's theorem is in complete analogy to Bloch's theorem in 3 dimensions for a particle in a periodic potential.</p> <p>A numerical recipe for computing Floquet modes and quasienergies is obtained by using the definition of the Floquet states. On the one hand, we have $$ \\begin{aligned}     |\\Psi_{m}(t+T)\\rangle &amp;= e^{-i\\epsilon_{m}(t+T)}|\\phi_{m}(t+T)\\rangle \\\\                           &amp;= e^{-i\\epsilon_{m}(t+T)}|\\phi_{m}(t)\\rangle. \\end{aligned} $$ On the other hand, the time-propagated Floquet state \\(|\\Psi_{m}(t+T)\\rangle\\) can be obtained from the propagator $$     |\\Psi_{m}(t+T)\\rangle=U(0,T)|\\Psi_{m}(t)\\rangle. $$ Thus, we find that the Floquet modes at \\(t=0\\) satisfy an eigenvalue equation $$     U(0,T)|\\phi_{m}(0)\\rangle=e^{-i\\epsilon_{m}T}|\\phi_{m}(0)\\rangle, $$ where the eigenvalues are exponentials of the quasienergies. Therefore, one means of obtaining the \\(t=0\\) Floquet modes and associated quasienergies is to diagonalize the propagator \\(U(0,T)\\). The Floquet modes at other times can then be immediately obtained from the Floquet modes at \\(t=0\\) by noting that $$ \\begin{aligned}     |\\Psi_{m}(t)\\rangle &amp;= e^{-i\\epsilon_{m}t}|\\phi_{m}(t)\\rangle \\\\         &amp;= U(0,t)|\\Psi_{m}(0)\\rangle \\\\         &amp;= U(0,t)|\\phi_{m}(0)\\rangle. \\end{aligned} $$ From the first and the last equality we then obtain $$     |\\phi_{m}(t)\\rangle=e^{i\\epsilon_{m}t}U(0,t)|\\phi_{m}(0)\\rangle. $$ Oftentimes, this procedure must be done numerically if the Hamiltonian is time dependent. However, there are simple cases that can be treated analytically, one of which we explore below to demonstrate the technique and build intuition.</p>"},{"location":"documentation/basics/floquet-integration.html#driven-qubit","title":"Driven qubit","text":"<p>Let us consider a driven qubit within the rotating-wave approximation (RWA), $$     H(t) = -\\frac{\\omega}{2}\\sigma_{z}+\\frac{A}{2}(\\sigma_{+}e^{-i\\omega_{d}t} + \\mathrm{h.c.}), $$ where \\(\\sigma_{+}=|1\\rangle\\langle0|\\). We can straightforwardly solve for the propagator associated with this Hamiltonian by first moving into a rotating frame (also called interaction frame) defined by the unitary transformation \\(U_{r}(t)=\\exp(i\\omega_{d}t\\sigma_{z}/2)\\). The Hamiltonian in the rotating frame is $$     H'(t)=U_{r}^{\\dagger} H(t)U_{r}-iU_{r}^{\\dagger}\\dot{U_{r}} =-\\frac{\\Delta}{2}\\sigma_{z}+\\frac{A}{2}\\sigma_{x}, $$ where \\(\\Delta=\\omega-\\omega_{d}\\). This is a time-independent Hamiltonian, for which we can obtain the propagator immediately by exponentiation. The propagator in this frame after one period of the drive is $$     U'(0,T) = \\cos\\left(\\frac{\\Omega t}{2}\\right)I-i\\frac{\\sin(\\frac{\\Omega t}{2})}{\\Omega}\\left(-\\Delta\\sigma_{z} + A\\sigma_{x}\\right), $$ where \\(\\Omega=\\sqrt{\\Delta^2+A^2}.\\) To obtain the Floquet modes and quasienergies, we need to diagonalize this propagator. This 2x2 matrix can be diagonalized by hand, or with symbolic algebra software, yielding the eigenvalues $$     \\eta_{\\pm} = e^{-i(\\pm\\Omega T/2)}, $$ and associated (unnormalized) eigenvectors $$     |\\epsilon_{\\pm}\\rangle = \\left(      \\begin{matrix}         1 \\\\ \\frac{\\epsilon}{\\Delta\\pm\\Omega}     \\end{matrix}     \\right). $$ The quasienergies are thus \\(\\epsilon_{\\pm} = \\pm \\Omega/2\\). We can simplify the form of the eigenvectors by using some trigonometric identities. We first define \\(\\Delta/\\Omega = \\cos(\\theta), \\epsilon/\\Omega = \\sin(\\theta)\\). We then multiply the eigenvectors by successive constants to simplify them. For instance, for \\(|\\epsilon_{+}\\rangle\\) we obtain $$     |\\epsilon_{+}\\rangle = \\left(      \\begin{matrix}         1 \\\\ \\frac{\\epsilon}{\\Delta+\\Omega}     \\end{matrix}     \\right) \\rightarrow      \\left(      \\begin{matrix}         \\Delta + \\Omega \\\\ \\epsilon     \\end{matrix}     \\right)     \\rightarrow     \\left(      \\begin{matrix}         1 + \\Delta/\\Omega \\\\ \\epsilon/\\Omega     \\end{matrix}     \\right)     =\\left(      \\begin{matrix}         1 + \\cos\\theta \\\\ \\sin\\theta     \\end{matrix}     \\right). $$ Normalizing and noting that \\(1 + \\cos\\theta=2\\cos^2\\tfrac{\\theta}{2}\\) and \\(\\sin\\theta=2\\sin\\tfrac{\\theta}{2}\\cos\\tfrac{\\theta}{2}\\), we obtain $$     |\\epsilon_{+}\\rangle = \\left(      \\begin{matrix}         \\cos\\tfrac{\\theta}{2} \\\\ \\sin\\tfrac{\\theta}{2}     \\end{matrix}     \\right). $$ By a similar analysis, we find for the other eigenvector $$     |\\epsilon_{-}\\rangle = \\left(      \\begin{matrix}         \\sin\\tfrac{\\theta}{2} \\\\ -\\cos\\tfrac{\\theta}{2}     \\end{matrix}     \\right). $$ This example is used as an analytical test for the Floquet functionality of Dynamiqs.</p>"},{"location":"documentation/basics/floquet-integration.html#finding-floquet-modes-and-quasienergies-using-dynamiqs","title":"Finding Floquet modes and quasienergies using Dynamiqs","text":"<p>Let us now consider a truly time-dependent example for which there is no analytical solution: the Rabi model of a driven two-level system.</p> <pre><code>import jax.numpy as jnp\nimport dynamiqs as dq\n\njnp.set_printoptions(precision=3, suppress=True)  # set custom array print style\n\nT = 1.0                             # drive period\nomega_d = 2 * jnp.pi / T            # drive frequency\nH0 = 0.1 * dq.sigmaz()              # drift Hamiltonian\nf = lambda t: jnp.cos(omega_d * t)  # time-dependent drive\nH1 = dq.modulated(f, dq.sigmax())   # drive Hamiltonian\ntsave = jnp.linspace(0, T, 11)      # saving times\nres = dq.floquet(H0 + H1, T, tsave)  # run the simulation\nprint(res.quasienergies)            # print the quasienergies\nprint(res.modes[-1])                # print the final floquet modes\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 1.99ms \u25c6 remaining 0.00ms\n[ 0.972 -0.972]\nQArray: shape=(2, 2, 1), dims=(2,), dtype=complex64, layout=dense\n[[[ 0.998+0.j]\n  [-0.055-0.j]]\n\n [[ 0.055-0.j]\n  [ 0.998+0.j]]]\n</code></pre>"},{"location":"documentation/basics/open-systems.html","title":"Open systems","text":""},{"location":"documentation/basics/open-systems.html#open-systems","title":"Open systems","text":"<p>This tutorial introduces the quantum state for an open quantum system, describes its evolution with the Lindblad master equation, and explains three common numerical methods to simulate the evolution: computing the propagator, solving the ODE iteratively or sampling trajectories.</p>"},{"location":"documentation/basics/open-systems.html#the-quantum-state","title":"The quantum state","text":"<p>The quantum state that describes an open quantum system is a density matrix \\(\\rho\\). It is a positive semi-definite Hermitian matrix with unit trace, of size \\(n\\times n\\)(1).</p> <ol> <li>Where \\(n\\) is the dimension of the finite-dimensional complex Hilbert space of the system.</li> </ol> <p>Example for a two-level system</p> <p>For a two-level system, \\(\\rho=\\begin{pmatrix}a &amp; b\\\\ c &amp; d\\end{pmatrix}\\) with \\(a,d\\in\\R^+\\) and \\(b,c\\in\\mathbb{C}\\) with \\(b^*=c\\) (Hermitian matrix), \\(a+d=1\\) (unit trace) and all its eigenvalues are positive (positive semi-definite).</p> <p>Numerically, each coefficient of the state is stored as a complex number represented by two real numbers (the real and the imaginary parts), stored either</p> <ul> <li>in single precision: the <code>complex64</code> type which uses two <code>float32</code>,</li> <li>in double precision: the <code>complex128</code> type which uses two <code>float64</code>.</li> </ul> <p>A greater precision will give a more accurate result, but will also take longer to calculate.</p>"},{"location":"documentation/basics/open-systems.html#the-lindblad-master-equation","title":"The Lindblad master equation","text":"<p>The state evolution is described by the Lindblad master equation: $$     \\frac{\\dd\\rho(t)}{\\dt} = -\\frac{i}{\\hbar}[H, \\rho(t)] + \\sum_{k=1}^N \\left(L_k \\rho(t) L_k^\\dag - \\frac{1}{2} L_k^\\dag L_k \\rho(t) - \\frac{1}{2} \\rho(t) L_k^\\dag L_k\\right), $$ where \\(H\\) is a linear operator called the Hamiltonian, a matrix of size \\(n\\times n\\), and \\(\\{L_k\\}\\) is a collection of arbitrary operators called jump operators which are also matrices of size \\(n\\times n\\). This equation is a first-order (linear and homogeneous) ordinary differential equation (ODE). To simplify notations, we set \\(\\hbar=1\\). In this tutorial we consider a constant Hamiltonian and jump operators, but note that they can also be time-dependent \\(H(t)\\) and \\(L_k(t)\\).</p> <p>Example for a two-level system</p> <p>For example, \\(H=\\frac{\\omega}{2}\\sigma_z=\\begin{pmatrix}\\omega/2&amp;0\\\\0&amp;-\\omega/2\\end{pmatrix}\\) and a single jump operator \\(L=\\sqrt\\gamma\\sigma_-=\\begin{pmatrix}0&amp;0\\\\\\sqrt\\gamma&amp;0\\end{pmatrix}\\).</p> <p>We can also write $$     \\frac{\\dd\\rho(t)}{\\dt} = \\mathcal{L}(\\rho(t)), $$ where \\(\\mathcal{L}\\) is a superoperator(1) called the Liouvillian (sometimes referred as Lindbladian). We can write the state and Liouvillian in vectorized form, where we see the state \\(\\rho(t)\\) as a column vector of size \\(n^2\\), and the Liouvillian as a matrix of size \\(n^2\\times n^2\\).</p> <ol> <li>A superoperator is a linear map that takes an operator and returns an operator.</li> </ol> <p>Example for a two-level system</p> <p>For example, for \\(H=\\frac{\\omega}{2}\\sigma_z\\) and a single jump operator \\(L=\\sqrt\\gamma\\sigma_-\\), the Liouvillian in vectorized form is a \\(4\\times4\\) matrix: $$     \\mathcal{L} = \\begin{pmatrix}     -\\gamma &amp; 0 &amp; 0 &amp; 0\\\\     0 &amp; -\\gamma/2+\\omega i &amp; 0 &amp; 0\\\\     0 &amp; 0 &amp; -\\gamma/2-\\omega i &amp; 0\\\\     \\gamma &amp; 0 &amp; 0 &amp; 0\\\\     \\end{pmatrix} $$</p>"},{"location":"documentation/basics/open-systems.html#solving-the-lindblad-master-equation-numerically","title":"Solving the Lindblad master equation numerically","text":"<p>There are three common ideas for solving the Lindblad master equation.</p>"},{"location":"documentation/basics/open-systems.html#computing-the-propagator","title":"Computing the propagator","text":"<p>The state at time \\(t\\) is given by \\(\\rho(t)=e^{t\\mathcal{L}}(\\rho(0))\\), where \\(\\rho(0)\\) is the state at time \\(t=0\\). The superoperator \\(e^{t\\mathcal{L}}\\) is called the propagator, in vectorized form it is a matrix of size \\(n^2\\times n^2\\).</p> Solution for a time-dependent Liouvillian <p>For a time-dependent Liouvillian \\(\\mathcal{L}(t)\\), the solution at time \\(t\\) is $$     \\rho(t) = \\mathscr{T}\\exp\\left(\\int_0^t\\mathcal{L}(t')\\dt'\\right)(\\rho(0)), $$ where \\(\\mathscr{T}\\) is the time-ordering symbol, which indicates the time-ordering of the Liouvillians upon expansion of the matrix exponential (Liouvillians at different times do not commute).</p> <p>The first idea is to explicitly compute the propagator to evolve the state up to time \\(t\\). There are various ways to compute the matrix exponential, such as exact diagonalization of the Liouvillian or approximate methods such as truncated Taylos series expansions.</p> <p>Space complexity: \\(O(n^4)\\) (storing the Liouvillian).</p> <p>Time complexity: \\(O(n^6)\\) (complexity of computing the \\(n^2\\times n^2\\) Liouvillian matrix exponential(1)).</p> <ol> <li>Computing a matrix exponential requires a few matrix multiplications, and the time complexity of multiplying two dense matrices of size \\(n\\times n\\) is \\(\\mathcal{O(n^3)}\\).</li> </ol> <p>For large Hilbert space sizes, the time complexity of computing the matrix exponential is often prohibitive, hence the need for other methods such as the ones we now describe below.</p>"},{"location":"documentation/basics/open-systems.html#integrating-the-ode","title":"Integrating the ODE","text":"<p>The Lindblad master equation is an ODE, for which a wide variety of methods have been developed. The simplest approach is the Euler method, a first-order ODE method with a fixed step size which we describe shortly. Let us write the Taylor series expansion of the state at time \\(t+\\dt\\) up to first order: $$     \\begin{aligned}         \\rho(t+\\dt) &amp;= \\rho(t)+\\dt\\frac{\\dd\\rho(t)}{\\dt}+\\mathcal{O}(\\dt^2) \\\\         &amp;\\approx \\rho(t)+\\dt\\mathcal{L}(\\rho(t)) \\\\         &amp;\\approx \\rho(t)+\\dt\\left(-i[H(t), \\rho(t)] + \\sum_{k=1}^N \\left(L_k \\rho(t) L_k^\\dag - \\frac{1}{2} L_k^\\dag L_k \\rho(t) - \\frac{1}{2} \\rho(t) L_k^\\dag L_k\\right)\\right),     \\end{aligned} $$ where we used the Lindblad master equation to replace the time derivative of the state. By choosing a sufficiently small step size \\(\\dt\\) and starting from \\(\\rho(0)\\), the state is then iteratively evolved to a final time using the previous equation.</p> <p>There are two main types of ODE methods:</p> <ul> <li>Fixed step size: as with the Euler method, the step size \\(\\dt\\) is fixed during the simulation. The best known higher order methods are the Runge-Kutta methods. It is important for all these methods that the time step is sufficiently small to ensure the accuracy of the solution.</li> <li>Adaptive step size: the step size is automatically adjusted during the simulation, at each time step. A well-known method is the Dormand-Prince method.</li> </ul> <p>Space complexity: \\(O(n^2)\\) (storing the Hamiltonian and jump operators).</p> <p>Time complexity: \\(O(n^3\\times\\text{number of time steps})\\) (complexity of the matrix-matrix product at each time step).</p>"},{"location":"documentation/basics/open-systems.html#sampling-trajectories","title":"Sampling trajectories","text":"<p>Also called the quantum-jump approach.</p> <p>Work in progress.</p>"},{"location":"documentation/basics/open-systems.html#using-dynamiqs","title":"Using Dynamiqs","text":"<p>You can create the state, Hamiltonian and jump operators using any qarray-like. Let's take the example of a two-level system with a simple Hamiltonian and a single jump operator:</p> <pre><code>import jax.numpy as jnp\nimport dynamiqs as dq\n\njnp.set_printoptions(precision=3, suppress=True)  # set custom array print style\n\npsi0 = dq.excited()                         # initial state\nH = dq.sigmaz()                             # Hamiltonian\njump_ops = [dq.sigmam()]                    # list of jump operators\ntsave = jnp.linspace(0, 1.0, 11)            # saving times\nres = dq.mesolve(H, jump_ops, psi0, tsave)  # run the simulation\nprint(res.states[-1])                       # print the final state\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 1.75ms \u25c6 remaining 0.00ms\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[0.368+0.j 0.   +0.j]\n [0.   +0.j 0.632+0.j]]\n</code></pre> <p>If you want to know more about the available methods or the different options, head to the <code>dq.mesolve()</code> API documentation.</p> <p>You can also directly compute the propagator with the <code>dq.mepropagator()</code> solver. Continuing the last example:</p> <pre><code>res = dq.mepropagator(H, jump_ops, tsave)\nprint(res.propagators[-1])  # print the final propagator\n</code></pre> Output<pre><code>QArray: shape=(4, 4), dims=(2,), dtype=complex64, layout=dense, vectorized=True\n[[ 0.368+0.j     0.   +0.j     0.   +0.j     0.   +0.j   ]\n [ 0.   +0.j    -0.252+0.552j  0.   +0.j     0.   +0.j   ]\n [ 0.   +0.j     0.   +0.j    -0.252-0.552j  0.   +0.j   ]\n [ 0.632+0.j     0.   +0.j     0.   +0.j     1.   +0.j   ]]\n</code></pre>"},{"location":"documentation/basics/time-dependent-operators.html","title":"Time-dependent operators","text":""},{"location":"documentation/basics/time-dependent-operators.html#time-dependent-operators","title":"Time-dependent operators","text":"<p>This tutorial explains how to define time-dependent Hamiltonians \u2013 and more generally time-dependent operators \u2013 in Dynamiqs. There are currently four supported formats: constant operator, piecewise constant operator, constant operator modulated by a time-dependent factor, or arbitrary time-dependent operator defined by a function.</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nfrom matplotlib import pyplot as plt\n\ndq.plot.mplstyle(dpi=150)  # set custom matplotlib style\n</code></pre>"},{"location":"documentation/basics/time-dependent-operators.html#the-timeqarray-type","title":"The <code>TimeQArray</code> type","text":"<p>In Dynamiqs, time-dependent operators are defined with type <code>TimeQArray</code>. They can be called at arbitrary times, and return the corresponding qarray at that time. For example to define the Hamiltonian $$     H_x(t)=\\cos(2\\pi t)\\sigma_x $$ </p><pre><code>&gt;&gt;&gt; f = lambda t: jnp.cos(2.0 * jnp.pi * t)\n&gt;&gt;&gt; Hx = dq.modulated(f, dq.sigmax())  # initialize a modulated timeqarray\n&gt;&gt;&gt; Hx(1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n[[  \u22c5    1.+0.j]\n [1.+0.j   \u22c5   ]]\n&gt;&gt;&gt; Hx.shape\n(2, 2)\n</code></pre><p></p> <p>Timeqarrays support common arithmetic operations with scalars, qarray-likes and other timeqarrays. For example to define the Hamiltonian $$     H(t) = \\sigma_z + 2 H_x(t) - \\sin(\\pi t) \\sigma_y $$ </p><pre><code>&gt;&gt;&gt; g = lambda t: jnp.sin(jnp.pi * t)\n&gt;&gt;&gt; Hy = dq.modulated(g, dq.sigmay())\n&gt;&gt;&gt; H = dq.sigmaz() + 2 * Hx - Hy\n&gt;&gt;&gt; H(1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=3\n[[ 1.+0.j  2.-0.j]\n [ 2.+0.j -1.+0.j]]\n</code></pre><p></p> <p>Finally, timeqarrays also support common utility functions, such as <code>.conj()</code>, or <code>.reshape()</code>. More details can be found in the <code>TimeQArray</code> API page.</p>"},{"location":"documentation/basics/time-dependent-operators.html#defining-a-timeqarray","title":"Defining a timeqarray","text":""},{"location":"documentation/basics/time-dependent-operators.html#constant-operators","title":"Constant operators","text":"<p>A constant operator is defined by $$     O(t) = O_0 $$ for any time \\(t\\), where \\(O_0\\) is an arbitrary operator. The most practical way to define constant operators is using qarray-likes. They can also be instantiated as timeqarrays using the <code>dq.constant()</code> function. For instance, to define the Pauli operator \\(H = \\sigma_z\\), you can use any of the following syntaxes:</p> Dynamiqs utilitiesDynamiqs qarrayNumPy arrayJAX arrayQuTiP QobjPython list <pre><code>import dynamiqs as dq\nH = dq.sigmaz()\n</code></pre> <pre><code>import dynamiqs as dq\nH = dq.asqarray([[1, 0], [0, -1]])\n</code></pre> <pre><code>import numpy as np\nH = np.array([[1, 0], [0, -1]])\n</code></pre> <pre><code>import jax.numpy as jnp\nH = jnp.array([[1, 0], [0, -1]])\n</code></pre> <pre><code>import qutip as qt\nH = qt.sigmaz()\n</code></pre> <pre><code>H = [[1, 0], [0, -1]]\n</code></pre> <p>Note</p> <p>Common operators are available as utility functions, see the list of available operators in the Python API.</p>"},{"location":"documentation/basics/time-dependent-operators.html#piecewise-constant-operators","title":"Piecewise constant operators","text":"<p>A piecewise constant (PWC) operator takes constant values over some time intervals. It is defined by $$     O(t) = \\left(\\sum_{k=0}^{N-1} c_k\\; \\Omega_{[t_k, t_{k+1}[}(t)\\right) O_0 $$ where \\(c_k\\) are constant values, \\(\\Omega_{[t_k, t_{k+1}[}\\) is the rectangular window function defined by \\(\\Omega_{[t_a, t_b[}(t) = 1\\) if \\(t \\in [t_a, t_b[\\) and \\(\\Omega_{[t_a, t_b[}(t) = 0\\) otherwise, and \\(O_0\\) is a constant operator.</p> <p>In Dynamiqs, PWC operators are defined by:</p> <ul> <li><code>times</code>: the time points \\((t_0, \\ldots, t_N)\\) defining the boundaries of the time intervals, of shape (N+1,),</li> <li><code>values</code>: the constant values \\((c_0, \\ldots, c_{N-1})\\) for each time interval, of shape (..., N),</li> <li><code>qarray</code>: the qarray defining the constant operator \\(O_0\\), of shape (n, n).</li> </ul> <p>To construct a PWC operator, these three arguments must be passed to the <code>dq.pwc()</code> function, which returns a timeqarray. When called at some time \\(t\\), this object then returns a qarray with shape (..., n, n). For example, let us define a PWC operator \\(H(t)\\) with constant value \\(3\\sigma_z\\) for \\(t\\in[0, 1[\\) and \\(-2\\sigma_z\\) for \\(t\\in[1, 2[\\): </p><pre><code>&gt;&gt;&gt; times = [0.0, 1.0, 2.0]\n&gt;&gt;&gt; values = [3.0, -2.0]\n&gt;&gt;&gt; qarray = dq.sigmaz()\n&gt;&gt;&gt; H = dq.pwc(times, values, qarray)\n&gt;&gt;&gt; H\nPWCTimeQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n</code></pre><p></p> <p>The returned object can be called at different times:</p> \\(t = -1.0\\)\\(t=0.0\\)\\(t=0.5\\)\\(t=1.0\\)\\(t=1.5\\)\\(t=2.0\\) <pre><code>&gt;&gt;&gt; H(-1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5      \u22c5   ]\n [  \u22c5      \u22c5   ]]\n</code></pre> <pre><code>&gt;&gt;&gt; H(0.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[ 3.+0.j    \u22c5   ]\n [   \u22c5    -3.+0.j]]\n</code></pre> <pre><code>&gt;&gt;&gt; H(0.5)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[ 3.+0.j    \u22c5   ]\n [   \u22c5    -3.+0.j]]\n</code></pre> <pre><code>&gt;&gt;&gt; H(1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[-2.+0.j    \u22c5   ]\n [   \u22c5     2.+0.j]]\n</code></pre> <pre><code>&gt;&gt;&gt; H(1.5)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[-2.+0.j    \u22c5   ]\n [   \u22c5     2.+0.j]]\n</code></pre> <pre><code>&gt;&gt;&gt; H(2.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5      \u22c5   ]\n [  \u22c5      \u22c5   ]]\n</code></pre> <p>We can use <code>dq.plot.pwc_pulse()</code> to plot the PWC pulse values at different times: </p><pre><code>dq.plot.pwc_pulse(H.times, H.values)\nplt.gca().set(xlabel='Time $t$')\nrenderfig('tqarray_plot_pwc_pulse')\n</code></pre><p></p> <p></p> <p>Note</p> <p>The argument <code>times</code> must be sorted in ascending order, but does not need to be evenly spaced. When calling the resulting timeqarray at time \\(t\\), the returned qarray is the operator \\(c_k\\ O_0\\) corresponding to the interval \\([t_k, t_{k+1}[\\) in which the time \\(t\\) falls. If \\(t\\) does not belong to any time intervals, the returned qarray is null.</p> Batching PWC operators <p>The batching of the returned timeqarray is specified by <code>values</code>. For example, to define a PWC operator batched over a parameter \\(\\theta\\): </p><pre><code>&gt;&gt;&gt; thetas = jnp.linspace(0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; times = [0.0, 1.0, 2.0]\n&gt;&gt;&gt; values = thetas[:, None] * jnp.array([3.0, -2.0])  # (11, 2)\n&gt;&gt;&gt; qarray = dq.sigmaz()\n&gt;&gt;&gt; H = dq.pwc(times, values, qarray)\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre><p></p>"},{"location":"documentation/basics/time-dependent-operators.html#modulated-operators","title":"Modulated operators","text":"<p>A modulated operator is defined by $$     O(t) = f(t) O_0 $$ where \\(f(t)\\) is a time-dependent scalar. In Dynamiqs, modulated operators are defined by:</p> <ul> <li><code>f</code>: a Python function with signature <code>f(t: float) -&gt; Scalar | Array</code> that returns the modulating factor \\(f(t)\\) for any time \\(t\\), as a scalar or an array of shape (...),</li> <li><code>qarray</code>: the qarray defining the constant operator \\(O_0\\), of shape (n, n).</li> </ul> <p>To construct a modulated operator, these two arguments must be passed to the <code>dq.modulated()</code> function, which returns a timeqarray. When called at some time \\(t\\), this object then returns a qarray with shape (..., n, n). For example, let us define the modulated operator \\(H(t)=\\cos(2\\pi t)\\sigma_x\\): </p><pre><code>&gt;&gt;&gt; f = lambda t: jnp.cos(2.0 * jnp.pi * t)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n&gt;&gt;&gt; H\nModulatedTimeQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n</code></pre><p></p> <p>The returned object can be called at different times:</p> \\(t = 0.5\\)\\(t=1.0\\) <pre><code>&gt;&gt;&gt; H(0.5)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n[[   \u22c5    -1.+0.j]\n [-1.+0.j    \u22c5   ]]\n</code></pre> <pre><code>&gt;&gt;&gt; H(1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n[[  \u22c5    1.+0.j]\n [1.+0.j   \u22c5   ]]\n</code></pre> <p>We can use the <code>prefactor()</code> method to plot \\(f(t)\\) at different times: </p><pre><code>ts = jnp.linspace(-1.0, 1.0, 501)\nplt.plot(ts, H.prefactor(ts))\nplt.gca().set(xlabel='Time $t$', ylabel='$f(t)$')\nrenderfig('tqarray_plot_modulated')\n</code></pre><p></p> <p></p> Batching modulated operators <p>The batching of the returned timeqarray is specified by the array returned by <code>f</code>. For example, to define a modulated Hamiltonian \\(H(t)=\\cos(\\omega t)\\sigma_x\\) batched over the parameter \\(\\omega\\): </p><pre><code>&gt;&gt;&gt; omegas = jnp.linspace(0.0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; f = lambda t: jnp.cos(omegas * t)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre><p></p> Function with additional arguments <p>To define a modulated operator with a function that takes arguments other than time (extra <code>*args</code> and <code>**kwargs</code>), you can use <code>functools.partial()</code>. For example: </p><pre><code>&gt;&gt;&gt; import functools\n&gt;&gt;&gt; def pulse(t, omega, amplitude=1.0):\n...     return amplitude * jnp.cos(omega * t)\n&gt;&gt;&gt; # create function with correct signature (t: float) -&gt; Array\n&gt;&gt;&gt; f = functools.partial(pulse, omega=1.0, amplitude=5.0)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n</code></pre><p></p> Discontinuous function <p>If there is a discontinuous jump in the function values, you should use the optional argument <code>discontinuity_ts</code> to enforce adaptive step size methods to stop at these times (i.e., right before, and right after the jump).</p>"},{"location":"documentation/basics/time-dependent-operators.html#arbitrary-time-dependent-operators","title":"Arbitrary time-dependent operators","text":"<p>An arbitrary time-dependent operator is defined by $$     O(t) = f(t) $$ where \\(f(t)\\) is a time-dependent operator. In Dynamiqs, arbitrary time-dependent operators are defined by:</p> <ul> <li><code>f</code>: a Python function with signature <code>f(t: float) -&gt; QArray</code> that returns the operator \\(f(t)\\) for any time \\(t\\), as a qarray of shape (..., n, n).</li> </ul> <p>To construct an arbitrary time-dependent operator, pass this argument to the <code>dq.timecallable()</code> function, which returns a timeqarray. This object then returns a qarray with shape (..., n, n) when called at any time \\(t\\).</p> <p>For example, let us define the arbitrary time-dependent operator \\(H(t)=\\begin{pmatrix}t &amp; 0\\\\0 &amp; 1 - t\\end{pmatrix}\\): </p><pre><code>&gt;&gt;&gt; f = lambda t: dq.asqarray([[t, 0], [0, 1 - t]])\n&gt;&gt;&gt; H = dq.timecallable(f)\n&gt;&gt;&gt; H\nCallableTimeQArray: shape=(2, 2), dims=(2,), dtype=float32, layout=dense\n</code></pre><p></p> <p>The returned object can be called at different times:</p> \\(t = 0.5\\)\\(t=1.0\\) <pre><code>&gt;&gt;&gt; H(0.5)\nQArray: shape=(2, 2), dims=(2,), dtype=float32, layout=dense\n[[0.5 0. ]\n [0.  0.5]]\n</code></pre> <pre><code>&gt;&gt;&gt; H(1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=float32, layout=dense\n[[1. 0.]\n [0. 0.]]\n</code></pre> <p>The function <code>f</code> must return a qarray (not a qarray-like!)</p> <p>An error is raised if the function <code>f</code> does not return a qarray. This error concerns any other qarray-likes. This is enforced to avoid costly conversions at every time step of the numerical integration.</p> Batching arbitrary time-dependent operators <p>The batching of the returned timeqarray is specified by the qarray returned by <code>f</code>. For example, to define an arbitrary time-dependent operator batched over a parameter \\(\\theta\\): </p><pre><code>&gt;&gt;&gt; thetas = jnp.linspace(0, 1.0, 11)  # (11,)\n&gt;&gt;&gt; f = lambda t: thetas[:, None, None] * dq.asqarray([[t, 0], [0, 1 - t]])\n&gt;&gt;&gt; H = dq.timecallable(f)\n&gt;&gt;&gt; H.shape\n(11, 2, 2)\n</code></pre><p></p> Function with additional arguments <p>To define an arbitrary time-dependent operator with a function that takes arguments other than time (extra <code>*args</code> and <code>**kwargs</code>), you can use <code>functools.partial()</code>. For example: </p><pre><code>&gt;&gt;&gt; import functools\n&gt;&gt;&gt; def func(t, a, amplitude=1.0):\n...     return amplitude * dq.asqarray([[t, a], [a, 1 - t]])\n&gt;&gt;&gt; # create function with correct signature (t: float) -&gt; Array\n&gt;&gt;&gt; f = functools.partial(func, a=1.0, amplitude=5.0)\n&gt;&gt;&gt; H = dq.timecallable(f)\n</code></pre><p></p> Discontinuous function <p>If there is a discontinuous jump in the function values, you should use the optional argument <code>discontinuity_ts</code> to enforce adaptive step size methods to stop at these times (i.e., right before, and right after the jump).</p>"},{"location":"documentation/basics/time-dependent-operators.html#clipping-a-timeqarray","title":"Clipping a timeqarray","text":"<p>Time-dependent operators can be clipped to a given time interval, outside which the returned qarray is null. For example: </p><pre><code>&gt;&gt;&gt; f = lambda t: jnp.cos(2.0 * jnp.pi * t)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n&gt;&gt;&gt; H(2.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n[[  \u22c5    1.+0.j]\n [1.+0.j   \u22c5   ]]\n&gt;&gt;&gt; H_clipped = H.clip(0, 1)  # clip to 0 &lt;= t &lt; 1\n&gt;&gt;&gt; H_clipped(2.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n[[  \u22c5      \u22c5   ]\n [  \u22c5      \u22c5   ]]\n</code></pre><p></p> <p>We can plot the resulting prefactor values after clipping: </p><pre><code>_, axs = dq.plot.grid(2, w=4, h=3, sharexy=True)\nax0, ax1 = list(axs)\n\nts = jnp.linspace(-2.0, 2.0, 501)\n\nax0.plot(ts, H.prefactor(ts))\nax0.set(xlabel='Time $t$', ylabel='$f(t)$', title='H')\n\nax1.plot(ts, H_clipped.prefactor(ts))\nax1.set(xlabel='Time $t$', title='H.clip(0, 1)')\nrenderfig('tqarray_plot_clip')\n</code></pre><p></p> <p></p>"},{"location":"documentation/basics/workflow.html","title":"Workflow in Dynamiqs","text":""},{"location":"documentation/basics/workflow.html#workflow-in-dynamiqs","title":"Workflow in Dynamiqs","text":"<p>The core of Dynamiqs is to solve quantum differential equations. This tutorial goes over the basic workflow of such simulations, in mainly four steps:</p> <ul> <li>Define the system: Initialize the state and operators you are interested in.</li> <li>Set the scope: Specify the duration, observables to measure, or method to use.</li> <li>Run the simulation: Solve the differential equation and collect the results.</li> <li>Analyze the results: Plot results and extract the information you are interested in.</li> </ul> <p>In the rest of this tutorial, we go over these steps in detail, taking the example of Rabi oscillations of a two-level system.</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\ndq.plot.mplstyle(dpi=150)  # set custom matplotlib style\n</code></pre>"},{"location":"documentation/basics/workflow.html#i-define-the-system","title":"I. Define the system","text":"<p>After having imported the necessary packages, we can define our system, namely the initial state, the Hamiltonian, and the eventual loss operators. Common states and operators are already defined in Dynamiqs, see the Python API for more details. Otherwise, you can define specific states and operators using any array-like.</p> <p>Here, we will use <code>dq.fock()</code> to define the initial state \\(\\ket{\\psi_0}=\\ket{0}\\), <code>dq.sigmaz()</code> and <code>dq.sigmax()</code> to define the Hamiltonian \\(H = \\delta \\sigma_z + \\Omega \\sigma_x\\).</p> <pre><code># initial state\npsi0 = dq.fock(2, 0)\n\n# Hamiltonian\ndelta = 0.3  # detuning\nOmega = 1.0  # Rabi frequency\nH = delta * dq.sigmaz() + Omega * dq.sigmax()\n\nprint(f\"State of type {type(psi0)} and shape {psi0.shape}.\")\nprint(f\"Hamiltonian of type {type(H)} and shape {H.shape}.\")\n</code></pre> Output<pre><code>State of type &lt;class 'dynamiqs.qarrays.dense_qarray.DenseQArray'&gt; and shape (2, 1).\nHamiltonian of type &lt;class 'dynamiqs.qarrays.sparsedia_qarray.SparseDIAQArray'&gt; and shape (2, 2).\n</code></pre> <p>In Dynamiqs, all quantum objects are defined with the <code>QArray</code> type. All quantum objects have at least two dimensions to avoid systematic reshaping or coding mistakes (e.g. trying to multiply a ket and an operator in the wrong order). In particular, kets have shape <code>(..., n, 1)</code> and density matrices have shape <code>(..., n, n)</code>.</p>"},{"location":"documentation/basics/workflow.html#ii-set-the-scope","title":"II. Set the scope","text":"<p>Next, we define the scope of the simulation. This includes the total duration of time evolution, the observables we want to measure and how often we measure them. Observables are defined similarly to the Hamiltonian, using qarrays and Dynamiqs utility functions. The total duration and how often measurements are performed is defined in a single object named <code>tsave</code>. It is an arbitrary array of time points, of which <code>tsave[-1]</code> specifies the total duration of time evolution.</p> <p>We also need to specify the method and options related to it, namely the method of integration and the eventual related parameters. The list of available methods and their parameters is available in the Python API.</p> <pre><code># define sampling times\nsim_time = 10.0  # total time of evolution\nnum_save = 101  # number of time slots to save\ntsave = jnp.linspace(0.0, sim_time, num_save)  # can also be a list or a NumPy array\n\n# define list of observables\nexp_ops = [dq.sigmaz()]  # expectation value of sigma_z\n\n# define method (Dormand-Prince method of order 5)\nmethod = dq.method.Dopri5(rtol=1e-6, atol=1e-8)\n</code></pre>"},{"location":"documentation/basics/workflow.html#iii-run-the-simulation","title":"III. Run the simulation","text":"<p>We can now run the simulation. This is done by calling the <code>dq.sesolve()</code> function, which returns an instance of <code>SESolveResult</code>. This object contains the computed states, the observables, and various information about the method.</p> <pre><code># run simulation\nresult = dq.sesolve(H, psi0, tsave, exp_ops=exp_ops, method=method)\n\n# print some information\nprint(f\"`result` is of type {type(result)}.\")\nprint(f\"`result` has the following attributes:\")\nprint(f\"{[attr for attr in dir(result) if not attr.startswith('__')]}\\n\")\nprint(result)\n</code></pre> Output<pre><code>`result` is of type &lt;class 'dynamiqs.result.SESolveResult'&gt;.\n`result` has the following attributes:\n['_abc_impl', '_saved', '_str_parts', 'block_until_ready', 'expects', 'extra', 'final_state', 'gradient', 'infos', 'method', 'options', 'states', 'to_numpy', 'to_qutip', 'tsave']\n\n|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 4.57ms \u25c6 remaining 0.00ms\n==== SESolveResult ====\nMethod  : Dopri5\nInfos   : 56 steps (48 accepted, 8 rejected)\nStates  : QArray complex64 (101, 2, 1) | 1.6 Kb\nExpects : Array complex64 (1, 101) | 0.8 Kb\n</code></pre>"},{"location":"documentation/basics/workflow.html#iv-analyze-the-results","title":"IV. Analyze the results","text":"<p>Finally, you can analyze the results in whichever way is most relevant to your application. In our example, let us plot the \\(\\braket{\\sigma_z}\\) observable as a function of time. To do so, we call <code>result.expects[0].real</code> which extracts the first measured observable (here, the only one) and plot its real part (our observable is hermitian, so measurements are real-valued). We compare to the expected analytical result.</p> <pre><code># analytical result\nOmega_star = jnp.sqrt(delta**2 + Omega**2)  # generalized Rabi frequency\nexcited_pop = Omega / Omega_star * jnp.sin(tsave * Omega_star)  # excited population\nsigmaz_analytical = 1 - 2 * excited_pop**2  # expectation value of sigma_z\n\n# plot results\nplt.plot(tsave, sigmaz_analytical, 'k', lw=1.0)\nplt.plot(tsave, result.expects[0].real, 'oC0', ms=4)\n\n# formatting\nplt.xlabel('Time')\nplt.ylabel(r'$\\langle \\sigma_z \\rangle$')\nplt.xlim(0, 10)\nplt.ylim(-1, 1)\nplt.legend(('Analytical', 'Dynamiqs'))\nrenderfig('workflow')\n</code></pre> <p></p> <p>As expected, we find off-resonant Rabi oscillations at the generalized Rabi frequency \\(\\Omega^* = \\sqrt{\\delta^2 + \\Omega^2}\\), and with a reduced amplitude \\(|\\Omega / \\Omega^*|^2\\).</p>"},{"location":"documentation/getting_started/examples.html","title":"Basic examples","text":""},{"location":"documentation/getting_started/examples.html#basic-examples","title":"Basic examples","text":"<p>First time using Dynamiqs? Below are a few basic examples to help you get started.</p>"},{"location":"documentation/getting_started/examples.html#simulate-a-lossy-quantum-harmonic-oscillator","title":"Simulate a lossy quantum harmonic oscillator","text":"<p>This first example shows simulation of a lossy harmonic oscillator with Hamiltonian \\(H=\\omega a^\\dagger a\\) and a single jump operator \\(L=\\sqrt{\\kappa} a\\) from time \\(0\\) to time \\(T\\), starting from the initial coherent state \\(\\ket{\\alpha_0}\\).</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\n\n# parameters\nn = 16          # Hilbert space dimension\nomega = 1.0     # frequency\nkappa = 0.1     # decay rate\nalpha0 = 1.0    # initial coherent state amplitude\nT = 2 * jnp.pi  # total evolution time (one full revolution)\n\n# initialize operators, initial state and saving times\na = dq.destroy(n)\nH = omega * a.dag() @ a\njump_ops = [jnp.sqrt(kappa) * a]\npsi0 = dq.coherent(n, alpha0)\ntsave = jnp.linspace(0, T, 101)\n\n# run simulation\nresult = dq.mesolve(H, jump_ops, psi0, tsave)\nprint(result)\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 6.30ms \u25c6 remaining 0.00ms\n==== MESolveResult ====\nMethod : Tsit5\nInfos  : 40 steps (40 accepted, 0 rejected)\nStates : QArray complex64 (101, 16, 16) | 202.0 Kb\n</code></pre>"},{"location":"documentation/getting_started/examples.html#compute-gradients-with-respect-to-some-parameters","title":"Compute gradients with respect to some parameters","text":"<p>Suppose that in the above example, we want to compute the gradient of the number of photons in the final state at time \\(T\\), \\(\\bar{n} = \\mathrm{Tr}[a^\\dagger a \\rho(T)]\\), with respect to the frequency \\(\\omega\\), the decay rate \\(\\kappa\\) and the initial coherent state amplitude \\(\\alpha_0\\).</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport jax\n\n# parameters\nn = 16          # Hilbert space dimension\nomega = 1.0     # frequency\nkappa = 0.1     # decay rate\nalpha0 = 1.0    # initial coherent state amplitude\nT = 2 * jnp.pi  # total evolution time (one full revolution)\n\ndef population(omega, kappa, alpha0):\n    \"\"\"Return the oscillator population after time evolution.\"\"\"\n    # initialize operators, initial state and saving times\n    a = dq.destroy(n)\n    H = omega * a.dag() @ a\n    jump_ops = [jnp.sqrt(kappa) * a]\n    psi0 = dq.coherent(n, alpha0)\n    tsave = jnp.linspace(0, T, 101)\n\n    # run simulation\n    result = dq.mesolve(H, jump_ops, psi0, tsave)\n\n    return dq.expect(dq.number(n), result.states[-1]).real\n\n# compute gradient with respect to omega, kappa and alpha\ngrad_population = jax.grad(population, argnums=(0, 1, 2))\ngrads = grad_population(omega, kappa, alpha0)\nprint(f'Gradient w.r.t. omega : {grads[0]:.4f}')\nprint(f'Gradient w.r.t. kappa : {grads[1]:.4f}')\nprint(f'Gradient w.r.t. alpha0: {grads[2]:.4f}')\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 5.94ms \u25c6 remaining 0.00ms\nGradient w.r.t. omega : 0.0000\nGradient w.r.t. kappa : -3.3520\nGradient w.r.t. alpha0: 1.0670\n</code></pre> <p>Note</p> <p>On this specific example, we can verify the result analytically. The state remains a coherent state at all time with complex amplitude \\(\\alpha(t) = \\alpha_0 e^{-\\kappa t/2} e^{-i\\omega t}\\), and the final photon number is thus \\(\\bar{n} = |\\alpha(T)|^2 = \\alpha_0^2 e^{-\\kappa T}\\). We can then compute the gradient with respect to the three parameters \\(\\theta = (\\omega, \\kappa, \\alpha_0)\\):</p> \\[ \\nabla_\\theta\\ \\bar{n} = \\begin{pmatrix}   \\partial\\bar{n} / \\partial\\omega \\\\   \\partial\\bar{n} / \\partial\\kappa \\\\   \\partial\\bar{n} / \\partial\\alpha_0 \\end{pmatrix} = \\begin{pmatrix}   0\\\\   -\\alpha_0^2 T e^{-\\kappa T} \\\\   2 \\alpha_0 e^{-\\kappa T} \\end{pmatrix} \\approx \\begin{pmatrix}   0.0 \\\\   -3.3520 \\\\   1.0670 \\end{pmatrix} \\]"},{"location":"documentation/getting_started/installation.html","title":"Installation","text":""},{"location":"documentation/getting_started/installation.html#installation","title":"Installation","text":"<p>You can install Dynamiqs with <code>pip</code>:</p> <pre><code>pip install dynamiqs\n</code></pre> <p>Note</p> <p>If you're using a GPU, please refer to the JAX installation documentation page for detailed instructions on how to install JAX for your device.</p>"},{"location":"documentation/getting_started/sharp-bits.html","title":"The sharp bits \ud83d\udd2a","text":""},{"location":"documentation/getting_started/sharp-bits.html#the-sharp-bits","title":"The sharp bits \ud83d\udd2a","text":"<p>This page highlight common pitfalls that users may encounter when learning to use Dynamiqs.</p> <pre><code>import dynamiqs as dq\n</code></pre>"},{"location":"documentation/getting_started/sharp-bits.html#main-differences-with-qutip","title":"Main differences with QuTiP","text":"<p>The syntax in Dynamiqs is similar to QuTiP, a popular Python library for quantum simulation. However, there are some important differences that you should be aware of.</p>"},{"location":"documentation/getting_started/sharp-bits.html#floating-point-precision","title":"Floating-point precision","text":"<p>In Dynamiqs, all objects are represented by default with single-precision floating-point numbers (<code>float32</code> or <code>complex64</code>), whereas the default in QuTiP or NumPy is double-precision (<code>float64</code> or <code>complex128</code>). We made this choice to match JAX's default, and for performance reasons, as many problems do not require double-precision. If needed, it is possible to switch to double-precision using <code>dq.set_precision()</code>:</p> <pre><code>dq.set_precision('double')  # 'single' by default\n</code></pre> <p>When using single-precision, there are certain limitations to be aware of:</p> <ul> <li>Large numbers: Numerical errors in floating-point arithmetic become more significant when using large numbers. Therefore, you should try to choose units for your simulation such that all quantities involved are not too large.</li> <li>Tolerances: If you require very precise simulation results (e.g. if you set lower <code>rtol</code> and <code>atol</code> than the default values), the simulation time may increase significantly, and simulations may even get stuck. In such cases, it is recommended to switch to double-precision.</li> </ul> <p>Warning</p> <p>Most GPUs do not have native support for double-precision, and only perform well in single-precision. However, note that some recent NVIDIA GPUs (e.g. V100, A100, H100) do provide efficient support for double-precision.</p>"},{"location":"documentation/getting_started/sharp-bits.html#adding-a-scalar-to-an-operator","title":"Adding a scalar to an operator","text":"<p>In QuTiP, adding a scalar to a <code>Qobj</code> performs an implicit multiplication of the scalar with the identity matrix. This convention differs from the one adopted by common scientific libraries such as NumPy, PyTorch or JAX. In Dynamiqs, adding a scalar to an operator with <code>+</code> is forbidden. To achieve the same result as in QuTiP, you must explicitly multiply the scalar with the identity matrix:</p>  Correct Incorrect <pre><code>&gt;&gt;&gt; sz = dq.sigmaz()\n&gt;&gt;&gt; sz - 2 * dq.eye(2)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[-1.+0.j    \u22c5   ]\n [   \u22c5    -3.+0.j]]\n</code></pre> <pre><code>&gt;&gt;&gt; sz = dq.sigmaz()\n&gt;&gt;&gt; sz - 2\nTraceback (most recent call last):\n    ...\nNotImplementedError: Adding a scalar to a qarray with the `+` operator is not supported. To add a scaled identity matrix, use `x + scalar * dq.eye_like(x)`. To add a scalar, use `x.addscalar(scalar)`.\n</code></pre> <p>If you actually want to add a scalar element-wise to an operator, you can use <code>x.addscalar(scalar)</code>.</p>"},{"location":"documentation/getting_started/sharp-bits.html#multiplying-two-operators","title":"Multiplying two operators","text":"<p>In QuTiP, the <code>*</code> symbol is used to multiply two operators. This convention also differs from common scientific libraries. In Dynamiqs, the <code>@</code> symbol is used for matrix multiplication, and the <code>*</code> symbol is reserved for element-wise multiplication with a scalar:</p>  Correct Incorrect <pre><code>&gt;&gt;&gt; sx = dq.sigmax()\n&gt;&gt;&gt; sx @ sx\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[1.+0.j   \u22c5   ]\n [  \u22c5    1.+0.j]]\n</code></pre> <pre><code>&gt;&gt;&gt; sx = dq.sigmax()\n&gt;&gt;&gt; sx * sx\nTraceback (most recent call last):\n    ...\nNotImplementedError: Element-wise multiplication of two qarrays with the `*` operator is not supported. For matrix multiplication, use `x @ y`. For element-wise multiplication, use `x.elmul(y)`.\n</code></pre> <p>If you actually want to multiply two operators element-wise,you can use <code>x.elmul(y)</code>.</p> <p>Likewise, you should use <code>x.powm()</code> instead of <code>**</code> (element-wise power) to compute the power of a matrix:</p>  Correct Incorrect <pre><code>&gt;&gt;&gt; sx.powm(2)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[1.+0.j   \u22c5   ]\n [  \u22c5    1.+0.j]]\n</code></pre> <pre><code>&gt;&gt;&gt; sx**2\nTraceback (most recent call last):\n    ...\nNotImplementedError: Computing the element-wise power of a qarray with the `**` operator is not supported. For the matrix power, use `x.pomw(power)`. For the element-wise power, use `x.elpow(power)`.\n</code></pre> <p>If you actually want to compute the element-wise power, you can use <code>x.elpow(power)</code>.</p>"},{"location":"documentation/getting_started/sharp-bits.html#using-a-for-loop","title":"Using a for loop","text":"<p>If you want to simulate multiple Hamiltonians or initial states, you should use batching instead of a <code>for</code> loop. This functionality is explained in detail in the Batching simulations tutorial, together with the associated gain in performance.</p>"},{"location":"documentation/getting_started/sharp-bits.html#computing-the-gradient-with-respect-to-complex-parameters","title":"Computing the gradient with respect to complex parameters","text":"<p>To optimize a real-valued function of complex parameters \\(f:\\mathbb{C}^p\\to\\mathbb{R}\\), you should take a step in the direction of the conjugate of the gradient given by JAX. For example, if you use the SciPy optimizers with <code>scipy.minimize()</code>, you need to conjuguate the gradient before providing it to the optimiser:</p>  Correct Incorrect <pre><code>grad = lambda x: jax.grad(f)(x).conj()\nscipy.minimize(f, ..., jac=grad)\n</code></pre> <pre><code>grad = lambda x: jax.grad(f)(x)\nscipy.minimize(f, ..., jac=grad)\n</code></pre> <p>See the JAX documentation and the PyTorch documentation for detailed discussions on complex numbers and differentiation.</p>"},{"location":"documentation/getting_started/whatis.html","title":"What is Dynamiqs?","text":""},{"location":"documentation/getting_started/whatis.html#what-is-dynamiqs","title":"What is Dynamiqs ?","text":""},{"location":"documentation/getting_started/whatis.html#in-a-nutshell","title":"In a nutshell","text":"<p>Dynamiqs is a Python library for GPU-accelerated and differentiable quantum simulations. Solvers are available for the Schr\u00f6dinger equation, the Lindblad master equation, the stochastic master equation, and others. The library is built with JAX and the main solvers are based on Diffrax.</p> <p>See the Python API for a list of available functions and classes.</p> <p>The main features of Dynamiqs are:</p> <ul> <li>Running simulations on CPUs and GPUs with high-performance.</li> <li>Executing many simulations concurrently by batching over Hamiltonians, initial states or jump operators.</li> <li>Computing gradients of arbitrary functions with respect to arbitrary parameters of the system.</li> <li>Full compatibility with the JAX ecosystem with a QuTiP-like API.</li> </ul> <p>We hope that this library will prove useful to the community for e.g. simulation of large quantum systems, gradient-based parameter estimation or quantum optimal control. The library is designed for large-scale problems, but also runs efficiently on CPUs for smaller problems.</p> <p>Warning</p> <p>This library is under active development and some APIs and solvers are still finding their footing. While most of the library is stable, new releases might introduce breaking changes.</p>"},{"location":"documentation/getting_started/whatis.html#the-dynamiqs-project","title":"The Dynamiqs project","text":""},{"location":"documentation/getting_started/whatis.html#philosophy","title":"Philosophy","text":"<p>There is a noticeable gap in the availability of an open-source library that simplifies gradient-based parameter estimation and quantum optimal control. In addition, faster simulations of large systems are essential to accelerate the development of quantum technologies. The Dynamiqs library addresses both of these needs. It aims to be a fast and reliable building block for GPU-accelerated and differentiable solvers. We also work to make the library compatible with the existing Python ecosystem (i.e. JAX and QuTiP) to allow easy interfacing with other libraries.</p>"},{"location":"documentation/getting_started/whatis.html#team-and-sponsoring","title":"Team and sponsoring","text":"<p>The library is being developed by a team of physicists and developers. We are working with theorists, experimentalists, machine learning practitioners, optimisation and numerical methods experts to make the library as useful and as powerful as possible. The library is sponsored by the startup Alice &amp; Bob, where it is being used to simulate, calibrate and control chips made of superconducting-based dissipative cat qubits.</p>"},{"location":"documentation/getting_started/whatis.html#history","title":"History","text":"<p>Development started in early 2023, the library was originally based on PyTorch with homemade solvers and gradient methods. It was completely rewritten in JAX in early 2024 for performance.</p>"},{"location":"documentation/getting_started/whatis.html#more-features","title":"More features!","text":"<p>Below are some cool features of Dynamiqs that are either already available or planned for the near future.</p>"},{"location":"documentation/getting_started/whatis.html#solvers","title":"Solvers","text":"<ul> <li>Choose between a variety of methods for each solver, from modern explicit and implicit ODE methods (e.g. Tsit5 and PID controllers for adaptive step-sizing) to quantum-tailored methods that preserve the physicality of the evolution (the state trace and positivity are preserved).</li> <li>Simulate time-varying problems (both Hamiltonian and jump operators) with support for various formats (piecewise constant operator, constant operator modulated by a time-dependent factor, etc.).</li> <li>Define a custom save function during the evolution (e.g. to register only the state purity, to track a subsystem by taking the partial trace of the full system, or to compute the population in the last Fock states to regularise your QOC problem).</li> <li>Easily implement your own solvers by subclassing our base solver class and focusing directly on the solver logic.</li> <li>Simulate SME trajectories orders of magnitude faster by batching the simulation over the stochastic trajectories.</li> <li>Parallelise large simulations across multiple CPUs/GPUs.</li> </ul>"},{"location":"documentation/getting_started/whatis.html#gradients","title":"Gradients","text":"<ul> <li>Choose between various methods to compute the gradient, to tradeoff speed and memory (e.g. use the optimal online checkpointing scheme of Diffrax to compute gradients for large systems).</li> <li>Compute gradients with machine-precision accuracy.</li> <li>Evaluate derivatives with respect to evolution time (e.g. for time-optimal quantum control).</li> <li>Compute higher order derivatives (e.g. the Hessian).</li> </ul>"},{"location":"documentation/getting_started/whatis.html#utilities","title":"Utilities","text":"<ul> <li>Balance accuracy and speed by choosing between single precision (<code>float32</code> and <code>complex64</code>) or double precision (<code>float64</code> and <code>complex128</code>).</li> <li>Discover a custom sparse data format designed for matrices with only a few dense diagonals, offering substantial speedups for large systems.</li> <li>Plot beautiful figures by using our handcrafted plotting function.</li> <li>Apply any functions to batched arrays (e.g. <code>dq.wigner(states)</code> to compute the wigners of many states at once).</li> <li>Use QuTiP objects as arguments to any functions (e.g. if you have existing code to define your Hamiltonian in QuTiP, or if you want to use our nice plotting functions on a list of QuTiP states).</li> </ul>"},{"location":"documentation/getting_started/whatis.html#library-development","title":"Library development","text":"<ul> <li>Enjoy modern software development practices and tools.</li> <li>Build confidence from the analytical tests that verify state correctness and gradient accuracy for every solver, at each commit.</li> </ul>"},{"location":"documentation/getting_started/whatis.html#coming-soon","title":"Coming soon","text":"<ul> <li>Simulate using propagators solvers based on Krylov subspace methods.</li> <li>Benchmark code to compare solvers and performance for different systems.</li> </ul>"},{"location":"python_api/index.html","title":"Python API","text":""},{"location":"python_api/index.html#python-api","title":"Python API","text":"<p>The Dynamiqs Python API features two main types of functions: solvers of differential equations describing quantum systems, and various utility functions to ease the creation and manipulation of quantum states and operators.</p>"},{"location":"python_api/index.html#solvers","title":"Solvers","text":""},{"location":"python_api/index.html#general","title":"General","text":"<code>sesolve</code> <p>Solve the Schr\u00f6dinger equation.</p> <code>mesolve</code> <p>Solve the Lindblad master equation.</p> <code>sepropagator</code> <p>Compute the propagator of the Schr\u00f6dinger equation.</p> <code>mepropagator</code> <p>Compute the propagator of the Lindblad master equation.</p> <code>floquet</code> <p>Compute Floquet modes and quasienergies of a periodic closed system.</p>"},{"location":"python_api/index.html#stochastic","title":"Stochastic","text":"<code>jssesolve</code> <p>Solve the jump stochastic Schr\u00f6dinger equation (SSE).</p> <code>dssesolve</code> <p>Solve the diffusive stochastic Schr\u00f6dinger equation (SSE).</p> <code>jsmesolve</code> <p>Solve the jump stochastic master equation (SME).</p> <code>dsmesolve</code> <p>Solve the diffusive stochastic master equation (SME).</p>"},{"location":"python_api/index.html#core","title":"Core","text":""},{"location":"python_api/index.html#quantum-arrays","title":"Quantum arrays","text":"<code>QArray</code> <p>Dynamiqs custom array to represent quantum objects.</p>"},{"location":"python_api/index.html#time-dependent-qarrays","title":"Time-dependent qarrays","text":"<code>TimeQArray</code> <p>Base class for time-dependent qarrays.</p> <code>constant</code> <p>Instantiate a constant timeqarray.</p> <code>pwc</code> <p>Instantiate a piecewise constant (PWC) timeqarray.</p> <code>modulated</code> <p>Instantiate a modulated timeqarray.</p> <code>timecallable</code> <p>Instantiate a callable timeqarray.</p>"},{"location":"python_api/index.html#methods-dqmethod","title":"Methods (dq.method)","text":"<code>Tsit5</code> <p>Tsitouras method of order 5 (adaptive step size ODE method).</p> <code>Dopri5</code> <p>Dormand-Prince method of order 5 (adaptive step size ODE method).</p> <code>Dopri8</code> <p>Dormand-Prince method of order 8 (adaptive step size ODE method).</p> <code>Kvaerno3</code> <p>Kvaerno's method of order 3 (adaptive step size and implicit ODE method).</p> <code>Kvaerno5</code> <p>Kvaerno's method of order 5 (adaptive step size and implicit ODE method).</p> <code>Euler</code> <p>Euler method (fixed step size ODE method).</p> <code>EulerJump</code> <p>Euler-Jump method (fixed step size SDE method).</p> <code>EulerMaruyama</code> <p>Euler-Maruyama method (fixed step size SDE method).</p> <code>Rouchon1</code> <p>First-order Rouchon method (fixed step size ODE/SDE method).</p> <code>Rouchon2</code> <p>Second-order Rouchon method (fixed or adaptive step size ODE method).</p> <code>Rouchon3</code> <p>Third-order Rouchon method (fixed or adaptive step size ODE method).</p> <code>Expm</code> <p>Explicit matrix exponentiation to compute propagators.</p> <code>Event</code> <p>Event method for the jump SSE.</p> <code>JumpMonteCarlo</code> <p>Jump Monte Carlo method for the Lindblad master equation.</p> <code>DiffusiveMonteCarlo</code> <p>Diffusive Monte Carlo method for the Lindblad master equation.</p>"},{"location":"python_api/index.html#gradients-dqgradient","title":"Gradients (dq.gradient)","text":"<code>Direct</code> <p>Standard automatic differentiation of JAX.</p> <code>BackwardCheckpointed</code> <p>Checkpointed backward-mode automatic differentiation.</p> <code>Forward</code> <p>Forward-mode automatic differentiation.</p>"},{"location":"python_api/index.html#utilities","title":"Utilities","text":""},{"location":"python_api/index.html#operators","title":"Operators","text":"<code>eye</code> <p>Returns the identity operator.</p> <code>eye_like</code> <p>Returns the identity operator in the Hilbert space of the input.</p> <code>zeros</code> <p>Returns the null operator.</p> <code>zeros_like</code> <p>Returns the null operator in the Hilbert space of the input.</p> <code>destroy</code> <p>Returns a bosonic annihilation operator, or a tuple of annihilation operators for a multi-mode system.</p> <code>create</code> <p>Returns a bosonic creation operator, or a tuple of creation operators for a multi-mode system.</p> <code>number</code> <p>Returns the number operator of a bosonic mode, or a tuple of number operators for a multi-mode system.</p> <code>parity</code> <p>Returns the parity operator of a bosonic mode.</p> <code>displace</code> <p>Returns the displacement operator of complex amplitude \\(\\alpha\\).</p> <code>squeeze</code> <p>Returns the squeezing operator of complex squeezing amplitude \\(z\\).</p> <code>quadrature</code> <p>Returns the quadrature operator of phase angle \\(\\phi\\).</p> <code>position</code> <p>Returns the position operator \\(x = (a^\\dag + a) / 2\\).</p> <code>momentum</code> <p>Returns the momentum operator \\(p = i (a^\\dag - a) / 2\\).</p> <code>sigmax</code> <p>Returns the Pauli \\(\\sigma_x\\) operator.</p> <code>sigmay</code> <p>Returns the Pauli \\(\\sigma_y\\) operator.</p> <code>sigmaz</code> <p>Returns the Pauli \\(\\sigma_z\\) operator.</p> <code>xyz</code> <p>Returns the Pauli \\(\\sigma_x\\), \\(\\sigma_y\\) and \\(\\sigma_z\\) operators.</p> <code>sigmap</code> <p>Returns the Pauli raising operator \\(\\sigma_+\\).</p> <code>sigmam</code> <p>Returns the Pauli lowering operator \\(\\sigma_-\\).</p> <code>hadamard</code> <p>Returns the Hadamard transform on \\(n\\) qubits.</p> <code>rx</code> <p>Returns the \\(R_x(\\theta)\\) rotation gate.</p> <code>ry</code> <p>Returns the \\(R_y(\\theta)\\) rotation gate.</p> <code>rz</code> <p>Returns the \\(R_z(\\theta)\\) rotation gate.</p> <code>sgate</code> <p>Returns the \\(\\text{S}\\) gate.</p> <code>tgate</code> <p>Returns the \\(\\text{T}\\) gate.</p> <code>cnot</code> <p>Returns the \\(\\text{CNOT}\\) gate.</p> <code>toffoli</code> <p>Returns the \\(\\text{Toffoli}\\) gate.</p>"},{"location":"python_api/index.html#states","title":"States","text":"<code>fock</code> <p>Returns the ket of a Fock state or a tensor product of Fock states.</p> <code>fock_dm</code> <p>Returns the density matrix of a Fock state or a tensor product of Fock states.</p> <code>basis</code> <p>Alias of <code>dq.fock()</code>.</p> <code>basis_dm</code> <p>Alias of <code>dq.fock_dm()</code>.</p> <code>coherent</code> <p>Returns the ket of a coherent state or a tensor product of coherent states.</p> <code>coherent_dm</code> <p>Returns the density matrix of a coherent state or a tensor product of coherent states.</p> <code>ground</code> <p>Returns the eigenvector with eigenvalue \\(-1\\) of the Pauli \\(\\sigma_z\\) operator.</p> <code>ground_dm</code> <p>Returns the projector on the eigenvector with eigenvalue \\(-1\\) of the Pauli \\(\\sigma_z\\) operator.</p> <code>excited</code> <p>Returns the eigenvector with eigenvalue \\(+1\\) of the Pauli \\(\\sigma_z\\) operator.</p> <code>excited_dm</code> <p>Returns the projector on the eigenvector with eigenvalue \\(+1\\) of the Pauli \\(\\sigma_z\\) operator.</p> <code>thermal_dm</code> <p>Returns the density matrix of a thermal state or a tensor product of thermal states.</p>"},{"location":"python_api/index.html#quantum-utilities","title":"Quantum utilities","text":"<code>dag</code> <p>Returns the adjoint (complex conjugate transpose) of a matrix.</p> <code>powm</code> <p>Returns the \\(n\\)-th matrix power of a qarray.</p> <code>expm</code> <p>Returns the matrix exponential of a qarray.</p> <code>cosm</code> <p>Returns the cosine of a qarray.</p> <code>sinm</code> <p>Returns the sine of a qarray.</p> <code>signm</code> <p>Returns the operator sign function of a Hermitian qarray.</p> <code>trace</code> <p>Returns the trace of a qarray along its last two dimensions.</p> <code>tracemm</code> <p>Return the trace of a matrix multiplication using a fast implementation.</p> <code>ptrace</code> <p>Returns the partial trace of a ket, bra or density matrix.</p> <code>tensor</code> <p>Returns the tensor product of multiple kets, bras, density matrices or operators.</p> <code>expect</code> <p>Returns the expectation value of an operator or list of operators on a ket, bra or density matrix.</p> <code>norm</code> <p>Returns the norm of a ket, bra, density matrix, or Hermitian matrix.</p> <code>unit</code> <p>Normalize a ket, bra, density matrix or Hermitian matrix to unit norm.</p> <code>dissipator</code> <p>Applies the Lindblad dissipation superoperator to a density matrix.</p> <code>lindbladian</code> <p>Applies the Lindbladian superoperator to a density matrix.</p> <code>isket</code> <p>Returns True if the qarray is in the format of a ket.</p> <code>isbra</code> <p>Returns True if the qarray is in the format of a bra.</p> <code>isdm</code> <p>Returns True if the qarray is in the format of a density matrix.</p> <code>isop</code> <p>Returns True if the qarray is in the format of an operator.</p> <code>isherm</code> <p>Returns True if the qarray is Hermitian.</p> <code>toket</code> <p>Returns the ket representation of a pure quantum state.</p> <code>tobra</code> <p>Returns the bra representation of a pure quantum state.</p> <code>todm</code> <p>Returns the density matrix representation of a quantum state.</p> <code>proj</code> <p>Returns the projection operator onto a pure quantum state.</p> <code>braket</code> <p>Returns the inner product \\(\\braket{\\psi|\\varphi}\\) between two kets.</p> <code>overlap</code> <p>Returns the overlap between two quantum states.</p> <code>fidelity</code> <p>Returns the fidelity of two states, kets or density matrices.</p> <code>purity</code> <p>Returns the purity of a ket or density matrix.</p> <code>entropy_vn</code> <p>Returns the Von Neumann entropy of a ket or density matrix.</p> <code>entropy_relative</code> <p>Returns the quantum relative entropy between two kets or density matrices.</p> <code>bloch_coordinates</code> <p>Returns the spherical coordinates \\((r, \\theta, \\phi)\\) of a ket or density matrix on the Bloch sphere.</p> <code>wigner</code> <p>Compute the Wigner distribution of a ket or density matrix.</p>"},{"location":"python_api/index.html#qarray-utilities","title":"QArray utilities","text":"<code>asqarray</code> <p>Converts a qarray-like into a qarray.</p> <code>isqarraylike</code> <p>Returns True if the input is a qarray-like.</p> <code>stack</code> <p>Join a sequence of qarrays along a new axis.</p> <code>to_jax</code> <p>Convert a qarray-like into a JAX array.</p> <code>to_numpy</code> <p>Convert a qarray-like into a NumPy array.</p> <code>to_qutip</code> <p>Convert a qarray-like into a QuTiP Qobj or list of Qobjs.</p> <code>sparsedia_from_dict</code> <p>Initialize a <code>SparseDIAQArray</code> from a dictionary of offsets and diagonals.</p>"},{"location":"python_api/index.html#global-settings","title":"Global settings","text":"<code>set_device</code> <p>Configure the default device.</p> <code>set_precision</code> <p>Configure the default floating point precision.</p> <code>set_matmul_precision</code> <p>Configure the default precision for matrix multiplications on GPUs and TPUs.</p> <code>set_layout</code> <p>Configure the default matrix layout for operators supporting this option.</p> <code>set_progress_meter</code> <p>Configure the default progress meter.</p>"},{"location":"python_api/index.html#vectorization","title":"Vectorization","text":"<code>vectorize</code> <p>Returns the vectorized version of an operator.</p> <code>unvectorize</code> <p>Returns the operator version of a vectorized operator.</p> <code>spre</code> <p>Returns the superoperator formed from pre-multiplication by an operator.</p> <code>spost</code> <p>Returns the superoperator formed from post-multiplication by an operator.</p> <code>sprepost</code> <p>Returns the superoperator formed from pre- and post-multiplication by operators.</p> <code>sdissipator</code> <p>Returns the Lindblad dissipation superoperator (in matrix form).</p> <code>slindbladian</code> <p>Returns the Lindbladian superoperator (in matrix form).</p>"},{"location":"python_api/index.html#quantum-optimal-control","title":"Quantum optimal control","text":"<code>snap_gate</code> <p>Returns a SNAP gate.</p> <code>cd_gate</code> <p>Returns a conditional displacement gate.</p>"},{"location":"python_api/index.html#random-dqrandom","title":"Random (dq.random)","text":"<code>real</code> <p>Returns an array of uniformly distributed random real numbers.</p> <code>complex</code> <p>Returns an array of uniformly distributed random complex numbers.</p> <code>herm</code> <p>Returns a random complex Hermitian matrix.</p> <code>psd</code> <p>Returns a random complex positive semi-definite matrix.</p> <code>dm</code> <p>Returns a random density matrix (hermitian, positive semi-definite, and unit trace).</p> <code>ket</code> <p>Returns a random ket with unit norm.</p>"},{"location":"python_api/index.html#plotting-dqplot","title":"Plotting (dq.plot)","text":"<code>wigner_mosaic</code> <p>Plot the Wigner function of multiple states in a mosaic arrangement.</p> <code>wigner_gif</code> <p>Plot a GIF of the Wigner function of multiple states.</p> <code>wigner_data</code> <p>Plot a pre-computed Wigner function.</p> <code>pwc_pulse</code> <p>Plot a piecewise constant pulse.</p> <code>fock_evolution</code> <p>Plot the photon number population of state as a function of time.</p> <code>xyz</code> <p>Plot the expectation value of the Pauli operators of a qubit \\(\\sigma_x\\), \\(\\sigma_y\\) and \\(\\sigma_z\\) as a function of time.</p> <code>gifit</code> <p>Transform a plot function into a new function that returns an animated GIF.</p> <code>grid</code> <p>Returns a figure and an iterator of subplots organised in a grid.</p> <code>mplstyle</code> <p>Set custom Matplotlib style.</p>"},{"location":"python_api/index.html#helpers","title":"Helpers","text":"<code>hc</code> <p>This symbol can be used as a shortcut to sum a qarray or a timeqarray with its Hermitian conjugate.</p> <code>clicktimes_sse_to_sme</code> <p>Post-process click times from a jump SSE simulation to obtain click times for a jump SME simulation.</p> <code>measurements_sse_to_sme</code> <p>Post-process measurements from a diffusive SSE simulation to obtain measurements for a diffusive SME simulation.</p>"},{"location":"python_api/gradient/BackwardCheckpointed.html","title":"BackwardCheckpointed","text":""},{"location":"python_api/gradient/BackwardCheckpointed.html#dynamiqs.gradient.BackwardCheckpointed","title":"dq.gradient.BackwardCheckpointed","text":"<pre><code>BackwardCheckpointed(ncheckpoints: int | None = None)\n</code></pre> <p>Checkpointed backward-mode automatic differentiation.</p> <p>With this option, the gradient is computed by automatically differentiating through the internals of the solver. The difference with the standard automatic differentiation (see <code>dq.gradient.Direct</code>) is that a checkpointing scheme is used to reduce the memory usage of the backpropagation.</p> Note <p>For most problems this is the preferred technique for backpropagating through the solvers.</p> Warning <p>This cannot be forward-mode autodifferentiated (e.g. using <code>jax.jvp</code> ). Try using <code>dq.gradient.Direct</code> if that is something you need.</p> Note <p>For Diffrax-based methods, this falls back to the <code>diffrax.RecursiveCheckpointAdjoint</code> option.</p> <p>Parameters:</p> <ul> <li> <code>ncheckpoints</code>         \u2013          <p>Number of checkpoints to use. The amount of memory used by the differential equation solve will be roughly equal to the number of checkpoints multiplied by the size of the state. You can speed up backpropagation by allocating more checkpoints, so it makes sense to set as many checkpoints as you have memory for. This value is set to <code>None</code> by default, in which case it will be set to <code>log(max_steps)</code>, for which a theoretical result is available guaranteeing that backpropagation will take <code>O(n_steps log(n_steps))</code> time in the number of steps <code>n_steps &lt;= max_steps</code>.</p> </li> </ul>"},{"location":"python_api/gradient/Direct.html","title":"Direct","text":""},{"location":"python_api/gradient/Direct.html#dynamiqs.gradient.Direct","title":"dq.gradient.Direct","text":"<pre><code>Direct()\n</code></pre> <p>Standard automatic differentiation of JAX.</p> <p>With this option, the gradient is computed by automatically differentiating through the internals of the solver.</p> Note <p>For Diffrax-based methods, this falls back to the <code>diffrax.DirectAdjoint</code> option.</p>"},{"location":"python_api/gradient/Forward.html","title":"Forward","text":""},{"location":"python_api/gradient/Forward.html#dynamiqs.gradient.Forward","title":"dq.gradient.Forward","text":"<pre><code>Forward()\n</code></pre> <p>Forward-mode automatic differentiation.</p> <p>Enables support for forward-mode automatic differentiation (like <code>jax.jvp</code>   or <code>jax.jacfwd</code>).</p> Note <p>This is the most efficient when the function has more outputs than inputs. For instance, it's the preferred method when simulating a Lindbladian parameterized with a few values and computing the Jacobian of a function returning the expectation values of many observables (or the same observable at many different times).</p> Warning <p>This cannot be backward-mode autodifferentiated (e.g. using <code>jax.jacrev</code>). Try using <code>dq.gradient.BackwardCheckpointed</code> if that is something you need.</p> Warning <p>By default  <code>jax.grad</code> uses reverse mode. Use <code>jax.jacfwd</code> to compute the gradient in forward mode.</p> Note <p>For Diffrax-based methods, this falls back to the <code>diffrax.ForwardMode</code> option.</p>"},{"location":"python_api/helpers/clicktimes_sse_to_sme.html","title":"clicktimes_sse_to_sme","text":""},{"location":"python_api/helpers/clicktimes_sse_to_sme.html#dynamiqs.helpers.clicktimes_sse_to_sme","title":"dq.clicktimes_sse_to_sme","text":"<pre><code>clicktimes_sse_to_sme(\n    clicktimes: ArrayLike,\n    tsave: ArrayLike,\n    thetas: ArrayLike,\n    etas: ArrayLike,\n    key: PRNGKeyArray,\n) -&gt; Array\n</code></pre> <p>Post-process click times from a jump SSE simulation to obtain click times for a jump SME simulation.</p> <p>The SME click times are obtained from the SSE click times by adding false clicks with rate \\(\\theta\\) and removing actual clicks with probability \\(1-\\eta\\).</p> <p>Parameters:</p> <ul> <li> <code>clicktimes</code>         \u2013          <p>See result of <code>dq.jssesolve()</code>.</p> </li> <li> <code>tsave</code>         \u2013          <p>See <code>dq.jssesolve()</code>.</p> </li> <li> <code>thetas</code>         \u2013          <p>See <code>dq.jsmesolve()</code>.</p> </li> <li> <code>etas</code>         \u2013          <p>See <code>dq.jsmesolve()</code>.</p> </li> <li> <code>key</code>         \u2013          <p>PRNG key used to sample the added noise for the post-processing.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>SME click times. The shape is the same as <code>clicktimes</code>, except that the dimension corresponding to the number of jump operators measured may be smaller, if the corresponding efficiency is null.</p> </li> </ul>"},{"location":"python_api/helpers/hc.html","title":"hc","text":""},{"location":"python_api/helpers/hc.html#dynamiqs.helpers.hc","title":"hc","text":"<pre><code>hc = HermitianConjugate()\n</code></pre> <p>This symbol can be used as a shortcut to sum a qarray or a timeqarray with its Hermitian conjugate.</p> <p>Examples:</p> <p>For a linear drive with amplitude <code>omega</code>: </p><pre><code>- H = a.dag() @ a + omega * a + omega.conj() * a.dag()\n+ H = a.dag() @ a + (omega * a + dq.hc)\n</code></pre><p></p> <p>For two linear drives on two different modes: </p><pre><code>- H = omega_a * a + omega_a.conj() * a.dag() + omega_b * b + omega_b.conj() * b\n+ H = (omega_a * a + dq.hc) + (omega_b * b + dq.hc)\n</code></pre><p></p> <p>For a time-dependent linear drive: </p><pre><code>omega = lambda t: jnp.cos(2.0 * jnp.pi * t)\n- H = dq.modulated(omega, a)\n- H += H.dag()\n+ H = dq.modulated(omega, a) + dq.hc\n</code></pre><p></p> Warning <p>The only valid operation with this symbol is right-addition to a qarray or a timeqarray. Any other operation will raise a <code>TypeError</code>.</p> Warning <p>The symbol applies on all terms present in the left-hand side of the addition. If you want to apply it to a single term, you should use parentheses to isolate it:</p> <pre><code>&gt;&gt;&gt; sx, sz = dq.sigmax(), dq.sigmaz()\n&gt;&gt;&gt; sz + (sx + dq.hc)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=3\n[[ 1.+0.j  2.+0.j]\n [ 2.+0.j -1.+0.j]]\n&gt;&gt;&gt; sz + sx + dq.hc\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=3\n[[ 2.+0.j  2.+0.j]\n [ 2.+0.j -2.+0.j]]\n</code></pre>"},{"location":"python_api/helpers/measurements_sse_to_sme.html","title":"measurements_sse_to_sme","text":""},{"location":"python_api/helpers/measurements_sse_to_sme.html#dynamiqs.helpers.measurements_sse_to_sme","title":"dq.measurements_sse_to_sme","text":"<pre><code>measurements_sse_to_sme(\n    measurements: ArrayLike, tsave: ArrayLike, etas: ArrayLike, key: PRNGKeyArray\n) -&gt; Array\n</code></pre> <p>Post-process measurements from a diffusive SSE simulation to obtain measurements for a diffusive SME simulation.</p> <p>The SME measurements are obtained from the SSE measurements by adding additional Gaussian noise.</p> Note <p>More precisely, the SME measurement record \\(\\dd Y\\) for a specific jump operator is defined as follows from the SSE measurement record \\(\\dd \\tilde Y\\): $$     \\dd Y = \\sqrt{\\eta}\\,\\dd \\tilde Y + \\sqrt{1-\\eta}\\,\\dd W $$ where \\(\\dd W\\) is another independent Wiener process sampled for the post-processing.</p> <p>The SME time-averaged measurement \\(I(t_n, t_{n+1})\\) is then defined as follows from the SSE time-averaged measurements \\(\\tilde I(t_n, t_{n+1})\\): $$     I(t_n, t_{n+1})     = \\frac{1}{\\Delta t_n}\\int_{t_n}^{t_{n+1}} \\dd Y(t)     = \\sqrt{\\eta}\\, \\tilde I(t_n, t_{n+1})     + \\sqrt{1-\\eta}\\,\\frac{\\Delta W}{\\sqrt{\\Delta t_n}}, $$ where \\(\\Delta t_n=t_{n+1}-t_n\\) and \\(\\Delta W\\sim \\mathcal{N}(0, 1)\\) is a standard Gaussian random variable.</p> <p>Parameters:</p> <ul> <li> <code>measurements</code>         \u2013          <p>See result of <code>dq.dssesolve()</code>.</p> </li> <li> <code>tsave</code>         \u2013          <p>See <code>dq.dssesolve()</code>.</p> </li> <li> <code>etas</code>         \u2013          <p>See <code>dq.dsmesolve()</code>.</p> </li> <li> <code>key</code>         \u2013          <p>PRNG key used to sample the added noise for the post-processing.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>SME measurements. The shape is the same as <code>measurements</code>, except that the dimension corresponding to the number of jump operators measured may be smaller, if the corresponding efficiency is null.</p> </li> </ul>"},{"location":"python_api/integrators/dsmesolve.html","title":"dsmesolve","text":""},{"location":"python_api/integrators/dsmesolve.html#dynamiqs.integrators.dsmesolve","title":"dq.dsmesolve","text":"<pre><code>dsmesolve(\n    H: QArrayLike | TimeQArray,\n    jump_ops: list[QArrayLike | TimeQArray],\n    etas: ArrayLike,\n    rho0: QArrayLike,\n    tsave: ArrayLike,\n    keys: PRNGKeyArray,\n    *,\n    exp_ops: list[QArrayLike] | None = None,\n    method: Method | None = None,\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; DSMESolveResult\n</code></pre> <p>Solve the diffusive stochastic master equation (SME).</p> <p>The diffusive SME describes the evolution of a quantum system measured by a diffusive detector (for example homodyne or heterodyne detection in quantum optics). This function computes the evolution of the density matrix \\(\\rho(t)\\) at time \\(t\\), starting from an initial state \\(\\rho_0\\), according to the diffusive SME in It\u00f4 form (\\(\\hbar=1\\), time is implicit(1)) $$     \\begin{split}         \\dd\\rho =&amp;~ -i[H, \\rho]\\,\\dt + \\sum_{k=1}^N \\left(             L_k \\rho L_k^\\dag             - \\frac{1}{2} L_k^\\dag L_k \\rho             - \\frac{1}{2} \\rho L_k^\\dag L_k     \\right)\\dt \\\\         &amp;+ \\sum_{k=1}^N \\sqrt{\\eta_k} \\left(             L_k \\rho             + \\rho L_k^\\dag             - \\tr{(L_k+L_k^\\dag)\\rho}\\rho         \\right)\\dd W_k,     \\end{split} $$ where \\(H\\) is the system's Hamiltonian, \\(\\{L_k\\}\\) is a collection of jump operators, each continuously measured with efficiency \\(0\\leq\\eta_k\\leq1\\) (\\(\\eta_k=0\\) for purely dissipative loss channels) and \\(\\dd W_k\\) are independent Wiener processes.</p> <ol> <li>With explicit time dependence:<ul> <li>\\(\\rho\\to\\rho(t)\\)</li> <li>\\(H\\to H(t)\\)</li> <li>\\(L_k\\to L_k(t)\\)</li> <li>\\(\\dd W_k\\to \\dd W_k(t)\\)</li> </ul> </li> </ol> <p>The continuous-time measurements are defined with the It\u00f4 processes \\(\\dd Y_k\\) (time is implicit) $$     \\dd Y_k = \\sqrt{\\eta_k} \\tr{(L_k + L_k^\\dag) \\rho} \\dt + \\dd W_k. $$</p> <p>The solver returns the time-averaged measurements \\(I_k(t_n, t_{n+1})\\) defined for each time interval \\([t_n, t_{n+1}[\\) by $$     I_k(t_n, t_{n+1}) = \\frac{Y_k(t_{n+1}) - Y_k(t_n)}{t_{n+1} - t_n}     = \\frac{1}{t_{n+1}-t_n}\\int_{t_n}^{t_{n+1}} \\dd Y_k(t) $$ The time intervals \\([t_n, t_{n+1}[\\) are defined by <code>tsave</code>, so the number of returned measurement values for each detector is <code>len(tsave)-1</code>.</p> Warning <p>For now, <code>dsmesolve()</code> only supports linearly spaced <code>tsave</code> with values that are exact multiples of the method fixed step size <code>dt</code>. Moreover, to JIT-compile code using <code>dsmesolve()</code>, <code>tsave</code> must be passed as tuple.</p> Simulating the measurement record only <p>If you are only interested in the measurement record and not the state, you should use <code>dq.dssesolve()</code> instead, and post-process the SSE measurement record to obtain the SME measurement record. You can use the helper function <code>dq.measurements_sse_to_sme()</code> to do this: </p><pre><code>result_sse = dq.dssesolve(H, jump_ops, psi0, tsave, keys)\nkey = jax.random.key(42)\nmeasurements_sme = dq.measurements_sse_to_sme(\n    result_sse.measurements, tsave, etas, key\n)\n</code></pre> This results in a significant speedup for large systems.<p></p> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like or timeqarray of shape (...H, n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>jump_ops</code>             (list of qarray-like or timeqarray, each of shape (n, n))         \u2013          <p>List of jump operators.</p> </li> <li> <code>etas</code>             (array-like of shape (len(jump_ops),))         \u2013          <p>Measurement efficiency for each loss channel with values between 0 (purely dissipative) and 1 (perfectly measured). No measurement is returned for purely dissipative loss channels.</p> </li> <li> <code>rho0</code>             (qarray-like of shape (...rho0, n, 1) or (...rho0, n, n))         \u2013          <p>Initial state.</p> </li> <li> <code>tsave</code>             (array-like of shape (ntsave,))         \u2013          <p>Times at which the states and expectation values are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>. Measurements are time-averaged and saved over each interval defined by <code>tsave</code>.</p> </li> <li> <code>keys</code>             (list of PRNG keys)         \u2013          <p>PRNG keys used to sample the Wiener processes. The number of elements defines the number of sampled stochastic trajectories.</p> </li> <li> <code>exp_ops</code>             (list of array-like, each of shape (n, n))         \u2013          <p>List of operators for which the expectation value is computed.</p> </li> <li> <code>method</code>         \u2013          <p>Method for the integration. No defaults for now, you have to specify a method (supported: <code>EulerMaruyama</code>, <code>Rouchon1</code>).</p> </li> <li> <code>gradient</code>         \u2013          <p>Algorithm used to compute the gradient. The default is method-dependent, refer to the documentation of the chosen method for more details.</p> </li> <li> <code>options</code>         \u2013          <p>Generic options (supported: <code>save_states</code>, <code>cartesian_batching</code>, <code>save_extra</code>).</p> Detailed options API <pre><code>dq.Options(\n    save_states: bool = True,\n    cartesian_batching: bool = True,\n    save_extra: callable[[Array], PyTree] | None = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>save_states</code> - If <code>True</code>, the state is saved at every time in     <code>tsave</code>, otherwise only the final state is returned.</li> <li><code>cartesian_batching</code> - If <code>True</code>, batched arguments are treated as     separated batch dimensions, otherwise the batching is performed over     a single shared batched dimension.</li> <li><code>save_extra</code> (function, optional) - A function with signature     <code>f(QArray) -&gt; PyTree</code> that takes a state as input and returns a     PyTree. This can be used to save additional arbitrary data     during the integration, accessible in <code>result.extra</code>.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>dq.DSMESolveResult</code> object holding the result of the diffusive SME integration. Use <code>result.states</code> to access the saved states, <code>result.expects</code> to access the saved expectation values and <code>result.measurements</code> to access the detector measurements.</p> Detailed result API <pre><code>dq.DSMESolveResult\n</code></pre> <p>For the shape indications we define <code>ntrajs</code> as the number of trajectories (<code>ntrajs = len(keys)</code>) and <code>nLm</code> as the number of measured loss channels (those for which the measurement efficiency is not zero).</p> <p>Attributes:</p> <ul> <li><code>states</code> (qarray of shape (..., ntrajs, nsave, n, n)) - Saved     states with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if     <code>options.save_states=False</code>.</li> <li><code>final_state</code> (qarray of shape (..., ntrajs, n, n)) - Saved     final state.</li> <li><code>expects</code> (array of shape (..., ntrajs, len(exp_ops), ntsave)     or None) - Saved expectation values, if specified by <code>exp_ops</code>.</li> <li><code>measurements</code> (array of shape (..., ntrajs, nLm, nsave-1)) -     Saved measurements.</li> <li><code>extra</code> (PyTree or None) - Extra data saved with <code>save_extra()</code>     if specified in <code>options</code>.</li> <li><code>keys</code> (PRNG key array of shape (ntrajs,)) - PRNG keys used to     sample the Wiener processes.</li> <li><code>infos</code> (PyTree or None) - Method-dependent information on the     resolution.</li> <li><code>tsave</code> (array of shape (ntsave,)) - Times for which results     were saved.</li> <li><code>method</code> (Method) - Method used.</li> <li><code>gradient</code> (Gradient) - Gradient used.</li> <li><code>options</code> (Options) - Options used.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport jax\n\nn = 16\na = dq.destroy(n)\n\nH = a.dag() @ a\njump_ops = [a]\netas = [0.5]\npsi0 = dq.coherent(n, 1.0)\ntsave = jnp.linspace(0, 1.0, 11)\nkeys = jax.random.split(jax.random.key(42), 100)\n\nmethod = dq.method.EulerMaruyama(dt=1e-3)\nresult = dq.dsmesolve(H, jump_ops, etas, psi0, tsave, keys, method=method)\nprint(result)\n</code></pre> Output<pre><code>==== DSMESolveResult ====\nMethod       : EulerMaruyama\nInfos        : 1000 steps | infos shape (100,)\nStates       : QArray complex64 (100, 11, 16, 16) | 2.1 Mb\nMeasurements : Array float32 (100, 1, 10) | 3.9 Kb\n</code></pre>"},{"location":"python_api/integrators/dsmesolve.html#dynamiqs.integrators.dsmesolve--advanced-use-cases","title":"Advanced use-cases","text":""},{"location":"python_api/integrators/dsmesolve.html#dynamiqs.integrators.dsmesolve--defining-a-time-dependent-hamiltonian-or-jump-operator","title":"Defining a time-dependent Hamiltonian or jump operator","text":"<p>If the Hamiltonian or the jump operators depend on time, they can be converted to time-arrays using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p>"},{"location":"python_api/integrators/dsmesolve.html#dynamiqs.integrators.dsmesolve--running-multiple-simulations-concurrently","title":"Running multiple simulations concurrently","text":"<p>The Hamiltonian <code>H</code> and the initial density matrix <code>rho0</code> can be batched to solve multiple SMEs concurrently. All other arguments (including the PRNG key) are common to every batch. The resulting states, measurements and expectation values are batched according to the leading dimensions of <code>H</code> and <code>rho0</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option.</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are </p><pre><code>... = ...H, ...rho0\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>rho0</code> has shape (4, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, ntrajs, ntsave, n, n).</p> <p>The results leading dimensions are </p><pre><code>... = ...H = ...rho0  # (once broadcasted)\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>rho0</code> has shape (3, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntrajs, ntsave, n, n).</p> <p>See the Batching simulations tutorial for more details.</p> Warning <p>Batching on <code>jump_ops</code> and <code>etas</code> is not yet supported, if this is needed don't hesitate to open an issue on GitHub.</p>"},{"location":"python_api/integrators/dssesolve.html","title":"dssesolve","text":""},{"location":"python_api/integrators/dssesolve.html#dynamiqs.integrators.dssesolve","title":"dq.dssesolve","text":"<pre><code>dssesolve(\n    H: QArrayLike | TimeQArray,\n    jump_ops: list[QArrayLike | TimeQArray],\n    psi0: QArrayLike,\n    tsave: ArrayLike,\n    keys: PRNGKeyArray,\n    *,\n    exp_ops: list[QArrayLike] | None = None,\n    method: Method | None = None,\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; DSSESolveResult\n</code></pre> <p>Solve the diffusive stochastic Schr\u00f6dinger equation (SSE).</p> <p>The diffusive SSE describes the evolution of a quantum system measured by an ideal diffusive detector (for example homodyne or heterodyne detection in quantum optics). This function computes the evolution of the state vector \\(\\ket{\\psi(t)}\\) at time \\(t\\), starting from an initial state \\(\\ket{\\psi_0}\\) according to the diffusive SSE in It\u00f4 form (\\(\\hbar=1\\), time is implicit(1)) $$     \\begin{split}         \\dd\\!\\ket\\psi = \\Bigg[             &amp;-iH \\dt             -\\frac12 \\sum_{k=1}^N \\left(                 L_k^\\dag L_k - \\braket{L_k + L_k^\\dag} L_k                 + \\frac14 \\braket{L_k + L_k^\\dag }^2             \\right) \\dt \\\\             &amp;+ \\sum_{k=1}^N \\left(                 L_k - \\frac12 \\braket{L_k + L_k^\\dag}             \\right) \\dd W_k         \\Bigg] \\!\\ket\\psi     \\end{split} $$ where \\(H\\) is the system's Hamiltonian, \\(\\{L_k\\}\\) is a collection of jump operators, each continuously measured with perfect efficiency and \\(\\dd W_k\\) are independent Wiener processes.</p> <ol> <li>With explicit time dependence:<ul> <li>\\(\\ket\\psi\\to\\ket{\\psi(t)}\\)</li> <li>\\(H\\to H(t)\\)</li> <li>\\(L_k\\to L_k(t)\\)</li> <li>\\(\\dd W_k\\to \\dd W_k(t)\\)</li> </ul> </li> </ol> <p>The continuous-time measurements are defined with the It\u00f4 processes \\(\\dd Y_k\\) (time is implicit) $$     \\dd Y_k = \\braket{L_k + L_k^\\dag} \\dt + \\dd W_k. $$</p> <p>The solver returns the time-averaged measurements \\(I_k(t_n, t_{n+1})\\) defined for each time interval \\([t_n, t_{n+1}[\\) by $$     I_k(t_n, t_{n+1}) = \\frac{Y_k(t_{n+1}) - Y_k(t_n)}{t_{n+1} - t_n}     = \\frac{1}{t_{n+1}-t_n}\\int_{t_n}^{t_{n+1}} \\dd Y_k(t) $$ The time intervals \\([t_n, t_{n+1}[\\) are defined by <code>tsave</code>, so the number of returned measurement values for each detector is <code>len(tsave)-1</code>.</p> Warning <p>For now, <code>dssesolve()</code> only supports linearly spaced <code>tsave</code> with values that are exact multiples of the method fixed step size <code>dt</code>. Moreover, to JIT-compile code using <code>dssesolve()</code>, <code>tsave</code> must be passed as tuple.</p> Note <p>If you are only interested in simulating trajectories to solve the Lindblad master equation, consider using <code>dq.mesolve()</code> with the <code>dq.method.DiffusiveMonteCarlo</code> method.</p> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like or timeqarray of shape (...H, n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>jump_ops</code>             (list of qarray-like or timeqarray, each of shape (...Lk, n, n))         \u2013          <p>List of jump operators.</p> </li> <li> <code>psi0</code>             (qarray-like of shape (...psi0, n, 1))         \u2013          <p>Initial state.</p> </li> <li> <code>tsave</code>             (array-like of shape (ntsave,))         \u2013          <p>Times at which the states and expectation values are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>. Measurements are time-averaged and saved over each interval defined by <code>tsave</code>.</p> </li> <li> <code>keys</code>             (list of PRNG keys)         \u2013          <p>PRNG keys used to sample the Wiener processes. The number of elements defines the number of sampled stochastic trajectories.</p> </li> <li> <code>exp_ops</code>             (list of array-like, each of shape (n, n))         \u2013          <p>List of operators for which the expectation value is computed.</p> </li> <li> <code>method</code>         \u2013          <p>Method for the integration. No defaults for now, you have to specify a method (supported: <code>EulerMaruyama</code>, <code>Rouchon1</code>).</p> </li> <li> <code>gradient</code>         \u2013          <p>Algorithm used to compute the gradient. The default is method-dependent, refer to the documentation of the chosen method for more details.</p> </li> <li> <code>options</code>         \u2013          <p>Generic options (supported: <code>save_states</code>, <code>cartesian_batching</code>, <code>save_extra</code>).</p> Detailed options API <pre><code>dq.Options(\n    save_states: bool = True,\n    cartesian_batching: bool = True,\n    save_extra: callable[[Array], PyTree] | None = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>save_states</code> - If <code>True</code>, the state is saved at every time in     <code>tsave</code>, otherwise only the final state is returned.</li> <li><code>cartesian_batching</code> - If <code>True</code>, batched arguments are treated as     separated batch dimensions, otherwise the batching is performed over     a single shared batched dimension.</li> <li><code>save_extra</code> (function, optional) - A function with signature     <code>f(QArray) -&gt; PyTree</code> that takes a state as input and returns a     PyTree. This can be used to save additional arbitrary data     during the integration, accessible in <code>result.extra</code>.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>dq.DSSESolveResult</code> object holding the result of the diffusive SSE integration. Use <code>result.states</code> to access the saved states, <code>result.expects</code> to access the saved expectation values and <code>result.measurements</code> to access the detector measurements.</p> Detailed result API <pre><code>dq.DSSESolveResult\n</code></pre> <p>For the shape indications we define <code>ntrajs</code> as the number of trajectories (<code>ntrajs = len(keys)</code>).</p> <p>Attributes:</p> <ul> <li><code>states</code> (qarray of shape (..., ntrajs, nsave, n, 1)) - Saved     states with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if     <code>options.save_states=False</code>.</li> <li><code>final_state</code> (qarray of shape (..., ntrajs, n, 1)) - Saved     final state.</li> <li><code>expects</code> (array of shape (..., ntrajs, len(exp_ops), ntsave)     or None) - Saved expectation values, if specified by <code>exp_ops</code>.</li> <li><code>measurements</code> (array of shape     (..., ntrajs, len(jump_ops), nsave-1)) - Saved measurements.</li> <li><code>extra</code> (PyTree or None) - Extra data saved with <code>save_extra()</code>     if specified in <code>options</code>.</li> <li><code>keys</code> (PRNG key array of shape (ntrajs,)) - PRNG keys used to     sample the Wiener processes.</li> <li><code>infos</code> (PyTree or None) - Method-dependent information on the     resolution.</li> <li><code>tsave</code> (array of shape (ntsave,)) - Times for which results     were saved.</li> <li><code>method</code> (Method) - Method used.</li> <li><code>gradient</code> (Gradient) - Gradient used.</li> <li><code>options</code> (Options) - Options used.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport jax\n\nn = 16\na = dq.destroy(n)\n\nH = a.dag() @ a\njump_ops = [a]\npsi0 = dq.coherent(n, 1.0)\ntsave = jnp.linspace(0, 1.0, 11)\nkeys = jax.random.split(jax.random.key(42), 100)\n\nmethod = dq.method.EulerMaruyama(dt=1e-3)\nresult = dq.dssesolve(H, jump_ops, psi0, tsave, keys, method=method)\nprint(result)\n</code></pre> Output<pre><code>==== DSSESolveResult ====\nMethod       : EulerMaruyama\nInfos        : 1000 steps | infos shape (100,)\nStates       : QArray complex64 (100, 11, 16, 1) | 137.5 Kb\nMeasurements : Array float32 (100, 1, 10) | 3.9 Kb\n</code></pre>"},{"location":"python_api/integrators/dssesolve.html#dynamiqs.integrators.dssesolve--advanced-use-cases","title":"Advanced use-cases","text":""},{"location":"python_api/integrators/dssesolve.html#dynamiqs.integrators.dssesolve--defining-a-time-dependent-hamiltonian-or-jump-operator","title":"Defining a time-dependent Hamiltonian or jump operator","text":"<p>If the Hamiltonian or the jump operators depend on time, they can be converted to time-arrays using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p>"},{"location":"python_api/integrators/dssesolve.html#dynamiqs.integrators.dssesolve--running-multiple-simulations-concurrently","title":"Running multiple simulations concurrently","text":"<p>The Hamiltonian <code>H</code>, the jump operators <code>jump_ops</code> and the initial state <code>psi0</code> can be batched to solve multiple SSEs concurrently. All other arguments (including the PRNG key) are common to every batch. The resulting states, measurements and expectation values are batched according to the leading dimensions of <code>H</code>, <code>jump_ops</code> and <code>psi0</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option.</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are </p><pre><code>... = ...H, ...L0, ...L1, (...), ...psi0\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(4, 5, n, n), (6, n, n)],</li> <li><code>psi0</code> has shape (7, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, 5, 6, 7, ntrajs, ntsave, n, 1).</p> <p>The results leading dimensions are </p><pre><code>... = ...H = ...L0 = ...L1 = (...) = ...psi0  # (once broadcasted)\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(3, n, n), (2, 1, n, n)],</li> <li><code>psi0</code> has shape (3, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntrajs, ntsave, n, 1).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/integrators/floquet.html","title":"floquet","text":""},{"location":"python_api/integrators/floquet.html#dynamiqs.integrators.floquet","title":"dq.floquet","text":"<pre><code>floquet(\n    H: QArrayLike | TimeQArray,\n    T: float,\n    tsave: ArrayLike,\n    *,\n    method: Method = Tsit5(),\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; FloquetResult\n</code></pre> <p>Compute Floquet modes and quasienergies of a periodic closed system.</p> <p>The Floquet modes \\(\\Phi_{m}(t_0)\\) and corresponding quasienergies \\(\\epsilon_m\\) are defined by the eigenvalue equation $$     U(t_0, t_0+T)\\Phi_{m}(t_0) = \\exp(-i \\epsilon_{m} T)\\Phi_{m}(t_0), $$ where \\(U(t_0, t_0+T)\\) is the propagator over a single period \\(T\\), with \\(t_0\\) some arbitrary initial time (typically \\(t_0 = 0\\)). According to the Floquet theorem, these Floquet modes are periodic with period \\(T\\) and form a complete basis for the time evolution of the system. The \\(t=t_0\\) Floquet modes are obtained from diagonalization of the above propagator, while the \\(t \\geq t_0\\) Floquet modes are obtained by propagating the \\(t=t_0\\) Floquet modes forward in time, via $$     \\Phi_{m}(t) = \\exp(i\\epsilon_{m}t)U(t_0, t_0+t)\\Phi_{m}(t_0). $$</p> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like or timeqarray of shape (...H, n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>T</code>         \u2013          <p>Period of the Hamiltonian. If the Hamiltonian is batched, the period should be common over all elements in the batch. To batch over different periods, wrap the call to <code>floquet</code> in a <code>jax.vmap</code>, see above.</p> </li> <li> <code>tsave</code>             (array-like of shape (ntsave,))         \u2013          <p>Times at which to compute floquet modes. The specified times should be ordered, strictly ascending, and such that <code>tsave[-1] - tsave[0] &lt;= T</code>.</p> </li> <li> <code>method</code>         \u2013          <p>Method for the integration. Defaults to <code>dq.method.Tsit5</code> (supported: <code>Tsit5</code>, <code>Dopri5</code>, <code>Dopri8</code>, <code>Kvaerno3</code>, <code>Kvaerno5</code>, <code>Euler</code>).</p> </li> <li> <code>gradient</code>         \u2013          <p>Algorithm used to compute the gradient.</p> </li> <li> <code>options</code>         \u2013          <p>Generic options (supported: <code>progress_meter</code>, <code>t0</code>).</p> Detailed options API <pre><code>dq.Options(\n    progress_meter: AbstractProgressMeter | bool | None = None,\n    t0: ScalarLike | None = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>progress_meter</code> - Progress meter indicating how far the solve has     progressed. Defaults to <code>None</code> which uses the global default     progress meter (see     <code>dq.set_progress_meter()</code>). Set to     <code>True</code> for a tqdm progress meter,     and <code>False</code> for no output. See other options in     dynamiqs/progress_meter.py.     If gradients are computed, the progress meter only displays during     the forward pass.</li> <li><code>t0</code> - Initial time. If <code>None</code>, defaults to the first time in     <code>tsave</code>.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>dq.FloquetResult</code> object holding the result of the Floquet computation. Use <code>result.modes</code> to access the saved Floquet modes and <code>result.quasienergies</code> for the associated quasienergies.</p> Detailed result API <pre><code>dq.FloquetResult\n</code></pre> <p>Attributes:</p> <ul> <li><code>modes</code> (qarray of shape (..., ntsave, n, n, 1)) - Saved Floquet     modes.</li> <li><code>quasienergies</code> (array of shape (..., n)) - Saved quasienergies</li> <li><code>T</code> (float) - Drive period</li> <li><code>infos</code> (PyTree or None) - Method-dependent information on the     resolution.</li> <li><code>tsave</code> (array of shape (ntsave,)) - Times for which results     were saved.</li> <li><code>method</code> (Method) - Method used.</li> <li><code>gradient</code> (Gradient) - Gradient used.</li> <li><code>options</code> (Options) - Options used.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\n\nn = 16\na = dq.destroy(n)\n\nf = lambda t: jnp.cos(2 * jnp.pi * t)\nH = dq.modulated(f, dq.sigmax())\nT = 1.0\ntsave = jnp.linspace(0, 1.0, 11)\n\nresult = dq.floquet(H, T, tsave)\nprint(result)\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 0.89ms \u25c6 remaining 0.00ms\n==== FloquetResult ====\nMethod        : Tsit5\nInfos         : 11 steps (10 accepted, 1 rejected)\nModes         : QArray complex64 (11, 2, 2, 1) | 0.3 Kb\nQuasienergies : Array float32 (2,) | 0.0 Kb\n</code></pre>"},{"location":"python_api/integrators/floquet.html#dynamiqs.integrators.floquet--advanced-use-cases","title":"Advanced use-cases","text":""},{"location":"python_api/integrators/floquet.html#dynamiqs.integrators.floquet--running-multiple-simulations-concurrently","title":"Running multiple simulations concurrently","text":"<p>The Hamiltonian <code>H</code> can be batched to compute multiple Floquet modes and quasienergies concurrently. All other arguments are common to every batch. The Floquet modes and quasienergies are batched according to the leading dimensions of <code>H</code>. For example if <code>H</code> has shape (2, 3, n, n), then <code>result.modes</code> has shape (2, 3, ntsave, n, n, 1).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/integrators/floquet.html#dynamiqs.integrators.floquet--batching-over-drive-periods","title":"Batching over drive periods","text":"<p>The current API does not yet natively support batching over multiple drive periods, for instance if you wanted to batch over Hamiltonians with different drive frequencies. This however can be achieved straightforwardly with an external call to <code>jax.vmap</code>, as follows:</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport dynamiqs as dq\n\n\ndef single_floquet(omega):\n    H = dq.modulated(lambda t: jnp.cos(omega * t), dq.sigmax())\n    T = 2.0 * jnp.pi / omega\n    tsave = jnp.linspace(0.0, T, 11)\n    return dq.floquet(H, T, tsave)\n\n\nomegas = jnp.array([0.9, 1.0, 1.1])\nbatched_floquet = jax.vmap(single_floquet)\nresult = batched_floquet(omegas)\n</code></pre>"},{"location":"python_api/integrators/jsmesolve.html","title":"jsmesolve","text":""},{"location":"python_api/integrators/jsmesolve.html#dynamiqs.integrators.jsmesolve","title":"dq.jsmesolve","text":"<pre><code>jsmesolve(\n    H: QArrayLike | TimeQArray,\n    jump_ops: list[QArrayLike | TimeQArray],\n    thetas: ArrayLike,\n    etas: ArrayLike,\n    rho0: QArrayLike,\n    tsave: ArrayLike,\n    keys: PRNGKeyArray,\n    *,\n    exp_ops: list[QArrayLike] | None = None,\n    method: Method | None = None,\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; JSMESolveResult\n</code></pre> <p>Solve the jump stochastic master equation (SME).</p> <p>The jump SME describes the evolution of a quantum system measured by a jump detector (for example photodetection in quantum optics). This function computes the evolution of the density matrix \\(\\rho(t)\\) at time \\(t\\), starting from an initial state \\(\\rho_0\\), according to the jump SME (\\(\\hbar=1\\), time is implicit(1)) $$     \\begin{split}         \\dd\\rho =&amp;~ -i[H, \\rho]\\,\\dt + \\sum_{k=1}^N \\left(             L_k \\rho L_k^\\dag             - \\frac{1}{2} L_k^\\dag L_k \\rho             - \\frac{1}{2} \\rho L_k^\\dag L_k     \\right)\\dt \\\\         &amp;+ \\sum_{k=1}^N \\left(             \\frac{\\theta_k \\rho+ \\eta_k L_k\\rho L_k^\\dag}{\\theta_k + \\eta_k \\tr{L_k\\rho L_k^\\dag}}             - \\rho         \\right)\\left(\\dd N_k - \\left(\\theta_k + \\eta_k \\tr{L_k\\rho L_k^\\dag}\\right) \\dt\\right),     \\end{split} $$ where \\(H\\) is the system's Hamiltonian, \\(\\{L_k\\}\\) is a collection of jump operators, each continuously measured with dark count rate \\(\\theta_k\\geq0\\) and efficiency \\(0\\leq\\eta_k\\leq1\\) (\\(\\eta_k=0\\) for purely dissipative loss channels) and \\(\\dd N_k\\) are independent point processes with law $$     \\begin{split}         \\mathbb{P}[\\dd N_k = 0] &amp;= 1 - \\mathbb{P}[\\dd N_k = 1], \\\\         \\mathbb{P}[\\dd N_k = 1] &amp;= \\left(\\theta_k + \\eta_k \\tr{L_k\\rho L_k^\\dag}\\right) \\dt.     \\end{split} $$</p> <ol> <li>With explicit time dependence:<ul> <li>\\(\\rho\\to\\rho(t)\\)</li> <li>\\(H\\to H(t)\\)</li> <li>\\(L_k\\to L_k(t)\\)</li> <li>\\(\\dd N_k\\to \\dd N_k(t)\\)</li> </ul> </li> </ol> <p>The continuous-time measurements are defined by the point processes \\(\\dd N_k\\). The solver returns the times at which the detector clicked, \\(I_k = \\{t \\in [t_0, t_\\text{end}[ \\,|\\, \\dd N_k(t)=1\\}\\).</p> Warning <p>For now, <code>jsmesolve()</code> only supports linearly spaced <code>tsave</code> with values that are exact multiples of the method fixed step size <code>dt</code>. Moreover, to JIT-compile code using <code>jsmesolve()</code>, <code>tsave</code> must be passed as tuple.</p> Simulating the measurement record only <p>If you are only interested in the measurement record and not the state, you should use <code>dq.dssesolve()</code> instead, and post-process the SSE measurement record to obtain the SME measurement record. You can use the helper function <code>dq.clicktimes_sse_to_sme()</code> to do this: </p><pre><code>result_sse = dq.jssesolve(H, jump_ops, psi0, tsave, keys)\nkey = jax.random.key(42)\nclicktimes_sme = dq.clicktimes_sse_to_sme(\n    result_sse.clicktimes, tsave, thetas, etas, key\n)\n</code></pre> This results in a significant speedup for large systems.<p></p> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like or timeqarray of shape (...H, n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>jump_ops</code>             (list of qarray-like or timeqarray, each of shape (n, n))         \u2013          <p>List of jump operators.</p> </li> <li> <code>thetas</code>             (array-like of shape (len(jump_ops),))         \u2013          <p>Dark count rate for each loss channel.</p> </li> <li> <code>etas</code>             (array-like of shape (len(jump_ops),))         \u2013          <p>Measurement efficiency for each loss channel with values between 0 (purely dissipative) and 1 (perfectly measured). No measurement is returned for purely dissipative loss channels.</p> </li> <li> <code>rho0</code>             (qarray-like of shape (...rho0, n, 1) or (...rho0, n, n))         \u2013          <p>Initial state.</p> </li> <li> <code>tsave</code>             (array-like of shape (ntsave,))         \u2013          <p>Times at which the states and expectation values are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>.</p> </li> <li> <code>keys</code>             (list of PRNG keys)         \u2013          <p>PRNG keys used to sample the point processes. The number of elements defines the number of sampled stochastic trajectories.</p> </li> <li> <code>exp_ops</code>             (list of array-like, each of shape (n, n))         \u2013          <p>List of operators for which the expectation value is computed.</p> </li> <li> <code>method</code>         \u2013          <p>Method for the integration. No defaults for now, you have to specify a method (supported: <code>EulerJump</code>).</p> </li> <li> <code>gradient</code>         \u2013          <p>Algorithm used to compute the gradient. The default is method-dependent, refer to the documentation of the chosen method for more details.</p> </li> <li> <code>options</code>         \u2013          <p>Generic options (supported: <code>save_states</code>, <code>cartesian_batching</code>, <code>save_extra</code>, <code>nmaxclick</code>).</p> Detailed options API <pre><code>dq.Options(\n    save_states: bool = True,\n    cartesian_batching: bool = True,\n    save_extra: callable[[Array], PyTree] | None = None,\n    nmaxclick: int = 10_000,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>save_states</code> - If <code>True</code>, the state is saved at every time in     <code>tsave</code>, otherwise only the final state is returned.</li> <li><code>cartesian_batching</code> - If <code>True</code>, batched arguments are treated as     separated batch dimensions, otherwise the batching is performed over     a single shared batched dimension.</li> <li><code>save_extra</code> (function, optional) - A function with signature     <code>f(QArray) -&gt; PyTree</code> that takes a state as input and returns a     PyTree. This can be used to save additional arbitrary data     during the integration, accessible in <code>result.extra</code>.</li> <li><code>nmaxclick</code> - Maximum buffer size for <code>result.clicktimes</code>, should     be set higher than the expected maximum number of clicks.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>dq.JSMESolveResult</code> object holding the result of the jump SME integration. Use <code>result.states</code> to access the saved states, <code>result.expects</code> to access the saved expectation values and <code>result.clicktimes</code> to access the detector click times.</p> Detailed result API <pre><code>dq.JSMESolveResult\n</code></pre> <p>For the shape indications we define <code>ntrajs</code> as the number of trajectories (<code>ntrajs = len(keys)</code>) and <code>nLm</code> as the number of measured loss channels (those for which the measurement efficiency is not zero).</p> <p>Attributes:</p> <ul> <li><code>states</code> (qarray of shape (..., ntrajs, nsave, n, n)) - Saved     states with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if     <code>options.save_states=False</code>.</li> <li><code>final_state</code> (qarray of shape (..., ntrajs, n, n)) - Saved     final state.</li> <li><code>expects</code> (array of shape (..., ntrajs, len(exp_ops), ntsave)     or None) - Saved expectation values, if specified by <code>exp_ops</code>.</li> <li><code>clicktimes</code> (array of shape (..., ntrajs, nLm, nmaxclick)) -     Times at which the detectors clicked. Variable-length array padded     with <code>jnp.nan</code> up to <code>nmaxclick</code>.</li> <li><code>extra</code> (PyTree or None) - Extra data saved with <code>save_extra()</code>     if specified in <code>options</code>.</li> <li><code>keys</code> (PRNG key array of shape (ntrajs,)) - PRNG keys used to     sample the point processes.</li> <li><code>infos</code> (PyTree or None) - Method-dependent information on the     resolution.</li> <li><code>tsave</code> (array of shape (ntsave,)) - Times for which results     were saved.</li> <li><code>method</code> (Method) - Method used.</li> <li><code>gradient</code> (Gradient) - Gradient used.</li> <li><code>options</code> (Options) - Options used.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport jax\n\nn = 16\na = dq.destroy(n)\n\nH = a.dag() @ a\njump_ops = [a]\nthetas = [1.0]\netas = [0.5]\npsi0 = dq.coherent(n, 1.0)\ntsave = jnp.linspace(0, 1.0, 11)\nkeys = jax.random.split(jax.random.key(42), 100)\n\nmethod = dq.method.EulerJump(dt=1e-3)\nresult = dq.jsmesolve(H, jump_ops, thetas, etas, psi0, tsave, keys, method=method)\nprint(result)\n</code></pre> Output<pre><code>==== JSMESolveResult ====\nMethod     : EulerJump\nInfos      : 1000 steps | infos shape (100,)\nStates     : QArray complex64 (100, 11, 16, 16) | 2.1 Mb\nClicktimes : Array float32 (100, 1, 10000) | 3.8 Mb\n</code></pre>"},{"location":"python_api/integrators/jsmesolve.html#dynamiqs.integrators.jsmesolve--advanced-use-cases","title":"Advanced use-cases","text":""},{"location":"python_api/integrators/jsmesolve.html#dynamiqs.integrators.jsmesolve--defining-a-time-dependent-hamiltonian-or-jump-operator","title":"Defining a time-dependent Hamiltonian or jump operator","text":"<p>If the Hamiltonian or the jump operators depend on time, they can be converted to time-arrays using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p>"},{"location":"python_api/integrators/jsmesolve.html#dynamiqs.integrators.jsmesolve--running-multiple-simulations-concurrently","title":"Running multiple simulations concurrently","text":"<p>The Hamiltonian <code>H</code> and the initial density matrix <code>rho0</code> can be batched to solve multiple SMEs concurrently. All other arguments (including the PRNG key) are common to every batch. The resulting states, click times and expectation values are batched according to the leading dimensions of <code>H</code> and <code>rho0</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option.</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are </p><pre><code>... = ...H, ...rho0\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>rho0</code> has shape (4, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, ntrajs, ntsave, n, n).</p> <p>The results leading dimensions are </p><pre><code>... = ...H = ...rho0  # (once broadcasted)\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>rho0</code> has shape (3, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntrajs, ntsave, n, n).</p> <p>See the Batching simulations tutorial for more details.</p> Warning <p>Batching on <code>jump_ops</code>, <code>thetas</code> and <code>etas</code> is not yet supported, if this is needed don't hesitate to open an issue on GitHub.</p>"},{"location":"python_api/integrators/jssesolve.html","title":"jssesolve","text":""},{"location":"python_api/integrators/jssesolve.html#dynamiqs.integrators.jssesolve","title":"dq.jssesolve","text":"<pre><code>jssesolve(\n    H: QArrayLike | TimeQArray,\n    jump_ops: list[QArrayLike | TimeQArray],\n    psi0: QArrayLike,\n    tsave: ArrayLike,\n    keys: PRNGKeyArray,\n    *,\n    exp_ops: list[QArrayLike] | None = None,\n    method: Method | None = None,\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; JSSESolveResult\n</code></pre> <p>Solve the jump stochastic Schr\u00f6dinger equation (SSE).</p> <p>The jump SSE describes the evolution of a quantum system measured by an ideal jump detector (for example photodetection in quantum optics). This function computes the evolution of the state vector \\(\\ket{\\psi(t)}\\) at time \\(t\\), starting from an initial state \\(\\ket{\\psi_0}\\), according to the jump SSE (\\(\\hbar=1\\), time is implicit(1)) $$     \\dd\\!\\ket\\psi = \\left[         -iH \\dt         - \\frac12 \\sum_{k=1}^N \\left(             L_k^\\dag L_k - \\braket{L_k^\\dag L_k}         \\right) \\dt         + \\sum_{k=1}^N \\left(             \\frac{L_k}{\\sqrt{\\braket{L_k^\\dag L_k}}} - 1         \\right) \\dd N_k     \\right] \\!\\ket\\psi $$ where \\(H\\) is the system's Hamiltonian, \\(\\{L_k\\}\\) is a collection of jump operators, each continuously measured with perfect efficiency, and \\(\\dd N_k\\) are independent point processes with law $$     \\begin{split}         \\mathbb{P}[\\dd N_k = 0] &amp;= 1 - \\mathbb{P}[\\dd N_k = 1], \\\\         \\mathbb{P}[\\dd N_k = 1] &amp;= \\braket{L_k^\\dag L_k} \\dt.     \\end{split} $$</p> <ol> <li>With explicit time dependence:<ul> <li>\\(\\ket\\psi\\to\\ket{\\psi(t)}\\)</li> <li>\\(H\\to H(t)\\)</li> <li>\\(L_k\\to L_k(t)\\)</li> <li>\\(\\dd N_k\\to \\dd N_k(t)\\)</li> </ul> </li> </ol> <p>The continuous-time measurements are defined by the point processes \\(\\dd N_k\\). The solver returns the times at which the detector clicked, \\(I_k = \\{t \\in [t_0, t_\\text{end}[ \\,|\\, \\dd N_k(t)=1\\}\\).</p> Note <p>If you are only interested in simulating trajectories to solve the Lindblad master equation, consider using <code>dq.mesolve()</code> with the <code>dq.method.JumpMonteCarlo</code> method.</p> Note <p>This function is the Dynamiqs counterpart of QuTiP's <code>mcsolve()</code> function.</p> Warning <p>For now, <code>jssesolve()</code> only supports linearly spaced <code>tsave</code> with values that are exact multiples of the method fixed step size <code>dt</code> for the <code>EulerJump</code> method. Moreover, to JIT-compile code using <code>jssesolve()</code>, <code>tsave</code> must be passed as tuple.</p> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like or timeqarray of shape (...H, n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>jump_ops</code>             (list of qarray-like or timeqarray, each of shape (...Lk, n, n))         \u2013          <p>List of jump operators.</p> </li> <li> <code>psi0</code>             (qarray-like of shape (...psi0, n, 1))         \u2013          <p>Initial state.</p> </li> <li> <code>tsave</code>             (array-like of shape (ntsave,))         \u2013          <p>Times at which the states and expectation values are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>.</p> </li> <li> <code>keys</code>             (list of PRNG keys)         \u2013          <p>PRNG keys used to sample the point processes. The number of elements defines the number of sampled stochastic trajectories.</p> </li> <li> <code>exp_ops</code>             (list of array-like, each of shape (n, n))         \u2013          <p>List of operators for which the expectation value is computed.</p> </li> <li> <code>method</code>         \u2013          <p>Method for the integration. No defaults for now, you have to specify a method (supported: <code>Event</code>, <code>EulerJump</code>).</p> </li> <li> <code>gradient</code>         \u2013          <p>Algorithm used to compute the gradient. The default is method-dependent, refer to the documentation of the chosen method for more details.</p> </li> <li> <code>options</code>         \u2013          <p>Generic options (supported: <code>save_states</code>, <code>cartesian_batching</code>, <code>t0</code>, <code>save_extra</code>, <code>nmaxclick</code>).</p> Detailed options API <pre><code>dq.Options(\n    save_states: bool = True,\n    cartesian_batching: bool = True,\n    t0: ScalarLike | None = None,\n    save_extra: callable[[Array], PyTree] | None = None,\n    nmaxclick: int = 10_000,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>save_states</code> - If <code>True</code>, the state is saved at every time in     <code>tsave</code>, otherwise only the final state is returned.</li> <li><code>cartesian_batching</code> - If <code>True</code>, batched arguments are treated as     separated batch dimensions, otherwise the batching is performed over     a single shared batched dimension.</li> <li><code>t0</code> - Initial time. If <code>None</code>, defaults to the first time in     <code>tsave</code>.</li> <li><code>save_extra</code> (function, optional) - A function with signature     <code>f(QArray) -&gt; PyTree</code> that takes a state as input and returns a     PyTree. This can be used to save additional arbitrary data     during the integration, accessible in <code>result.extra</code>.</li> <li><code>nmaxclick</code> - Maximum buffer size for <code>result.clicktimes</code>, should     be set higher than the expected maximum number of clicks.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>dq.JSSESolveResult</code> object holding the result of the jump SSE integration. Use <code>result.states</code> to access the saved states, <code>result.expects</code> to access the saved expectation values and <code>result.clicktimes</code> to access the detector click times.</p> Detailed result API <pre><code>dq.JSSESolveResult\n</code></pre> <p>For the shape indications we define <code>ntrajs</code> as the number of trajectories (<code>ntrajs = len(keys)</code>).</p> <p>Attributes:</p> <ul> <li><code>states</code> (qarray of shape (..., ntrajs, nsave, n, 1)) - Saved     states with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if     <code>options.save_states=False</code>.</li> <li><code>final_state</code> (qarray of shape (..., ntrajs, n, 1)) - Saved     final state.</li> <li><code>expects</code> (array of shape (..., ntrajs, len(exp_ops), ntsave) or     None) - Saved expectation values, if specified by <code>exp_ops</code>.</li> <li><code>clicktimes</code> (array of shape (..., ntrajs, len(jump_ops),     nmaxclick)) - Times at which the detectors clicked. Variable-length     array padded with <code>jnp.nan</code> up to <code>nmaxclick</code>.</li> <li><code>nclicks</code> (array of shape (..., ntrajs, len(jump_ops)) - Number     of clicks for each jump operator.</li> <li><code>extra</code> (PyTree or None) - Extra data saved with <code>save_extra()</code>     if specified in <code>options</code>.</li> <li><code>keys</code> (PRNG key array of shape (ntrajs,)) - PRNG keys used to     sample the point processes.</li> <li><code>infos</code> (PyTree or None) - Method-dependent information on the     resolution.</li> <li><code>tsave</code> (array of shape (ntsave,)) - Times for which results     were saved.</li> <li><code>method</code> (Method) - Method used.</li> <li><code>gradient</code> (Gradient) - Gradient used.</li> <li><code>options</code> (Options) - Options used.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport jax\n\nn = 16\na = dq.destroy(n)\n\nH = a.dag() @ a\njump_ops = [a]\npsi0 = dq.coherent(n, 1.0)\ntsave = jnp.linspace(0, 1.0, 11)\nkeys = jax.random.split(jax.random.key(42), 100)\n\nmethod = dq.method.EulerJump(dt=1e-3)\nresult = dq.jssesolve(H, jump_ops, psi0, tsave, keys, method=method)\nprint(result)\n</code></pre> Output<pre><code>==== JSSESolveResult ====\nMethod     : EulerJump\nInfos      : 1000 steps | infos shape (100,)\nStates     : QArray complex64 (100, 11, 16, 1) | 137.5 Kb\nClicktimes : Array float32 (100, 1, 10000) | 3.8 Mb\n</code></pre>"},{"location":"python_api/integrators/jssesolve.html#dynamiqs.integrators.jssesolve--advanced-use-cases","title":"Advanced use-cases","text":""},{"location":"python_api/integrators/jssesolve.html#dynamiqs.integrators.jssesolve--defining-a-time-dependent-hamiltonian-or-jump-operator","title":"Defining a time-dependent Hamiltonian or jump operator","text":"<p>If the Hamiltonian or the jump operators depend on time, they can be converted to time-arrays using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p>"},{"location":"python_api/integrators/jssesolve.html#dynamiqs.integrators.jssesolve--running-multiple-simulations-concurrently","title":"Running multiple simulations concurrently","text":"<p>The Hamiltonian <code>H</code>, the jump operators <code>jump_ops</code> and the initial state <code>psi0</code> can be batched to solve multiple SSEs concurrently. All other arguments (including the PRNG key) are common to every batch. The resulting states, measurements and expectation values are batched according to the leading dimensions of <code>H</code>, <code>jump_ops</code> and <code>psi0</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option.</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are </p><pre><code>... = ...H, ...L0, ...L1, (...), ...psi0\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(4, 5, n, n), (6, n, n)],</li> <li><code>psi0</code> has shape (7, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, 5, 6, 7, ntrajs, ntsave, n, 1).</p> <p>The results leading dimensions are </p><pre><code>... = ...H = ...L0 = ...L1 = (...) = ...psi0  # (once broadcasted)\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(3, n, n), (2, 1, n, n)],</li> <li><code>psi0</code> has shape (3, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntrajs, ntsave, n, 1).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/integrators/mepropagator.html","title":"mepropagator","text":""},{"location":"python_api/integrators/mepropagator.html#dynamiqs.integrators.mepropagator","title":"dq.mepropagator","text":"<pre><code>mepropagator(\n    H: QArrayLike | TimeQArray,\n    jump_ops: list[QArrayLike | TimeQArray],\n    tsave: ArrayLike,\n    *,\n    method: Method | None = None,\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; MEPropagatorResult\n</code></pre> <p>Compute the propagator of the Lindblad master equation.</p> <p>This function computes the propagator \\(\\mathcal{U}(t)\\) at time \\(t\\) of the Lindblad master equation (with \\(\\hbar=1\\)) $$     \\mathcal{U}(t) = \\mathscr{T}\\exp\\left(\\int_0^t\\mathcal{L}(t')\\dt'\\right), $$ where \\(\\mathscr{T}\\) is the time-ordering symbol and \\(\\mathcal{L}\\) is the system's Liouvillian. The formula simplifies to \\(\\mathcal{U}(t)=e^{t\\mathcal{L}}\\) if the Liouvillian does not depend on time.</p> <p>If the Liouvillian is constant or piecewise constant, the propagator is computed by directly exponentiating the Liouvillian. Otherwise, the propagator is computed by solving the Lindblad master equation with an ODE method.</p> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like or timeqarray of shape (...H, n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>jump_ops</code>             (list of qarray-like or timeqarray, each of shape (...Lk, n, n))         \u2013          <p>List of jump operators.</p> </li> <li> <code>tsave</code>             (array-like of shape (ntsave,))         \u2013          <p>Times at which the propagators are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>, or from <code>t0</code> to <code>tsave[-1]</code> if <code>t0</code> is specified in <code>options</code>.</p> </li> <li> <code>method</code>         \u2013          <p>Method for the integration. Defaults to <code>None</code> which redirects to <code>dq.method.Expm</code> (explicit matrix exponentiation) or <code>dq.method.Tsit5</code> depending on the Liouvillian type (supported: <code>Expm</code>, <code>Tsit5</code>, <code>Dopri5</code>, <code>Dopri8</code>, <code>Kvaerno3</code>, <code>Kvaerno5</code>, <code>Euler</code>).</p> </li> <li> <code>gradient</code>         \u2013          <p>Algorithm used to compute the gradient. The default is method-dependent, refer to the documentation of the chosen method for more details.</p> </li> <li> <code>options</code>         \u2013          <p>Generic options (supported: <code>save_propagators</code>, <code>cartesian_batching</code>, <code>progress_meter</code>, <code>t0</code>, <code>save_extra</code>).</p> Detailed options API <pre><code>dq.Options(\n    save_propagators: bool = True,\n    cartesian_batching: bool = True,\n    progress_meter: AbstractProgressMeter | bool | None = None,\n    t0: ScalarLike | None = None,\n    save_extra: callable[[Array], PyTree] | None = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>save_propagators</code> - If <code>True</code>, the propagator is saved at every     time in <code>tsave</code>, otherwise only the final propagator is returned.</li> <li><code>cartesian_batching</code> - If <code>True</code>, batched arguments are treated as     separated batch dimensions, otherwise the batching is performed over     a single shared batched dimension.</li> <li><code>progress_meter</code> - Progress meter indicating how far the solve has     progressed. Defaults to <code>None</code> which uses the global default     progress meter (see     <code>dq.set_progress_meter()</code>). Set to     <code>True</code> for a tqdm progress meter,     and <code>False</code> for no output. See other options in     dynamiqs/progress_meter.py.     If gradients are computed, the progress meter only displays during     the forward pass.</li> <li><code>t0</code> - Initial time. If <code>None</code>, defaults to the first time in     <code>tsave</code>.</li> <li><code>save_extra</code> (function, optional) - A function with signature     <code>f(QArray) -&gt; PyTree</code> that takes a propagator as input and returns     a PyTree. This can be used to save additional arbitrary data     during the integration, accessible in <code>result.extra</code>.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>dq.MEPropagatorResult</code> object holding the result of the propagator computation. Use <code>result.propagators</code> to access the saved propagators.</p> Detailed result API <pre><code>dq.MEPropagatorResult\n</code></pre> <p>Attributes:</p> <ul> <li><code>propagators</code> (qarray of shape (..., nsave, n^2, n^2)) - Saved     propagators with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if     <code>options.save_propagators=False</code>.</li> <li><code>final_propagator</code> (qarray of shape (..., n^2, n^2)) - Saved     final propagator.</li> <li><code>extra</code> (PyTree or None) - Extra data saved with <code>save_extra()</code>     if specified in <code>options</code>.</li> <li><code>infos</code> (PyTree or None) - Method-dependent information on the     resolution.</li> <li><code>tsave</code> (array of shape (ntsave,)) - Times for which results     were saved.</li> <li><code>method</code> (Method) - Method used.</li> <li><code>gradient</code> (Gradient) - Gradient used.</li> <li><code>options</code> (Options) - Options used.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\n\nn = 16\na = dq.destroy(n)\n\nH = a.dag() @ a\njump_ops = [a]\ntsave = jnp.linspace(0, 1.0, 11)\n\nresult = dq.mepropagator(H, jump_ops, tsave)\nprint(result)\n</code></pre> Output<pre><code>==== MEPropagatorResult ====\nMethod      : Expm\nInfos       : 10 steps\nPropagators : QArray complex64 (11, 256, 256) | 5.5 Mb\n</code></pre>"},{"location":"python_api/integrators/mepropagator.html#dynamiqs.integrators.mepropagator--advanced-use-cases","title":"Advanced use-cases","text":""},{"location":"python_api/integrators/mepropagator.html#dynamiqs.integrators.mepropagator--defining-a-time-dependent-hamiltonian-or-jump-operator","title":"Defining a time-dependent Hamiltonian or jump operator","text":"<p>If the Hamiltonian or the jump operators depend on time, they can be converted to timeqarrays using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p>"},{"location":"python_api/integrators/mepropagator.html#dynamiqs.integrators.mepropagator--running-multiple-simulations-concurrently","title":"Running multiple simulations concurrently","text":"<p>The Hamiltonian <code>H</code> and the jump operators <code>jump_ops</code> can be batched to compute multiple propagators concurrently. All other arguments are common to every batch. The resulting propagators are batched according to the leading dimensions of <code>H</code> and <code>jump_ops</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option.</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are </p><pre><code>... = ...H, ...L0, ...L1, (...)\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(4, 5, n, n), (6, n, n)],</li> </ul> <p>then <code>result.propagators</code> has shape (2, 3, 4, 5, 6, ntsave, n^2, n^2).</p> <p>The results leading dimensions are </p><pre><code>... = ...H = ...L0 = ...L1 = (...)  # (once broadcasted)\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(3, n, n), (2, 1, n, n)],</li> </ul> <p>then <code>result.propagators</code> has shape (2, 3, ntsave, n^2, n^2).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/integrators/mesolve.html","title":"mesolve","text":""},{"location":"python_api/integrators/mesolve.html#dynamiqs.integrators.mesolve","title":"dq.mesolve","text":"<pre><code>mesolve(\n    H: QArrayLike | TimeQArray,\n    jump_ops: list[QArrayLike | TimeQArray],\n    rho0: QArrayLike,\n    tsave: ArrayLike,\n    *,\n    exp_ops: list[QArrayLike] | None = None,\n    method: Method = Tsit5(),\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; MESolveResult\n</code></pre> <p>Solve the Lindblad master equation.</p> <p>This function computes the evolution of the density matrix \\(\\rho(t)\\) at time \\(t\\), starting from an initial state \\(\\rho_0\\), according to the Lindblad master equation (with \\(\\hbar=1\\) and where time is implicit(1)) $$     \\frac{\\dd\\rho}{\\dt} = -i[H, \\rho]     + \\sum_{k=1}^N \\left(         L_k \\rho L_k^\\dag         - \\frac{1}{2} L_k^\\dag L_k \\rho         - \\frac{1}{2} \\rho L_k^\\dag L_k     \\right), $$ where \\(H\\) is the system's Hamiltonian and \\(\\{L_k\\}\\) is a collection of jump operators.</p> <ol> <li>With explicit time dependence:<ul> <li>\\(\\rho\\to\\rho(t)\\)</li> <li>\\(H\\to H(t)\\)</li> <li>\\(L_k\\to L_k(t)\\)</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like or timeqarray of shape (...H, n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>jump_ops</code>             (list of qarray-like or timeqarray, each of shape (...Lk, n, n))         \u2013          <p>List of jump operators.</p> </li> <li> <code>rho0</code>             (qarray-like of shape (...rho0, n, 1) or (...rho0, n, n))         \u2013          <p>Initial state.</p> </li> <li> <code>tsave</code>             (array-like of shape (ntsave,))         \u2013          <p>Times at which the states and expectation values are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>, or from <code>t0</code> to <code>tsave[-1]</code> if <code>t0</code> is specified in <code>options</code>.</p> </li> <li> <code>exp_ops</code>             (list of qarray-like, each of shape (n, n))         \u2013          <p>List of operators for which the expectation value is computed.</p> </li> <li> <code>method</code>         \u2013          <p>Method for the integration. Defaults to <code>dq.method.Tsit5</code> (supported: <code>Tsit5</code>, <code>Dopri5</code>, <code>Dopri8</code>, <code>Kvaerno3</code>, <code>Kvaerno5</code>, <code>Euler</code>, <code>Rouchon1</code>, <code>Rouchon2</code>, <code>Rouchon3</code>, <code>Expm</code>, <code>JumpMonteCarlo</code>, <code>DiffusiveMonteCarlo</code>).</p> </li> <li> <code>gradient</code>         \u2013          <p>Algorithm used to compute the gradient. The default is method-dependent, refer to the documentation of the chosen method for more details.</p> </li> <li> <code>options</code>         \u2013          <p>Generic options (supported: <code>save_states</code>, <code>cartesian_batching</code>, <code>progress_meter</code>, <code>t0</code>, <code>save_extra</code>).</p> Detailed options API <pre><code>dq.Options(\n    save_states: bool = True,\n    cartesian_batching: bool = True,\n    progress_meter: AbstractProgressMeter | bool | None = None,\n    t0: ScalarLike | None = None,\n    save_extra: callable[[Array], PyTree] | None = None,\n    vectorized: bool = False,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>save_states</code> - If <code>True</code>, the state is saved at every time in     <code>tsave</code>, otherwise only the final state is returned.</li> <li><code>cartesian_batching</code> - If <code>True</code>, batched arguments are treated as     separated batch dimensions, otherwise the batching is performed over     a single shared batched dimension.</li> <li><code>progress_meter</code> - Progress meter indicating how far the solve has     progressed. Defaults to <code>None</code> which uses the global default     progress meter (see     <code>dq.set_progress_meter()</code>). Set to     <code>True</code> for a tqdm progress meter,     and <code>False</code> for no output. See other options in     dynamiqs/progress_meter.py.     If gradients are computed, the progress meter only displays during     the forward pass.</li> <li><code>t0</code> - Initial time. If <code>None</code>, defaults to the first time in     <code>tsave</code>.</li> <li><code>save_extra</code> (function, optional) - A function with signature     <code>f(QArray) -&gt; PyTree</code> that takes a state as input and returns a     PyTree. This can be used to save additional arbitrary data     during the integration, accessible in <code>result.extra</code>.</li> <li><code>vectorized</code> - If <code>True</code>, the master equation is solved by     vectorizing the density matrix and Liouvillian. This is usually     more efficient for small Hilbert spaces but less efficient for     large Hilbert spaces. This option is only supported for     Diffrax-based ODE methods.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>dq.MESolveResult</code> object holding the result of the Lindblad master equation integration. Use <code>result.states</code> to access the saved states and <code>result.expects</code> to access the saved expectation values.</p> Detailed result API <pre><code>dq.MESolveResult\n</code></pre> <p>Attributes:</p> <ul> <li><code>states</code> (qarray of shape (..., nsave, n, n)) - Saved states     with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if     <code>options.save_states=False</code>.</li> <li><code>final_state</code> (qarray of shape (..., n, n)) - Saved final state.</li> <li><code>expects</code> (array of shape (..., len(exp_ops), ntsave) or None) -     Saved expectation values, if specified by <code>exp_ops</code>.</li> <li><code>extra</code> (PyTree or None) - Extra data saved with <code>save_extra()</code>     if specified in <code>options</code>.</li> <li><code>infos</code> (PyTree or None) - Method-dependent information on the     resolution.</li> <li><code>tsave</code> (array of shape (ntsave,)) - Times for which results     were saved.</li> <li><code>method</code> (Method) - Method used.</li> <li><code>gradient</code> (Gradient) - Gradient used.</li> <li><code>options</code> (Options) - Options used.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\n\nn = 16\na = dq.destroy(n)\n\nH = a.dag() @ a\njump_ops = [a]\npsi0 = dq.coherent(n, 1.0)\ntsave = jnp.linspace(0, 1.0, 11)\n\nresult = dq.mesolve(H, jump_ops, psi0, tsave)\nprint(result)\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 1.13ms \u25c6 remaining 0.00ms\n==== MESolveResult ====\nMethod : Tsit5\nInfos  : 9 steps (9 accepted, 0 rejected)\nStates : QArray complex64 (11, 16, 16) | 22.0 Kb\n</code></pre>"},{"location":"python_api/integrators/mesolve.html#dynamiqs.integrators.mesolve--advanced-use-cases","title":"Advanced use-cases","text":""},{"location":"python_api/integrators/mesolve.html#dynamiqs.integrators.mesolve--defining-a-time-dependent-hamiltonian-or-jump-operator","title":"Defining a time-dependent Hamiltonian or jump operator","text":"<p>If the Hamiltonian or the jump operators depend on time, they can be converted to timeqarrays using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p>"},{"location":"python_api/integrators/mesolve.html#dynamiqs.integrators.mesolve--running-multiple-simulations-concurrently","title":"Running multiple simulations concurrently","text":"<p>The Hamiltonian <code>H</code>, the jump operators <code>jump_ops</code> and the initial density matrix <code>rho0</code> can be batched to solve multiple master equations concurrently. All other arguments are common to every batch. The resulting states and expectation values are batched according to the leading dimensions of <code>H</code>, <code>jump_ops</code> and  <code>rho0</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option.</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are </p><pre><code>... = ...H, ...L0, ...L1, (...), ...rho0\n</code></pre><p></p> <p>For example if:</p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(4, 5, n, n), (6, n, n)],</li> <li><code>rho0</code> has shape (7, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, 5, 6, 7, ntsave, n, n).</p> <p>The results leading dimensions are </p><pre><code>... = ...H = ...L0 = ...L1 = (...) = ...rho0  # (once broadcasted)\n</code></pre><p></p> <p>For example if:</p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>jump_ops = [L0, L1]</code> has shape [(3, n, n), (2, 1, n, n)],</li> <li><code>rho0</code> has shape (3, n, n),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntsave, n, n).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/integrators/sepropagator.html","title":"sepropagator","text":""},{"location":"python_api/integrators/sepropagator.html#dynamiqs.integrators.sepropagator","title":"dq.sepropagator","text":"<pre><code>sepropagator(\n    H: QArrayLike | TimeQArray,\n    tsave: ArrayLike,\n    *,\n    method: Method | None = None,\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; SEPropagatorResult\n</code></pre> <p>Compute the propagator of the Schr\u00f6dinger equation.</p> <p>This function computes the propagator \\(U(t)\\) at time \\(t\\) of the Schr\u00f6dinger equation (with \\(\\hbar=1\\)) $$     U(t) = \\mathscr{T}\\exp\\left(-i\\int_0^tH(t')\\dt'\\right), $$ where \\(\\mathscr{T}\\) is the time-ordering symbol and \\(H\\) is the system's Hamiltonian. The formula simplifies to \\(U(t)=e^{-iHt}\\) if the Hamiltonian does not depend on time.</p> <p>If the Hamiltonian is constant or piecewise constant, the propagator is computed by directly exponentiating the Hamiltonian. Otherwise, the propagator is computed by solving the Schr\u00f6dinger equation with an ODE method.</p> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like or timeqarray of shape (...H, n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>tsave</code>             (array-like of shape (ntsave,))         \u2013          <p>Times at which the propagators are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>, or from <code>t0</code> to <code>tsave[-1]</code> if <code>t0</code> is specified in <code>options</code>.</p> </li> <li> <code>method</code>         \u2013          <p>Method for the integration. Defaults to <code>None</code> which redirects to <code>dq.method.Expm</code> (explicit matrix exponentiation) or <code>dq.method.Tsit5</code> depending on the Hamiltonian type (supported: <code>Expm</code>, <code>Tsit5</code>, <code>Dopri5</code>, <code>Dopri8</code>, <code>Kvaerno3</code>, <code>Kvaerno5</code>, <code>Euler</code>).</p> </li> <li> <code>gradient</code>         \u2013          <p>Algorithm used to compute the gradient. The default is method-dependent, refer to the documentation of the chosen method for more details.</p> </li> <li> <code>options</code>         \u2013          <p>Generic options (supported: <code>save_propagators</code>, <code>progress_meter</code>, <code>t0</code>, <code>save_extra</code>).</p> Detailed options API <pre><code>dq.Options(\n    save_propagators: bool = True,\n    progress_meter: AbstractProgressMeter | bool | None = None,\n    t0: ScalarLike | None = None,\n    save_extra: callable[[Array], PyTree] | None = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>save_propagators</code> - If <code>True</code>, the propagator is saved at every     time in <code>tsave</code>, otherwise only the final propagator is returned.</li> <li><code>progress_meter</code> - Progress meter indicating how far the solve has     progressed. Defaults to <code>None</code> which uses the global default     progress meter (see     <code>dq.set_progress_meter()</code>). Set to     <code>True</code> for a tqdm progress meter,     and <code>False</code> for no output. See other options in     dynamiqs/progress_meter.py.     If gradients are computed, the progress meter only displays during     the forward pass.</li> <li><code>t0</code> - Initial time. If <code>None</code>, defaults to the first time in     <code>tsave</code>.</li> <li><code>save_extra</code> (function, optional) - A function with signature     <code>f(QArray) -&gt; PyTree</code> that takes a propagator as input and returns     a PyTree. This can be used to save additional arbitrary data     during the integration, accessible in <code>result.extra</code>.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>dq.SEPropagatorResult</code> object holding the result of the propagator computation. Use <code>result.propagators</code> to access the saved propagators.</p> Detailed result API <pre><code>dq.SEPropagatorResult\n</code></pre> <p>Attributes:</p> <ul> <li><code>propagators</code> (qarray of shape (..., nsave, n, n)) - Saved     propagators with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if     <code>options.save_propagators=False</code>.</li> <li><code>final_propagator</code> (qarray of shape (..., n, n)) - Saved final     propagator.</li> <li><code>extra</code> (PyTree or None) - Extra data saved with <code>save_extra()</code>     if specified in <code>options</code>.</li> <li><code>infos</code> (PyTree or None) - Method-dependent information on the     resolution.</li> <li><code>tsave</code> (array of shape (ntsave,)) - Times for which results     were saved.</li> <li><code>method</code> (Method) - Method used.</li> <li><code>gradient</code> (Gradient) - Gradient used.</li> <li><code>options</code> (Options) - Options used.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\n\nn = 16\na = dq.destroy(n)\n\nH = a.dag() @ a\ntsave = jnp.linspace(0, 1.0, 11)\n\nresult = dq.sepropagator(H, tsave)\nprint(result)\n</code></pre> Output<pre><code>==== SEPropagatorResult ====\nMethod      : Expm\nInfos       : 10 steps\nPropagators : QArray complex64 (11, 16, 16) | 22.0 Kb\n</code></pre>"},{"location":"python_api/integrators/sepropagator.html#dynamiqs.integrators.sepropagator--advanced-use-cases","title":"Advanced use-cases","text":""},{"location":"python_api/integrators/sepropagator.html#dynamiqs.integrators.sepropagator--defining-a-time-dependent-hamiltonian","title":"Defining a time-dependent Hamiltonian","text":"<p>If the Hamiltonian depends on time, it can be converted to a timeqarray using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p>"},{"location":"python_api/integrators/sepropagator.html#dynamiqs.integrators.sepropagator--running-multiple-simulations-concurrently","title":"Running multiple simulations concurrently","text":"<p>The Hamiltonian <code>H</code> can be batched to compute multiple propagators concurrently. All other arguments are common to every batch. The resulting propagators are batched according to the leading dimensions of <code>H</code>. For example if <code>H</code> has shape (2, 3, n, n), then <code>result.propagators</code> has shape (2, 3, ntsave, n, n).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/integrators/sesolve.html","title":"sesolve","text":""},{"location":"python_api/integrators/sesolve.html#dynamiqs.integrators.sesolve","title":"dq.sesolve","text":"<pre><code>sesolve(\n    H: QArrayLike | TimeQArray,\n    psi0: QArrayLike,\n    tsave: ArrayLike,\n    *,\n    exp_ops: list[QArrayLike] | None = None,\n    method: Method = Tsit5(),\n    gradient: Gradient | None = None,\n    options: Options = Options()\n) -&gt; SESolveResult\n</code></pre> <p>Solve the Schr\u00f6dinger equation.</p> <p>This function computes the evolution of the state vector \\(\\ket{\\psi(t)}\\) at time \\(t\\), starting from an initial state \\(\\ket{\\psi_0}\\), according to the Schr\u00f6dinger equation (with \\(\\hbar=1\\) and where time is implicit(1)) $$     \\frac{\\dd\\ket{\\psi}}{\\dt} = -i H \\ket{\\psi}, $$ where \\(H\\) is the system's Hamiltonian.</p> <ol> <li>With explicit time dependence:<ul> <li>\\(\\ket\\psi\\to\\ket{\\psi(t)}\\)</li> <li>\\(H\\to H(t)\\)</li> </ul> </li> </ol> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like or timeqarray of shape (...H, n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>psi0</code>             (qarray-like of shape (...psi0, n, 1))         \u2013          <p>Initial state.</p> </li> <li> <code>tsave</code>             (array-like of shape (ntsave,))         \u2013          <p>Times at which the states and expectation values are saved. The equation is solved from <code>tsave[0]</code> to <code>tsave[-1]</code>, or from <code>t0</code> to <code>tsave[-1]</code> if <code>t0</code> is specified in <code>options</code>.</p> </li> <li> <code>exp_ops</code>             (list of qarray-like, each of shape (n, n))         \u2013          <p>List of operators for which the expectation value is computed.</p> </li> <li> <code>method</code>         \u2013          <p>Method for the integration. Defaults to <code>dq.method.Tsit5</code> (supported: <code>Tsit5</code>, <code>Dopri5</code>, <code>Dopri8</code>, <code>Kvaerno3</code>, <code>Kvaerno5</code>, <code>Euler</code>, <code>Expm</code>).</p> </li> <li> <code>gradient</code>         \u2013          <p>Algorithm used to compute the gradient. The default is method-dependent, refer to the documentation of the chosen method for more details.</p> </li> <li> <code>options</code>         \u2013          <p>Generic options (supported: <code>save_states</code>, <code>cartesian_batching</code>, <code>progress_meter</code>, <code>t0</code>, <code>save_extra</code>).</p> Detailed options API <pre><code>dq.Options(\n    save_states: bool = True,\n    cartesian_batching: bool = True,\n    progress_meter: AbstractProgressMeter | bool | None = None,\n    t0: ScalarLike | None = None,\n    save_extra: callable[[Array], PyTree] | None = None,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>save_states</code> - If <code>True</code>, the state is saved at every time in     <code>tsave</code>, otherwise only the final state is returned.</li> <li><code>cartesian_batching</code> - If <code>True</code>, batched arguments are treated as     separated batch dimensions, otherwise the batching is performed over     a single shared batched dimension.</li> <li><code>progress_meter</code> - Progress meter indicating how far the solve has     progressed. Defaults to <code>None</code> which uses the global default     progress meter (see     <code>dq.set_progress_meter()</code>). Set to     <code>True</code> for a tqdm progress meter,     and <code>False</code> for no output. See other options in     dynamiqs/progress_meter.py.     If gradients are computed, the progress meter only displays during     the forward pass.</li> <li><code>t0</code> - Initial time. If <code>None</code>, defaults to the first time in     <code>tsave</code>.</li> <li><code>save_extra</code> (function, optional) - A function with signature     <code>f(QArray) -&gt; PyTree</code> that takes a state as input and returns a     PyTree. This can be used to save additional arbitrary data     during the integration, accessible in <code>result.extra</code>.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>dq.SESolveResult</code> object holding the result of the Schr\u00f6dinger equation integration.  Use <code>result.states</code> to access the saved states and <code>result.expects</code> to access the saved expectation values.</p> Detailed result API <pre><code>dq.SESolveResult\n</code></pre> <p>Attributes:</p> <ul> <li><code>states</code> (qarray of shape (..., nsave, n, 1)) - Saved states     with <code>nsave = ntsave</code>, or <code>nsave = 1</code> if     <code>options.save_states=False</code>.</li> <li><code>final_state</code> (qarray of shape (..., n, 1)) - Saved final state.</li> <li><code>expects</code> (array of shape (..., len(exp_ops), ntsave) or None) -     Saved expectation values, if specified by <code>exp_ops</code>.</li> <li><code>extra</code> (PyTree or None) - Extra data saved with <code>save_extra()</code>     if specified in <code>options</code>.</li> <li><code>infos</code> (PyTree or None) - Method-dependent information on the     resolution.</li> <li><code>tsave</code> (array of shape (ntsave,)) - Times for which results     were saved.</li> <li><code>method</code> (Method) - Method used.</li> <li><code>gradient</code> (Gradient) - Gradient used.</li> <li><code>options</code> (Options) - Options used.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\n\nn = 16\na = dq.destroy(n)\n\nH = a.dag() @ a\npsi0 = dq.coherent(n, 1.0)\ntsave = jnp.linspace(0, 1.0, 11)\n\nresult = dq.sesolve(H, psi0, tsave)\nprint(result)\n</code></pre> Output<pre><code>|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100.0% \u25c6 elapsed 1.50ms \u25c6 remaining 0.00ms\n==== SESolveResult ====\nMethod : Tsit5\nInfos  : 11 steps (11 accepted, 0 rejected)\nStates : QArray complex64 (11, 16, 1) | 1.4 Kb\n</code></pre>"},{"location":"python_api/integrators/sesolve.html#dynamiqs.integrators.sesolve--advanced-use-cases","title":"Advanced use-cases","text":""},{"location":"python_api/integrators/sesolve.html#dynamiqs.integrators.sesolve--defining-a-time-dependent-hamiltonian","title":"Defining a time-dependent Hamiltonian","text":"<p>If the Hamiltonian depends on time, it can be converted to a timeqarray using <code>dq.pwc()</code>, <code>dq.modulated()</code>, or <code>dq.timecallable()</code>. See the Time-dependent operators tutorial for more details.</p>"},{"location":"python_api/integrators/sesolve.html#dynamiqs.integrators.sesolve--running-multiple-simulations-concurrently","title":"Running multiple simulations concurrently","text":"<p>Both the Hamiltonian <code>H</code> and the initial state <code>psi0</code> can be batched to solve multiple Schr\u00f6dinger equations concurrently. All other arguments are common to every batch. The resulting states and expectation values are batched according to the leading dimensions of <code>H</code> and <code>psi0</code>. The behaviour depends on the value of the <code>cartesian_batching</code> option.</p> If <code>cartesian_batching = True</code> (default value)If <code>cartesian_batching = False</code> <p>The results leading dimensions are </p><pre><code>... = ...H, ...psi0\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>psi0</code> has shape (4, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, 4, ntsave, n, 1).</p> <p>The results leading dimensions are </p><pre><code>... = ...H = ...psi0  # (once broadcasted)\n</code></pre> For example if:<p></p> <ul> <li><code>H</code> has shape (2, 3, n, n),</li> <li><code>psi0</code> has shape (3, n, 1),</li> </ul> <p>then <code>result.states</code> has shape (2, 3, ntsave, n, 1).</p> <p>See the Batching simulations tutorial for more details.</p>"},{"location":"python_api/method/DiffusiveMonteCarlo.html","title":"DiffusiveMonteCarlo","text":""},{"location":"python_api/method/DiffusiveMonteCarlo.html#dynamiqs.method.DiffusiveMonteCarlo","title":"dq.method.DiffusiveMonteCarlo","text":"<pre><code>DiffusiveMonteCarlo(keys: PRNGKeyArray, dsse_method: Method)\n</code></pre> <p>Diffusive Monte Carlo method for the Lindblad master equation.</p> <p>This method calls <code>dq.dssesolve()</code> to compute stochastic trajectories of the unit-efficiency diffusive unraveling of the Lindblad master equation (ME). These trajectories are then averaged to obtain an approximation of the ME solution.</p> Note <p>This method is solely a wrapper around <code>dq.dssesolve()</code>. If you are looking for direct access to individual trajectories, use <code>dq.dssesolve()</code> instead.</p> <p>Parameters:</p> <ul> <li> <code>keys</code>             (list of PRNG keys)         \u2013          <p>PRNG keys used for the diffusive SSE solver. See <code>dq.dssesolve()</code> for more details.</p> </li> <li> <code>dsse_method</code>         \u2013          <p>Method used for the diffusive SSE solver. See <code>dq.dssesolve()</code> for more details.</p> </li> </ul> Supported gradients <p>See the documentation of the chosen <code>dsse_method</code>.</p>"},{"location":"python_api/method/Dopri5.html","title":"Dopri5","text":""},{"location":"python_api/method/Dopri5.html#dynamiqs.method.Dopri5","title":"dq.method.Dopri5","text":"<pre><code>Dopri5(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Dormand-Prince method of order 5 (adaptive step size ODE method).</p> <p>This method is implemented by the Diffrax library, see <code>diffrax.Dopri5</code>.</p> <p>Parameters:</p> <ul> <li> <code>rtol</code>         \u2013          <p>Relative tolerance.</p> </li> <li> <code>atol</code>         \u2013          <p>Absolute tolerance.</p> </li> <li> <code>safety_factor</code>         \u2013          <p>Safety factor for adaptive step sizing.</p> </li> <li> <code>min_factor</code>         \u2013          <p>Minimum factor for adaptive step sizing.</p> </li> <li> <code>max_factor</code>         \u2013          <p>Maximum factor for adaptive step sizing.</p> </li> <li> <code>max_steps</code>         \u2013          <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code>, <code>dq.gradient.BackwardCheckpointed</code> (default) and <code>dq.gradient.Forward</code>.</p>"},{"location":"python_api/method/Dopri8.html","title":"Dopri8","text":""},{"location":"python_api/method/Dopri8.html#dynamiqs.method.Dopri8","title":"dq.method.Dopri8","text":"<pre><code>Dopri8(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Dormand-Prince method of order 8 (adaptive step size ODE method).</p> <p>This method is implemented by the Diffrax library, see <code>diffrax.Dopri8</code>.</p> <p>Parameters:</p> <ul> <li> <code>rtol</code>         \u2013          <p>Relative tolerance.</p> </li> <li> <code>atol</code>         \u2013          <p>Absolute tolerance.</p> </li> <li> <code>safety_factor</code>         \u2013          <p>Safety factor for adaptive step sizing.</p> </li> <li> <code>min_factor</code>         \u2013          <p>Minimum factor for adaptive step sizing.</p> </li> <li> <code>max_factor</code>         \u2013          <p>Maximum factor for adaptive step sizing.</p> </li> <li> <code>max_steps</code>         \u2013          <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code>, <code>dq.gradient.BackwardCheckpointed</code> (default) and <code>dq.gradient.Forward</code>.</p>"},{"location":"python_api/method/Euler.html","title":"Euler","text":""},{"location":"python_api/method/Euler.html#dynamiqs.method.Euler","title":"dq.method.Euler","text":"<pre><code>Euler(dt: float)\n</code></pre> <p>Euler method (fixed step size ODE method).</p> <p>This method is implemented by the Diffrax library, see <code>diffrax.Euler</code>.</p> Warning <p>This method is not recommended for general use.</p> <p>Parameters:</p> <ul> <li> <code>dt</code>         \u2013          <p>Fixed time step.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code>, <code>dq.gradient.BackwardCheckpointed</code> (default) and <code>dq.gradient.Forward</code>.</p>"},{"location":"python_api/method/EulerJump.html","title":"EulerJump","text":""},{"location":"python_api/method/EulerJump.html#dynamiqs.method.EulerJump","title":"dq.method.EulerJump","text":"<pre><code>EulerJump(dt: float)\n</code></pre> <p>Euler-Jump method (fixed step size SDE method).</p> <p>Parameters:</p> <ul> <li> <code>dt</code>         \u2013          <p>Fixed time step.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code> (default).</p>"},{"location":"python_api/method/EulerMaruyama.html","title":"EulerMaruyama","text":""},{"location":"python_api/method/EulerMaruyama.html#dynamiqs.method.EulerMaruyama","title":"dq.method.EulerMaruyama","text":"<pre><code>EulerMaruyama(dt: float)\n</code></pre> <p>Euler-Maruyama method (fixed step size SDE method).</p> <p>For a fixed step size \\(\\dt\\), it has weak order of convergence \\(\\dt\\) and strong order of convergence \\(\\sqrt{\\dt}\\).</p> <p>Parameters:</p> <ul> <li> <code>dt</code>         \u2013          <p>Fixed time step.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code> (default).</p>"},{"location":"python_api/method/Event.html","title":"Event","text":""},{"location":"python_api/method/Event.html#dynamiqs.method.Event","title":"dq.method.Event","text":"<pre><code>Event(\n    noclick_method: Method = Tsit5(),\n    dtmax: float | None = None,\n    root_finder: AbstractRootFinder | None = None,\n    smart_sampling: bool = False,\n)\n</code></pre> <p>Event method for the jump SSE.</p> <p>This method uses the Diffrax library event handling to interrupt the no-click integration at the next sampled click time, apply the corresponding measurement backaction to the state, and continue the no-click integration until the subsequent sampled click time.</p> Click times precision <p>When using adaptive step size solvers for the no-click integration, you must specify either <code>dtmax</code> or <code>root_finder</code> to control the precision of the click times. Otherwise, the adaptive solver may choose to take very large step sizes, which results in imprecise click times. You can either:</p> <ul> <li>specify <code>dtmax</code> to limit the maximum step size of the no-click evolution,</li> <li>or use the <code>root_finder</code> argument to refine the exact click times to a chosen   precision, see for example the   optimistix library Newton root finder.</li> </ul> <p>Parameters:</p> <ul> <li> <code>noclick_method</code>         \u2013          <p>Method for the no-click evolution. Defaults to <code>dq.method.Tsit5</code> (supported: <code>Tsit5</code>, <code>Dopri5</code>, <code>Dopri8</code>, <code>Kvaerno3</code>, <code>Kvaerno5</code>, <code>Euler</code>).</p> </li> <li> <code>dtmax</code>         \u2013          <p>Maximum step size for the no-click evolution, defaults to <code>None</code>.</p> </li> <li> <code>root_finder</code>         \u2013          <p>Root finder to refine the click times, defaults to <code>None</code> (precision determined by the integration step size).</p> </li> <li> <code>smart_sampling</code>         \u2013          <p>If <code>True</code>, the no-click trajectory is sampled only once, and <code>result.states</code> contains only trajectories with one or more clicks. Information about the no-click trajectory are stored in <code>result.infos</code>:</p> <ul> <li><code>result.infos.noclick_states</code> (qarray of shape (..., nsave, n, 1)) -     No-click trajectory.</li> <li><code>result.infos.noclick_prob</code> (array of shape (...)) - Probability of     the no-click trajectory.</li> <li><code>result.infos.noclick_expects</code> (array of shape     (..., len(exp_ops), ntsave) or None) - No-click trajectory expectation     values.</li> </ul> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.BackwardCheckpointed</code> (default).</p>"},{"location":"python_api/method/Expm.html","title":"Expm","text":""},{"location":"python_api/method/Expm.html#dynamiqs.method.Expm","title":"dq.method.Expm","text":"<pre><code>Expm()\n</code></pre> <p>Explicit matrix exponentiation to compute propagators.</p> <p>Explicitly batch-compute the propagators for all time intervals in <code>tsave</code>. These propagators are then iteratively applied:</p> <ul> <li>starting from the initial state for <code>dq.sesolve()</code> and   <code>dq.mesolve()</code>, to compute states for all times in <code>tsave</code>,</li> <li>starting from the identity matrix for <code>dq.sepropagator()</code>   and <code>dq.mepropagator()</code>, to compute propagators for all   times in <code>tsave</code>.</li> </ul> <p>For the Schr\u00f6dinger equation with constant Hamiltonian \\(H\\), the propagator from time \\(t_0\\) to time \\(t_1\\) is an \\(n\\times n\\) matrix given by $$     U(t_0, t_1) = \\exp(-i (t_1 - t_0) H). $$</p> <p>For the Lindblad master equation with constant Liouvillian \\(\\mathcal{L}\\), the problem is vectorized and the propagator from time \\(t_0\\) to time \\(t_1\\) is an \\(n^2\\times n^2\\) matrix given by $$     \\mathcal{U}(t_0, t_1) = \\exp((t_1 - t_0)\\mathcal{L}). $$</p> Warning <p>If the Hamiltonian or jump operators are sparse qarrays, they will be silently converted to dense qarrays before computing their matrix exponentials.</p> Warning <p>This method is not recommended for open systems of large dimension, due to the \\(\\mathcal{O}(n^6)\\) scaling of computing the Liouvillian exponential.</p> Warning <p>This method only supports constant or piecewise constant Hamiltonian and jump operators.</p> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code> (default).</p>"},{"location":"python_api/method/JumpMonteCarlo.html","title":"JumpMonteCarlo","text":""},{"location":"python_api/method/JumpMonteCarlo.html#dynamiqs.method.JumpMonteCarlo","title":"dq.method.JumpMonteCarlo","text":"<pre><code>JumpMonteCarlo(keys: PRNGKeyArray, jsse_method: Method, jsse_nmaxclick: int = 10000)\n</code></pre> <p>Jump Monte Carlo method for the Lindblad master equation.</p> <p>This method calls <code>dq.jssesolve()</code> to compute stochastic trajectories of the unit-efficiency jump unraveling of the Lindblad master equation (ME). These trajectories are then averaged to obtain an approximation of the ME solution.</p> Note <p>This method is solely a wrapper around <code>dq.jssesolve()</code>. If you are looking for direct access to individual trajectories, use <code>dq.jssesolve()</code> instead.</p> <p>Parameters:</p> <ul> <li> <code>keys</code>             (list of PRNG keys)         \u2013          <p>PRNG keys used for the jump SSE solver. See <code>dq.jssesolve()</code> for more details.</p> </li> <li> <code>jsse_method</code>         \u2013          <p>Method used for the jump SSE solver. See <code>dq.jssesolve()</code> for more details.</p> </li> <li> <code>jsse_nmaxclick</code>         \u2013          <p>Maximum buffer size for <code>result.clicktimes</code>. See <code>dq.jssesolve()</code> for more details.</p> </li> </ul> Supported gradients <p>See the documentation of the chosen <code>jsse_method</code>.</p>"},{"location":"python_api/method/Kvaerno3.html","title":"Kvaerno3","text":""},{"location":"python_api/method/Kvaerno3.html#dynamiqs.method.Kvaerno3","title":"dq.method.Kvaerno3","text":"<pre><code>Kvaerno3(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Kvaerno's method of order 3 (adaptive step size and implicit ODE method).</p> <p>This method is suitable for stiff problems, typically those with Hamiltonians or Liouvillians that have eigenvalues spanning different orders of magnitudes. This is for instance the case with problems involving high-order polynomials of the bosonic annihilation and creation operators, in large dimensions.</p> <p>This method is implemented by the Diffrax library, see <code>diffrax.Kvaerno3</code>.</p> Warning <p>If you find that your simulation is slow or that the progress bar gets stuck, consider switching to double-precision with <code>dq.set_precision('double')</code>. See more details in The sharp bits \ud83d\udd2a tutorial.</p> <p>Parameters:</p> <ul> <li> <code>rtol</code>         \u2013          <p>Relative tolerance.</p> </li> <li> <code>atol</code>         \u2013          <p>Absolute tolerance.</p> </li> <li> <code>safety_factor</code>         \u2013          <p>Safety factor for adaptive step sizing.</p> </li> <li> <code>min_factor</code>         \u2013          <p>Minimum factor for adaptive step sizing.</p> </li> <li> <code>max_factor</code>         \u2013          <p>Maximum factor for adaptive step sizing.</p> </li> <li> <code>max_steps</code>         \u2013          <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code>, <code>dq.gradient.BackwardCheckpointed</code> (default) and <code>dq.gradient.Forward</code>.</p>"},{"location":"python_api/method/Kvaerno5.html","title":"Kvaerno5","text":""},{"location":"python_api/method/Kvaerno5.html#dynamiqs.method.Kvaerno5","title":"dq.method.Kvaerno5","text":"<pre><code>Kvaerno5(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Kvaerno's method of order 5 (adaptive step size and implicit ODE method).</p> <p>This method is suitable for stiff problems, typically those with Hamiltonians or Liouvillians that have eigenvalues spanning different orders of magnitudes. This is for instance the case with problems involving high-order polynomials of the bosonic annihilation and creation operators, in large dimensions.</p> <p>This method is implemented by the Diffrax library, see <code>diffrax.Kvaerno5</code>.</p> Warning <p>If you find that your simulation is slow or that the progress bar gets stuck, consider switching to double-precision with <code>dq.set_precision('double')</code>. See more details in The sharp bits \ud83d\udd2a tutorial.</p> <p>Parameters:</p> <ul> <li> <code>rtol</code>         \u2013          <p>Relative tolerance.</p> </li> <li> <code>atol</code>         \u2013          <p>Absolute tolerance.</p> </li> <li> <code>safety_factor</code>         \u2013          <p>Safety factor for adaptive step sizing.</p> </li> <li> <code>min_factor</code>         \u2013          <p>Minimum factor for adaptive step sizing.</p> </li> <li> <code>max_factor</code>         \u2013          <p>Maximum factor for adaptive step sizing.</p> </li> <li> <code>max_steps</code>         \u2013          <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code>, <code>dq.gradient.BackwardCheckpointed</code> (default) and <code>dq.gradient.Forward</code>.</p>"},{"location":"python_api/method/Rouchon1.html","title":"Rouchon1","text":""},{"location":"python_api/method/Rouchon1.html#dynamiqs.method.Rouchon1","title":"dq.method.Rouchon1","text":"<pre><code>Rouchon1(dt: float, normalize: bool = True, exact_expm: bool = False)\n</code></pre> <p>First-order Rouchon method (fixed step size ODE/SDE method).</p> <p>Parameters:</p> <ul> <li> <code>dt</code>         \u2013          <p>Fixed time step.</p> </li> <li> <code>normalize</code>         \u2013          <p>If True, the scheme is trace-preserving to machine precision, which is the recommended option because it is much more stable. Otherwise, it is only trace-preserving to the scheme order in \\(\\dt\\).</p> </li> <li> <code>exact_expm</code>         \u2013          <p>If True, the scheme uses the exact matrix exponential internally (at the cost of losing sparsity), otherwise it uses a Taylor expansion up to the scheme order.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code>, <code>dq.gradient.BackwardCheckpointed</code> (default) and <code>dq.gradient.Forward</code>.</p>"},{"location":"python_api/method/Rouchon2.html","title":"Rouchon2","text":""},{"location":"python_api/method/Rouchon2.html#dynamiqs.method.Rouchon2","title":"dq.method.Rouchon2","text":"<pre><code>Rouchon2(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n    dt: float | None = None,\n    normalize: bool = True,\n    exact_expm: bool = False,\n)\n</code></pre> <p>Second-order Rouchon method (fixed or adaptive step size ODE method).</p> Note <p>By default the scheme is using adaptive step size. The error is estimated using the difference between the first-order and second-order. To use a fixed step size second-order method (without evaluating the first-order), set the <code>dt</code> argument.</p> <p>Parameters:</p> <ul> <li> <code>rtol</code>         \u2013          <p>Relative tolerance.</p> </li> <li> <code>atol</code>         \u2013          <p>Absolute tolerance.</p> </li> <li> <code>safety_factor</code>         \u2013          <p>Safety factor for adaptive step sizing.</p> </li> <li> <code>min_factor</code>         \u2013          <p>Minimum factor for adaptive step sizing.</p> </li> <li> <code>max_factor</code>         \u2013          <p>Maximum factor for adaptive step sizing.</p> </li> <li> <code>max_steps</code>         \u2013          <p>Maximum number of steps.</p> </li> <li> <code>dt</code>         \u2013          <p>Fixed time step, if specified all arguments specific to adaptive step sizing are ignored (<code>rtol</code>, <code>atol</code>, <code>safety_factor</code>, <code>min_factor</code>, <code>max_factor</code> and <code>max_steps</code>).</p> </li> <li> <code>normalize</code>         \u2013          <p>If True, the scheme is trace-preserving to machine precision, which is the recommended option because it is much more stable. Otherwise, it is only trace-preserving to the scheme order in the numerical step size.</p> </li> <li> <code>exact_expm</code>         \u2013          <p>If True, the scheme uses the exact matrix exponential internally (at the cost of losing sparsity), otherwise it uses a Taylor expansion up to the scheme order.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code>, <code>dq.gradient.BackwardCheckpointed</code> (default) and <code>dq.gradient.Forward</code>.</p>"},{"location":"python_api/method/Rouchon3.html","title":"Rouchon3","text":""},{"location":"python_api/method/Rouchon3.html#dynamiqs.method.Rouchon3","title":"dq.method.Rouchon3","text":"<pre><code>Rouchon3(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n    dt: float | None = None,\n    normalize: bool = True,\n    exact_expm: bool = False,\n)\n</code></pre> <p>Third-order Rouchon method (fixed or adaptive step size ODE method).</p> Note <p>By default the scheme is using adaptive step size. The error is estimated using the difference between the second-order and third-order. To use a fixed step size third-order method (without evaluating the second-order), set the <code>dt</code> argument.</p> <p>Parameters:</p> <ul> <li> <code>rtol</code>         \u2013          <p>Relative tolerance.</p> </li> <li> <code>atol</code>         \u2013          <p>Absolute tolerance.</p> </li> <li> <code>safety_factor</code>         \u2013          <p>Safety factor for adaptive step sizing.</p> </li> <li> <code>min_factor</code>         \u2013          <p>Minimum factor for adaptive step sizing.</p> </li> <li> <code>max_factor</code>         \u2013          <p>Maximum factor for adaptive step sizing.</p> </li> <li> <code>max_steps</code>         \u2013          <p>Maximum number of steps.</p> </li> <li> <code>dt</code>         \u2013          <p>Fixed time step, if specified all arguments specific to adaptive step sizing are ignored (<code>rtol</code>, <code>atol</code>, <code>safety_factor</code>, <code>min_factor</code>, <code>max_factor</code> and <code>max_steps</code>).</p> </li> <li> <code>normalize</code>         \u2013          <p>If True, the scheme is trace-preserving to machine precision, which is the recommended option because it is much more stable. Otherwise, it is only trace-preserving to the scheme order in the numerical step size.</p> </li> <li> <code>exact_expm</code>         \u2013          <p>If True, the scheme uses the exact matrix exponential internally (at the cost of losing sparsity), otherwise it uses a Taylor expansion up to the scheme order.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code>, <code>dq.gradient.BackwardCheckpointed</code> (default) and <code>dq.gradient.Forward</code>.</p>"},{"location":"python_api/method/Tsit5.html","title":"Tsit5","text":""},{"location":"python_api/method/Tsit5.html#dynamiqs.method.Tsit5","title":"dq.method.Tsit5","text":"<pre><code>Tsit5(\n    rtol: float = 1e-06,\n    atol: float = 1e-06,\n    safety_factor: float = 0.9,\n    min_factor: float = 0.2,\n    max_factor: float = 5.0,\n    max_steps: int = 100000,\n)\n</code></pre> <p>Tsitouras method of order 5 (adaptive step size ODE method).</p> <p>This method is implemented by the Diffrax library, see <code>diffrax.Tsit5</code>.</p> <p>Parameters:</p> <ul> <li> <code>rtol</code>         \u2013          <p>Relative tolerance.</p> </li> <li> <code>atol</code>         \u2013          <p>Absolute tolerance.</p> </li> <li> <code>safety_factor</code>         \u2013          <p>Safety factor for adaptive step sizing.</p> </li> <li> <code>min_factor</code>         \u2013          <p>Minimum factor for adaptive step sizing.</p> </li> <li> <code>max_factor</code>         \u2013          <p>Maximum factor for adaptive step sizing.</p> </li> <li> <code>max_steps</code>         \u2013          <p>Maximum number of steps.</p> </li> </ul> Supported gradients <p>This method supports differentiation with <code>dq.gradient.Direct</code>, <code>dq.gradient.BackwardCheckpointed</code> (default) and <code>dq.gradient.Forward</code>.</p>"},{"location":"python_api/plot/fock.html","title":"fock","text":""},{"location":"python_api/plot/fock.html#dynamiqs.plot.fock.fock","title":"dq.plot.fock","text":"<pre><code>fock(\n    state: QArrayLike,\n    *,\n    ax: Axes | None = None,\n    allxticks: bool = False,\n    ymax: float | None = 1.0,\n    color: str = colors[\"blue\"],\n    alpha: float = 1.0,\n    label: str = \"\"\n)\n</code></pre> <p>Plot the photon number population of a state.</p> Warning <p>Documentation redaction in progress.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi = dq.coherent(16, 2.0)\n&gt;&gt;&gt; dq.plot.fock(psi)\n&gt;&gt;&gt; renderfig('plot_fock')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; # the even cat state has only even photon number components\n&gt;&gt;&gt; psi = (dq.coherent(32, 3.0) + dq.coherent(32, -3.0)).unit()\n&gt;&gt;&gt; dq.plot.fock(psi, allxticks=False, ymax=None)\n&gt;&gt;&gt; renderfig('plot_fock_even_cat')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; dq.plot.fock(dq.coherent(16, 1.0), alpha=0.5)\n&gt;&gt;&gt; dq.plot.fock(dq.coherent(16, 2.0), ax=plt.gca(), alpha=0.5, color='red')\n&gt;&gt;&gt; renderfig('plot_fock_coherent')\n</code></pre> <p></p>"},{"location":"python_api/plot/fock_evolution.html","title":"fock_evolution","text":""},{"location":"python_api/plot/fock_evolution.html#dynamiqs.plot.fock.fock_evolution","title":"dq.plot.fock_evolution","text":"<pre><code>fock_evolution(\n    states: QArrayLike,\n    *,\n    ax: Axes | None = None,\n    times: ArrayLike | None = None,\n    cmap: str = \"Blues\",\n    logscale: bool = False,\n    logvmin: float = 0.0001,\n    colorbar: bool = True,\n    allyticks: bool = False\n)\n</code></pre> <p>Plot the photon number population of state as a function of time.</p> Warning <p>Documentation redaction in progress.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; psi0 = dq.coherent(n, 0.0)\n&gt;&gt;&gt; H = 2.0 * (a + a.dag())\n&gt;&gt;&gt; tsave = jnp.linspace(0, 1.0, 11)\n&gt;&gt;&gt; result = dq.sesolve(H, psi0, tsave)\n&gt;&gt;&gt; dq.plot.fock_evolution(result.states, times=tsave)\n&gt;&gt;&gt; renderfig('plot_fock_evolution')\n</code></pre> <p></p> <p>Use the log scale option to visualise low populations:</p> <pre><code>&gt;&gt;&gt; dq.plot.fock_evolution(result.states, times=tsave, logscale=True)\n&gt;&gt;&gt; renderfig('plot_fock_evolution_log')\n</code></pre> <p></p>"},{"location":"python_api/plot/gifit.html","title":"gifit","text":""},{"location":"python_api/plot/gifit.html#dynamiqs.plot.gifit","title":"dq.plot.gifit","text":"<pre><code>gifit(plot_function: callable[[T, ...], None]) -&gt; callable[[Sequence[T], ...], Image]\n</code></pre> <p>Transform a plot function into a new function that returns an animated GIF.</p> <p>This function takes a plot function that normally operates on a single input and returns a new function that creates a GIF from a sequence of inputs. The new function accepts two extra keyword arguments:</p> <ul> <li>gif_duration (float) -- GIF duration in seconds.</li> <li>fps (int) -- GIF frames per seconds.</li> </ul> <p>The new function returns an object of type <code>IPython.core.display.Image</code>, which automatically displays the GIF in Jupyter notebook environments (when the <code>Image</code> object is the last expression in a cell).</p> Save GIF to a file <p>The returned GIF can be saved to a file with:</p> <pre><code>with open('/path/to/file.gif').open('wb') as f:\n    f.write(gif.data)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>plot_function</code>         \u2013          <p>Plot function which must take as first positional argument the input that will be sequenced over by the new function. It must create a matplotlib <code>Figure</code> object and not close it.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>A new function with the same signature as <code>plot_function</code> which accepts a sequence of inputs and returns a GIF by applying the original <code>plot_function</code> to each element in the sequence.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def plot_cos(phi):\n...     x = np.linspace(0, 1.0, 501)\n...     y = np.cos(2 * np.pi * x + phi)\n...     plt.figure(constrained_layout=True)\n...     plt.plot(x, y)\n&gt;&gt;&gt; phis = np.linspace(0, 2 * np.pi, 101)\n&gt;&gt;&gt; gif = dq.plot.gifit(plot_cos)(phis, fps=25)\n&gt;&gt;&gt; gif\n&lt;IPython.core.display.Image object&gt;\n&gt;&gt;&gt; rendergif(gif, 'cos')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; alphas = jnp.linspace(0.0, 3.0, 51)\n&gt;&gt;&gt; states = dq.coherent(24, alphas)\n&gt;&gt;&gt; gif = dq.plot.gifit(dq.plot.fock)(states, fps=25)\n&gt;&gt;&gt; rendergif(gif, 'coherent_evolution')\n</code></pre> <p></p>"},{"location":"python_api/plot/grid.html","title":"grid","text":""},{"location":"python_api/plot/grid.html#dynamiqs.plot.grid","title":"dq.plot.grid","text":"<pre><code>grid(\n    n: int,\n    nrows: int = 1,\n    *,\n    w: float = 3.0,\n    h: float | None = None,\n    sharexy: bool = False,\n    **kwargs\n) -&gt; tuple[Figure, Iterable[Axes]]\n</code></pre> <p>Returns a figure and an iterator of subplots organised in a grid.</p> Warning <p>Documentation redaction in progress.</p> Note <p>This method is a shortcut to Matplotlib <code>plt.subplots()</code>.</p> <p>Examples:</p> <p>For example, to plot six different curves:</p> <pre><code>&gt;&gt;&gt; x = jnp.linspace(0, 1, 101)\n&gt;&gt;&gt; ys = [jnp.sin(f * 2 * jnp.pi * x) for f in range(6)]  # (6, 101)\n</code></pre> <p>Replace the usual Matplotlib code</p> <pre><code>&gt;&gt;&gt; fig, axs = plt.subplots(\n...     2, 3, figsize=(3 * 3.0, 2 * 3.0), sharex=True, sharey=True\n... )\n&gt;&gt;&gt; for i, y in enumerate(ys):\n...     axs[i // 3][i % 3].plot(x, y)\n[...]\n&gt;&gt;&gt; fig.tight_layout()\n</code></pre> <p>by</p> <pre><code>&gt;&gt;&gt; _, axs = dq.plot.grid(6, 2, sharexy=True)  # 6 subplots, 2 rows\n&gt;&gt;&gt; for y in ys:\n...     next(axs).plot(x, y)\n[...]\n&gt;&gt;&gt; renderfig('plot_grid')\n</code></pre> <p></p>"},{"location":"python_api/plot/hinton.html","title":"hinton","text":"hinton"},{"location":"python_api/plot/hinton.html#dynamiqs.plot.hinton.hinton","title":"hinton.hinton","text":"<pre><code>hinton(\n    x: QArrayLike,\n    *,\n    ax: Axes | None = None,\n    cmap: str | None = None,\n    vmin: float | None = None,\n    vmax: float | None = None,\n    colorbar: bool = True,\n    allticks: bool = False,\n    tickslabel: list[str] | None = None,\n    ecolor: str = \"white\",\n    ewidth: float = 0.5,\n    clear: bool = False\n)\n</code></pre> <p>Plot a Hinton diagram.</p> Warning <p>Documentation redaction in progress.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rho = dq.coherent_dm(16, 2.0)\n&gt;&gt;&gt; dq.plot.hinton(jnp.abs(rho.to_jax()))\n&gt;&gt;&gt; renderfig('plot_hinton_coherent')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; a = dq.destroy(16)\n&gt;&gt;&gt; H = a.dag() @ a + 2.0 * (a + a.dag())\n&gt;&gt;&gt; dq.plot.hinton(jnp.abs(H.to_jax()))\n&gt;&gt;&gt; renderfig('plot_hinton_hamiltonian')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; cnot = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]\n&gt;&gt;&gt; dq.plot.hinton(cnot, tickslabel=['00', '01', '10', '11'])\n&gt;&gt;&gt; renderfig('plot_hinton_cnot')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; x = dq.random.complex(key, (16, 16))\n&gt;&gt;&gt; dq.plot.hinton(x)\n&gt;&gt;&gt; renderfig('plot_hinton_random_complex')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; _, axs = dq.plot.grid(2)\n&gt;&gt;&gt; psi = (dq.fock(4, 0) - dq.fock(4, 2)).unit()\n&gt;&gt;&gt; dq.plot.hinton(psi.todm(), ax=next(axs))\n&gt;&gt;&gt; rho = (dq.fock_dm(4, 0) + dq.fock_dm(4, 2)).unit()\n&gt;&gt;&gt; dq.plot.hinton(rho, ax=next(axs))\n&gt;&gt;&gt; renderfig('plot_hinton_fock02')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; _, axs = dq.plot.grid(2)\n&gt;&gt;&gt; x = np.random.uniform(-1.0, 1.0, (10, 10))\n&gt;&gt;&gt; dq.plot.hinton(x, ax=next(axs), vmin=-1.0, vmax=1.0)\n&gt;&gt;&gt; dq.plot.hinton(\n...     jnp.abs(x), ax=next(axs), cmap='Greys', vmax=1.0, ecolor='black'\n... )\n&gt;&gt;&gt; renderfig('plot_hinton_real')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; x = np.random.uniform(-1.0, 1.0, (100, 100))\n&gt;&gt;&gt; dq.plot.hinton(x, vmin=-1.0, vmax=1.0, ewidth=0, clear=True, w=20)\n&gt;&gt;&gt; renderfig('plot_hinton_large')\n</code></pre> <p></p>"},{"location":"python_api/plot/mplstyle.html","title":"mplstyle","text":""},{"location":"python_api/plot/mplstyle.html#dynamiqs.plot.mplstyle","title":"dq.plot.mplstyle","text":"<pre><code>mplstyle(*, usetex: bool = False, dpi: int = 72)\n</code></pre> <p>Set custom Matplotlib style.</p> Warning <p>Documentation redaction in progress.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = jnp.linspace(0, 2 * jnp.pi, 101)\n&gt;&gt;&gt; ys = [jnp.sin(x), jnp.sin(2 * x), jnp.sin(3 * x)]\n&gt;&gt;&gt; default_mpl_style()\n</code></pre> <p>Before (default Matplotlib style):</p> <pre><code>&gt;&gt;&gt; fig, ax = plt.subplots(1, 1)\n&gt;&gt;&gt; for y in ys:\n...     ax.plot(x, y)\n[...]\n&gt;&gt;&gt; ax.set(xlabel=r'$x$', ylabel=r'$\\sin(x)$')\n[...]\n&gt;&gt;&gt; renderfig('mplstyle_before')\n</code></pre> <p></p> <p>After (Dynamiqs Matplotlib style):</p> <pre><code>&gt;&gt;&gt; dq.plot.mplstyle(dpi=150)\n&gt;&gt;&gt; fig, ax = plt.subplots(1, 1)\n&gt;&gt;&gt; for y in ys:\n...     ax.plot(x, y)\n[...]\n&gt;&gt;&gt; ax.set(xlabel=r'$x$', ylabel=r'$\\sin(x)$')\n[...]\n&gt;&gt;&gt; renderfig('mplstyle_after')\n</code></pre> <p></p>"},{"location":"python_api/plot/pwc_pulse.html","title":"pwc_pulse","text":""},{"location":"python_api/plot/pwc_pulse.html#dynamiqs.plot.pwc_pulse","title":"dq.plot.pwc_pulse","text":"<pre><code>pwc_pulse(\n    times: ArrayLike,\n    values: ArrayLike,\n    *,\n    ax: Axes = None,\n    ycenter: bool = True,\n    real_color: str = colors[\"blue\"],\n    imag_color: str = colors[\"purple\"]\n)\n</code></pre> <p>Plot a piecewise constant pulse.</p> Warning <p>Documentation redaction in progress.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; n = 20\n&gt;&gt;&gt; times = jnp.linspace(0, 1.0, n + 1)\n&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; values = dq.random.complex(key, n)\n&gt;&gt;&gt; dq.plot.pwc_pulse(times, values)\n&gt;&gt;&gt; renderfig('plot_pwc_pulse')\n</code></pre> <p></p>"},{"location":"python_api/plot/wigner.html","title":"wigner","text":""},{"location":"python_api/plot/wigner.html#dynamiqs.plot.wigner.wigner","title":"dq.plot.wigner","text":"<pre><code>wigner(\n    state: QArrayLike,\n    *,\n    ax: Axes | None = None,\n    xmax: float = 5.0,\n    ymax: float | None = None,\n    vmax: float = 2 / jnp.pi,\n    npixels: int = 101,\n    cmap: str = \"dq\",\n    interpolation: str = \"bilinear\",\n    colorbar: bool = True,\n    cross: bool = False,\n    clear: bool = False\n)\n</code></pre> <p>Plot the Wigner function of a state.</p> Warning <p>Documentation redaction in progress.</p> Note <p>Choose a diverging colormap <code>cmap</code> for better results.</p> Warning <p>The axis scaling is chosen so that a coherent state \\(\\ket{\\alpha}\\) lies at the coordinates \\((x,y)=(\\mathrm{Re}(\\alpha),\\mathrm{Im}(\\alpha))\\), which is different from the default behaviour of <code>qutip.plot_wigner()</code>.</p> See also <ul> <li><code>dq.wigner()</code>: compute the Wigner distribution of a ket or     density matrix.</li> <li><code>dq.plot.wigner_data()</code>: plot a pre-computed     Wigner function.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi = dq.coherent(16, 2.0)\n&gt;&gt;&gt; dq.plot.wigner(psi)\n&gt;&gt;&gt; renderfig('plot_wigner_coh')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; psi = (dq.coherent(16, 2) + dq.coherent(16, -2)).unit()\n&gt;&gt;&gt; dq.plot.wigner(psi, xmax=4.0, ymax=2.0, colorbar=False)\n&gt;&gt;&gt; renderfig('plot_wigner_cat')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; psi = (dq.fock(2, 0) + dq.fock(2, 1)).unit()\n&gt;&gt;&gt; dq.plot.wigner(psi, xmax=2.0, cross=True)\n&gt;&gt;&gt; renderfig('plot_wigner_01')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; psi = dq.coherent(32, [3, 3j, -3, -3j]).sum(0).unit()\n&gt;&gt;&gt; dq.plot.wigner(psi, npixels=201, clear=True)\n&gt;&gt;&gt; renderfig('plot_wigner_4legged')\n</code></pre> <p></p>"},{"location":"python_api/plot/wigner_data.html","title":"wigner_data","text":""},{"location":"python_api/plot/wigner_data.html#dynamiqs.plot.wigner.wigner_data","title":"dq.plot.wigner_data","text":"<pre><code>wigner_data(\n    wigner: ArrayLike,\n    xmax: float,\n    ymax: float,\n    *,\n    ax: Axes | None = None,\n    vmax: float = 2 / jnp.pi,\n    cmap: str = \"dq\",\n    interpolation: str = \"bilinear\",\n    colorbar: bool = True,\n    cross: bool = False,\n    clear: bool = False\n)\n</code></pre> <p>Plot a pre-computed Wigner function.</p> Warning <p>Documentation redaction in progress.</p> Note <p>Choose a diverging colormap <code>cmap</code> for better results.</p> See also <ul> <li><code>dq.wigner()</code>: compute the Wigner distribution of a ket or     density matrix.</li> <li><code>dq.plot.wigner()</code>: plot the Wigner function of a     state.</li> </ul>"},{"location":"python_api/plot/wigner_gif.html","title":"wigner_gif","text":""},{"location":"python_api/plot/wigner_gif.html#dynamiqs.plot.wigner.wigner_gif","title":"dq.plot.wigner_gif","text":"<pre><code>wigner_gif(\n    states: QArrayLike,\n    *,\n    gif_duration: float = 5.0,\n    fps: int = 10,\n    w: float = 5.0,\n    xmax: float = 5.0,\n    ymax: float | None = None,\n    vmax: float = 2 / jnp.pi,\n    npixels: int = 101,\n    cmap: str = \"dq\",\n    interpolation: str = \"bilinear\",\n    cross: bool = False,\n    clear: bool = False\n) -&gt; Image\n</code></pre> <p>Plot a GIF of the Wigner function of multiple states.</p> Warning <p>Documentation redaction in progress.</p> <p>See <code>dq.plot.wigner()</code> and <code>dq.plot.gifit()</code> for more details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; H = dq.zeros(n)\n&gt;&gt;&gt; jump_ops = [a @ a - 4.0 * dq.eye(n)]  # cat state inflation\n&gt;&gt;&gt; psi0 = dq.coherent(n, 0)\n&gt;&gt;&gt; tsave = jnp.linspace(0, 1.0, 1001)\n&gt;&gt;&gt; result = dq.mesolve(H, jump_ops, psi0, tsave)\n&gt;&gt;&gt; gif = dq.plot.wigner_gif(result.states, fps=25, xmax=4.0, ymax=2.0)\n&gt;&gt;&gt; rendergif(gif, 'wigner-cat')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; H = a.dag() @ a.dag() @ a @ a  # Kerr Hamiltonian\n&gt;&gt;&gt; psi0 = dq.coherent(n, 2)\n&gt;&gt;&gt; tsave = jnp.linspace(0, jnp.pi, 1001)\n&gt;&gt;&gt; result = dq.sesolve(H, psi0, tsave)\n&gt;&gt;&gt; gif = dq.plot.wigner_gif(\n...     result.states, gif_duration=10.0, fps=25, xmax=4.0, clear=True\n... )\n&gt;&gt;&gt; rendergif(gif, 'wigner-kerr')\n</code></pre> <p></p>"},{"location":"python_api/plot/wigner_mosaic.html","title":"wigner_mosaic","text":""},{"location":"python_api/plot/wigner_mosaic.html#dynamiqs.plot.wigner.wigner_mosaic","title":"dq.plot.wigner_mosaic","text":"<pre><code>wigner_mosaic(\n    states: QArrayLike,\n    *,\n    n: int = 8,\n    nrows: int = 1,\n    w: float = 3.0,\n    h: float | None = None,\n    xmax: float = 5.0,\n    ymax: float | None = None,\n    vmax: float = 2 / jnp.pi,\n    npixels: int = 101,\n    cmap: str = \"dq\",\n    interpolation: str = \"bilinear\",\n    cross: bool = False\n)\n</code></pre> <p>Plot the Wigner function of multiple states in a mosaic arrangement.</p> Warning <p>Documentation redaction in progress.</p> <p>See <code>dq.plot.wigner()</code> for more details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psis = [dq.fock(3, i) for i in range(3)]\n&gt;&gt;&gt; dq.plot.wigner_mosaic(psis)\n&gt;&gt;&gt; renderfig('plot_wigner_mosaic_fock')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; H = dq.zeros(n)\n&gt;&gt;&gt; jump_ops = [a @ a - 4.0 * dq.eye(n)]  # cat state inflation\n&gt;&gt;&gt; psi0 = dq.coherent(n, 0)\n&gt;&gt;&gt; tsave = jnp.linspace(0, 1.0, 101)\n&gt;&gt;&gt; result = dq.mesolve(H, jump_ops, psi0, tsave)\n&gt;&gt;&gt; dq.plot.wigner_mosaic(result.states, n=6, xmax=4.0, ymax=2.0)\n&gt;&gt;&gt; renderfig('plot_wigner_mosaic_cat')\n</code></pre> <p></p> <pre><code>&gt;&gt;&gt; n = 16\n&gt;&gt;&gt; a = dq.destroy(n)\n&gt;&gt;&gt; H = a.dag() @ a.dag() @ a @ a  # Kerr Hamiltonian\n&gt;&gt;&gt; psi0 = dq.coherent(n, 2)\n&gt;&gt;&gt; tsave = jnp.linspace(0, jnp.pi, 101)\n&gt;&gt;&gt; result = dq.sesolve(H, psi0, tsave)\n&gt;&gt;&gt; dq.plot.wigner_mosaic(result.states, n=25, nrows=5, xmax=4.0)\n&gt;&gt;&gt; renderfig('plot_wigner_mosaic_kerr')\n</code></pre> <p></p>"},{"location":"python_api/plot/xyz.html","title":"xyz","text":""},{"location":"python_api/plot/xyz.html#dynamiqs.plot.xyz","title":"dq.plot.xyz","text":"<pre><code>xyz(\n    states: QArrayLike,\n    *,\n    ax: Axes | None = None,\n    times: ArrayLike | None = None,\n    hlines: bool = True\n)\n</code></pre> <p>Plot the expectation value of the Pauli operators of a qubit \\(\\sigma_x\\), \\(\\sigma_y\\) and \\(\\sigma_z\\) as a function of time.</p> Warning <p>Documentation redaction in progress.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; H = dq.sigmax() + dq.sigmay()\n&gt;&gt;&gt; jump_ops = [jnp.sqrt(0.2) * dq.sigmam()]\n&gt;&gt;&gt; psi0 = dq.excited()\n&gt;&gt;&gt; tsave = jnp.linspace(0, 10.0, 1001)\n&gt;&gt;&gt; result = states = dq.mesolve(H, jump_ops, psi0, tsave)\n&gt;&gt;&gt; dq.plot.xyz(result.states, times=tsave)\n&gt;&gt;&gt; renderfig('plot_xyz')\n</code></pre> <p></p>"},{"location":"python_api/qarrays/qarray/QArray.html","title":"Quantum arrays","text":""},{"location":"python_api/qarrays/qarray/QArray.html#dynamiqs.qarrays.qarray.QArray","title":"dq.QArray","text":"<p>Dynamiqs custom array to represent quantum objects.</p> <p>A qarray is a wrapper around the data structure representing a quantum object (a ket, a density matrix, an operator, a superoperator, etc.) that offers convenience methods.</p> <p>There are two types of qarrays:</p> <ul> <li><code>DenseQArray</code>: wrapper around JAX arrays, dense representation of the array.</li> <li><code>SparseDIAQArray</code>: Dynamiqs sparse diagonal format, storing only the non-zero     diagonals.</li> </ul> Constructing a new qarray from an other array type <p>Use the function <code>dq.asqarray()</code> to create a qarray from a qarray-like. Objects that can be converted to a <code>QArray</code> are of type <code>dq.QArrayLike</code>. This includes all numeric types (<code>bool</code>, <code>int</code>, <code>float</code>, <code>complex</code>), a NumPy or JAX array, a Dynamiqs qarray, a QuTiP qobj, or any nested sequence of these types. See also <code>dq.isqarraylike()</code>.</p> <p>Attributes:</p> <ul> <li> <code>dtype</code>             (numpy.dtype)         \u2013          <p>Data type.</p> </li> <li> <code>shape</code>             (tuple of ints)         \u2013          <p>Shape.</p> </li> <li> <code>ndim</code>             (int)         \u2013          <p>Number of dimensions in the shape.</p> </li> <li> <code>layout</code>             (Layout)         \u2013          <p>Data layout, either <code>dq.dense</code> or <code>dq.dia</code>.</p> </li> <li> <code>dims</code>             (tuple of ints)         \u2013          <p>Hilbert space dimension of each subsystem.</p> </li> <li> <code>mT</code>             (qarray)         \u2013          <p>Returns the qarray transposed over its last two dimensions.</p> </li> <li> <code>vectorized</code>             (bool)         \u2013          <p>Whether the underlying object is non-vectorized (ket, bra or operator) or vectorized (operator in vector form or superoperator in matrix form).</p> </li> </ul> Arithmetic operation support <p>Qarrays support basic arithmetic operations <code>-, +, *, /, @</code> with other qarray-likes.</p> Shortcuts methods to use quantum utilities <p>Many functions of the library can be called directly on a qarray rather than through the functional API. For example, you can use <code>x.dag()</code> instead of <code>dq.dag(x)</code>.</p> <p>Here is the list of qarray methods:</p> Method Description <code>x.conj()</code> Returns the element-wise complex conjugate of the qarray. <code>x.dag()</code> Alias of <code>dq.dag(x)</code>. <code>x.powm()</code> Alias of <code>dq.powm(x)</code>. <code>x.expm()</code> Alias of <code>dq.expm(x)</code>. <code>x.cosm()</code> Alias of <code>dq.cosm(x)</code>. <code>x.sinm()</code> Alias of <code>dq.sinm(x)</code>. <code>x.signm()</code> Alias of <code>dq.signm(x)</code>. <code>x.trace()</code> Alias of <code>dq.trace(x)</code>. <code>x.ptrace(keep)</code> Alias of <code>dq.ptrace(x, keep, dims=x.dims)</code>. <code>x.norm()</code> Alias of <code>dq.norm(x)</code>. <code>x.unit()</code> Alias of <code>dq.unit(x)</code>. <code>x.isket()</code> Alias of <code>dq.isket(x)</code>. <code>x.isbra()</code> Alias of <code>dq.isbra(x)</code>. <code>x.isdm()</code> Alias of <code>dq.isdm(x)</code>. <code>x.isop()</code> Alias of <code>dq.isop(x)</code>. <code>x.isherm()</code> Alias of <code>dq.isherm(x)</code>. <code>x.toket()</code> Alias of <code>dq.toket(x)</code>. <code>x.tobra()</code> Alias of <code>dq.tobra(x)</code>. <code>x.todm()</code> Alias of <code>dq.todm(x)</code>. <code>x.proj()</code> Alias of <code>dq.proj(x)</code>. <code>x.reshape(*shape)</code> Returns a reshaped copy of a qarray. <code>x.broadcast_to(*shape)</code> Broadcasts a qarray to a new shape. <code>x.addscalar(y)</code> Adds a scalar. <code>x.elmul(y)</code> Computes the element-wise multiplication. <code>x.elpow(power)</code> Computes the element-wise power. <p>There are also several conversion methods available:</p> Method Description <code>x.to_qutip()</code> Alias of <code>dq.to_qutip(x, dims=x.dims)</code>. <code>x.to_jax()</code> Alias of <code>dq.to_jax(x)</code>. <code>x.to_numpy()</code> Alias of <code>dq.to_numpy(x)</code>. <code>x.asdense()</code> Converts to a dense layout. <code>x.assparsedia()</code> Converts to a sparse diagonal layout."},{"location":"python_api/qarrays/qarray/QArray.html#dynamiqs.qarrays.qarray.QArray.conj","title":"QArray.conj","text":"<pre><code>conj() -&gt; QArray\n</code></pre> <p>Returns the element-wise complex conjugate of the qarray.</p> <p>Returns:</p> <ul> <li> <p>New qarray with element-wise complex conjuguated values.</p> </li> </ul>"},{"location":"python_api/qarrays/qarray/QArray.html#dynamiqs.qarrays.qarray.QArray.reshape","title":"QArray.reshape","text":"<pre><code>reshape(*shape: int) -&gt; QArray\n</code></pre> <p>Returns a reshaped copy of a qarray.</p> <p>Parameters:</p> <ul> <li> <code>*shape</code>         \u2013          <p>New shape, which must match the original size.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>New qarray with the given shape.</p> </li> </ul>"},{"location":"python_api/qarrays/qarray/QArray.html#dynamiqs.qarrays.qarray.QArray.broadcast_to","title":"QArray.broadcast_to","text":"<pre><code>broadcast_to(*shape: int) -&gt; QArray\n</code></pre> <p>Broadcasts a qarray to a new shape.</p> <p>Parameters:</p> <ul> <li> <code>*shape</code>         \u2013          <p>New shape, which must be compatible with the original shape.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>New qarray with the given shape.</p> </li> </ul>"},{"location":"python_api/qarrays/qarray/QArray.html#dynamiqs.qarrays.qarray.QArray.asdense","title":"QArray.asdense","text":"<pre><code>asdense() -&gt; DenseQArray\n</code></pre> <p>Converts to a dense layout.</p> <p>Returns:</p> <ul> <li> <p>A <code>DenseQArray</code>.</p> </li> </ul>"},{"location":"python_api/qarrays/qarray/QArray.html#dynamiqs.qarrays.qarray.QArray.assparsedia","title":"QArray.assparsedia","text":"<pre><code>assparsedia(offsets: tuple[int, ...] | None = None) -&gt; SparseDIAQArray\n</code></pre> <p>Converts to a sparse diagonal layout.</p> <p>Parameters:</p> <ul> <li> <code>offsets</code>         \u2013          <p>Offsets of the stored diagonals. If <code>None</code>, offsets are determined automatically from the matrix structure. This argument can also be explicitly specified to ensure compatibility with JAX transformations, which require static offset values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>A <code>SparseDIAQArray</code>.</p> </li> </ul>"},{"location":"python_api/qarrays/qarray/QArray.html#dynamiqs.qarrays.qarray.QArray.addscalar","title":"QArray.addscalar","text":"<pre><code>addscalar(y: ArrayLike) -&gt; QArray\n</code></pre> <p>Adds a scalar.</p> <p>Parameters:</p> <ul> <li> <code>y</code>         \u2013          <p>Scalar to add, whose shape should be broadcastable with the qarray.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>New qarray resulting from the addition with the scalar.</p> </li> </ul>"},{"location":"python_api/qarrays/qarray/QArray.html#dynamiqs.qarrays.qarray.QArray.elmul","title":"QArray.elmul","text":"<pre><code>elmul(y: QArrayLike) -&gt; QArray\n</code></pre> <p>Computes the element-wise multiplication.</p> <p>Parameters:</p> <ul> <li> <code>y</code>         \u2013          <p>Qarray-like to multiply with element-wise.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>New qarray resulting from the element-wise multiplication.</p> </li> </ul>"},{"location":"python_api/qarrays/qarray/QArray.html#dynamiqs.qarrays.qarray.QArray.elpow","title":"QArray.elpow","text":"<pre><code>elpow(power: int) -&gt; QArray\n</code></pre> <p>Computes the element-wise power.</p> <p>Parameters:</p> <ul> <li> <code>power</code>         \u2013          <p>Power to raise to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>New qarray with elements raised to the specified power.</p> </li> </ul>"},{"location":"python_api/qarrays/utils/asqarray.html","title":"asqarray","text":""},{"location":"python_api/qarrays/utils/asqarray.html#dynamiqs.qarrays.utils.asqarray","title":"dq.asqarray","text":"<pre><code>asqarray(\n    x: QArrayLike,\n    dims: tuple[int, ...] | None = None,\n    layout: Layout | None = None,\n    *,\n    offsets: tuple[int, ...] | None = None\n) -&gt; QArray\n</code></pre> <p>Converts a qarray-like into a qarray.</p> <p>Parameters:</p> <ul> <li> <code>x</code>         \u2013          <p>Object to convert.</p> </li> <li> <code>dims</code>             (tuple of ints or None)         \u2013          <p>Dimensions of each subsystem in the composite system Hilbert space tensor product. Defaults to <code>None</code> (<code>x.dims</code> if available, single Hilbert space <code>dims=(n,)</code> otherwise).</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout. If <code>None</code>, the default layout is <code>dq.dense</code>, except for qarrays that are directly returned.</p> </li> <li> <code>offsets</code>         \u2013          <p>Offsets of the stored diagonals if <code>layout==dq.dia</code>. If <code>None</code>, offsets are determined automatically from the matrix structure. This argument can also be explicitly specified to ensure compatibility with JAX transformations, which require static offset values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>Qarray representation of the input.</p> </li> </ul> See also <ul> <li><code>dq.isqarraylike()</code>: returns True if the input is     a qarray-like.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.asqarray([[1, 0], [0, -1]])\nQArray: shape=(2, 2), dims=(2,), dtype=int32, layout=dense\n[[ 1  0]\n [ 0 -1]]\n&gt;&gt;&gt; dq.asqarray([[1, 0], [0, -1]], layout=dq.dia)\nQArray: shape=(2, 2), dims=(2,), dtype=int32, layout=dia, ndiags=1\n[[ 1  \u22c5]\n [ \u22c5 -1]]\n&gt;&gt;&gt; dq.asqarray([qt.sigmax(), qt.sigmay(), qt.sigmaz()])\nQArray: shape=(3, 2, 2), dims=(2,), dtype=complex64, layout=dense\n[[[ 0.+0.j  1.+0.j]\n  [ 1.+0.j  0.+0.j]]\n\n [[ 0.+0.j  0.-1.j]\n  [ 0.+1.j  0.+0.j]]\n\n [[ 1.+0.j  0.+0.j]\n  [ 0.+0.j -1.+0.j]]]\n</code></pre>"},{"location":"python_api/qarrays/utils/isqarraylike.html","title":"isqarraylike","text":""},{"location":"python_api/qarrays/utils/isqarraylike.html#dynamiqs.qarrays.utils.isqarraylike","title":"dq.isqarraylike","text":"<pre><code>isqarraylike(x: Any) -&gt; bool\n</code></pre> <p>Returns True if the input is a qarray-like.</p> <p>Parameters:</p> <ul> <li> <code>x</code>         \u2013          <p>Any object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>True if <code>x</code> is a numeric types (<code>bool</code>, <code>int</code>, <code>float</code>, <code>complex</code>), a NumPy or JAX array, a Dynamiqs qarray, a QuTiP qobj, or any nested sequence of these types.</p> </li> </ul> See also <ul> <li><code>dq.asqarray()</code>: converts a qarray-like into a qarray.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.isqarraylike(1)\nTrue\n&gt;&gt;&gt; dq.isqarraylike(qt.fock(5, 0))\nTrue\n&gt;&gt;&gt; dq.isqarraylike([qt.fock(5, 0), qt.fock(5, 1)])\nTrue\n</code></pre>"},{"location":"python_api/qarrays/utils/sparsedia_from_dict.html","title":"sparsedia_from_dict","text":""},{"location":"python_api/qarrays/utils/sparsedia_from_dict.html#dynamiqs.qarrays.utils.sparsedia_from_dict","title":"dq.sparsedia_from_dict","text":"<pre><code>sparsedia_from_dict(\n    offsets_diags: dict[int, ArrayLike],\n    dims: tuple[int, ...] | None = None,\n    dtype: DTypeLike | None = None,\n) -&gt; SparseDIAQArray\n</code></pre> <p>Initialize a <code>SparseDIAQArray</code> from a dictionary of offsets and diagonals.</p> <p>Parameters:</p> <ul> <li> <code>offsets_diags</code>         \u2013          <p>Dictionary where keys are offsets and values are diagonals of shapes (..., n-|offset|) with a common batch shape between all diagonals.</p> </li> <li> <code>dims</code>             (tuple of ints or None)         \u2013          <p>Dimensions of each subsystem in the composite system Hilbert space tensor product. Defaults to <code>None</code> (single Hilbert space <code>dims=(n,)</code>).</p> </li> <li> <code>dtype</code>         \u2013          <p>Data type of the qarray. If <code>None</code>, the data type is inferred from the diagonals.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>A <code>SparseDIAQArray</code> with non-zero diagonals at the specified offsets.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.sparsedia_from_dict({0: [1, 2, 3], 1: [4, 5], -1: [6, 7]})\nQArray: shape=(3, 3), dims=(3,), dtype=int32, layout=dia, ndiags=3\n[[1 4 \u22c5]\n [6 2 5]\n [\u22c5 7 3]]\n&gt;&gt;&gt; dq.sparsedia_from_dict({0: jnp.ones((3, 2))})\nQArray: shape=(3, 2, 2), dims=(2,), dtype=float32, layout=dia, ndiags=1\n[[[1. \u22c5 ]\n  [ \u22c5 1.]]\n\n [[1. \u22c5 ]\n  [ \u22c5 1.]]\n\n [[1. \u22c5 ]\n  [ \u22c5 1.]]]\n</code></pre>"},{"location":"python_api/qarrays/utils/stack.html","title":"stack","text":""},{"location":"python_api/qarrays/utils/stack.html#dynamiqs.qarrays.utils.stack","title":"dq.stack","text":"<pre><code>stack(qarrays: Sequence[QArray], axis: int = 0) -&gt; QArray\n</code></pre> <p>Join a sequence of qarrays along a new axis.</p> Warning <p>All elements of the sequence <code>qarrays</code> must have identical types, shapes and <code>dims</code> attributes. Additionally, when stacking qarrays of type <code>SparseDIAQArray</code>, all elements must have identical <code>offsets</code> attributes.</p> <p>Parameters:</p> <ul> <li> <code>qarrays</code>         \u2013          <p>Qarrays to stack.</p> </li> <li> <code>axis</code>         \u2013          <p>Axis in the result along which the input qarrays are stacked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>Stacked qarray.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.stack([dq.fock(3, 0), dq.fock(3, 1)])\nQArray: shape=(2, 3, 1), dims=(3,), dtype=complex64, layout=dense\n[[[1.+0.j]\n  [0.+0.j]\n  [0.+0.j]]\n\n [[0.+0.j]\n  [1.+0.j]\n  [0.+0.j]]]\n</code></pre>"},{"location":"python_api/qarrays/utils/to_jax.html","title":"to_jax","text":""},{"location":"python_api/qarrays/utils/to_jax.html#dynamiqs.qarrays.utils.to_jax","title":"dq.to_jax","text":"<pre><code>to_jax(x: QArrayLike) -&gt; Array\n</code></pre> <p>Convert a qarray-like into a JAX array.</p> <p>Parameters:</p> <ul> <li> <code>x</code>         \u2013          <p>Object to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>JAX array.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.to_jax(dq.fock(3, 1))\nArray([[0.+0.j],\n       [1.+0.j],\n       [0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.to_jax([qt.sigmax(), qt.sigmay(), qt.sigmaz()])\nArray([[[ 0.+0.j,  1.+0.j],\n        [ 1.+0.j,  0.+0.j]],\n\n       [[ 0.+0.j,  0.-1.j],\n        [ 0.+1.j,  0.+0.j]],\n\n       [[ 1.+0.j,  0.+0.j],\n        [ 0.+0.j, -1.+0.j]]], dtype=complex64)\n</code></pre>"},{"location":"python_api/qarrays/utils/to_numpy.html","title":"to_numpy","text":""},{"location":"python_api/qarrays/utils/to_numpy.html#dynamiqs.qarrays.utils.to_numpy","title":"dq.to_numpy","text":"<pre><code>to_numpy(x: QArrayLike) -&gt; np.ndarray\n</code></pre> <p>Convert a qarray-like into a NumPy array.</p> <p>Parameters:</p> <ul> <li> <code>x</code>         \u2013          <p>Object to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>NumPy array.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.to_numpy(dq.fock(3, 1))\narray([[0.+0.j],\n       [1.+0.j],\n       [0.+0.j]], dtype=complex64)\n&gt;&gt;&gt; dq.to_numpy([qt.sigmax(), qt.sigmay(), qt.sigmaz()])\narray([[[ 0.+0.j,  1.+0.j],\n        [ 1.+0.j,  0.+0.j]],\n\n       [[ 0.+0.j,  0.-1.j],\n        [ 0.+1.j,  0.+0.j]],\n\n       [[ 1.+0.j,  0.+0.j],\n        [ 0.+0.j, -1.+0.j]]])\n</code></pre>"},{"location":"python_api/qarrays/utils/to_qutip.html","title":"to_qutip","text":""},{"location":"python_api/qarrays/utils/to_qutip.html#dynamiqs.qarrays.utils.to_qutip","title":"dq.to_qutip","text":"<pre><code>to_qutip(x: QArrayLike, dims: tuple[int, ...] | None = None) -&gt; Qobj | list[Qobj]\n</code></pre> <p>Convert a qarray-like into a QuTiP Qobj or list of Qobjs.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n) or (..., n, n))         \u2013          <p>Ket, bra, density matrix or operator.</p> </li> <li> <code>dims</code>             (tuple of ints or None)         \u2013          <p>Dimensions of each subsystem in the composite system Hilbert space tensor product. Defaults to <code>None</code> (<code>x.dims</code> if available, single Hilbert space <code>dims=(n,)</code> otherwise).</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>QuTiP Qobj or list of QuTiP Qobj.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.fock(3, 1)\nQArray: shape=(3, 1), dims=(3,), dtype=complex64, layout=dense\n[[0.+0.j]\n [1.+0.j]\n [0.+0.j]]\n&gt;&gt;&gt; dq.to_qutip(dq.fock(3, 1))\nQuantum object: dims=[[3], [1]], shape=(3, 1), type='ket', dtype=Dense\nQobj data =\n[[0.]\n [1.]\n [0.]]\n</code></pre> <p>For a batched qarray:</p> <pre><code>&gt;&gt;&gt; rhos = dq.stack([dq.coherent_dm(16, i) for i in range(5)])\n&gt;&gt;&gt; rhos.shape\n(5, 16, 16)\n&gt;&gt;&gt; len(dq.to_qutip(rhos))\n5\n</code></pre> <p>Note that the tensor product structure is inferred automatically for qarrays. It can be specified with the <code>dims</code> argument for other types.</p> <pre><code>&gt;&gt;&gt; dq.to_qutip(dq.eye(3, 2))\nQuantum object: dims=[[3, 2], [3, 2]], shape=(6, 6), type='oper', dtype=Dense, isherm=True\nQobj data =\n[[1. 0. 0. 0. 0. 0.]\n [0. 1. 0. 0. 0. 0.]\n [0. 0. 1. 0. 0. 0.]\n [0. 0. 0. 1. 0. 0.]\n [0. 0. 0. 0. 1. 0.]\n [0. 0. 0. 0. 0. 1.]]\n</code></pre>"},{"location":"python_api/random/complex.html","title":"complex","text":""},{"location":"python_api/random/complex.html#dynamiqs.random.complex","title":"dq.random.complex","text":"<pre><code>complex(key: PRNGKeyArray, shape: int | tuple[int, ...], *, rmax: float = 1.0) -&gt; Array\n</code></pre> <p>Returns an array of uniformly distributed random complex numbers.</p> <p>Each element of the returned array is sampled uniformly in the disk of radius \\(\\text{rmax}\\).</p> Uniform sampling in the complex plane <p>Here are three common options to generate random complex numbers, <code>dq.random.complex()</code> returns the last one:</p> <pre><code>_, (ax0, ax1, ax2) = dq.plot.grid(3, sharexy=True)\nax0.set(xlim=(-1.1, 1.1), ylim=(-1.1, 1.1))\n\nn = 10_000\n\n# option 1: uniformly distributed real and imaginary part\nx = np.random.rand(n) * 2 - 1 + 1j * (np.random.rand(n) * 2 - 1)\nax0.scatter(x.real, x.imag, s=1.0)\n\n# option 2: uniformly distributed magnitude and phase\nx = np.random.rand(n) * jnp.exp(1j * 2 * jnp.pi * np.random.rand(n))\nax1.scatter(x.real, x.imag, s=1.0)\n\n# option 3: uniformly distributed in a disk (in Dynamiqs)\nkey = jax.random.PRNGKey(42)\nx = dq.random.complex(key, n)\nax2.scatter(x.real, x.imag, s=1.0)\nrenderfig('random_complex')\n</code></pre> <p></p> <p>Parameters:</p> <ul> <li> <code>key</code>         \u2013          <p>A PRNG key used as the random key.</p> </li> <li> <code>shape</code>             (int or tuple of ints)         \u2013          <p>Shape of the returned array.</p> </li> <li> <code>rmax</code>         \u2013          <p>Maximum magnitude.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (*shape))           \u2013          <p>Random complex number array.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.complex(key, (2, 3), rmax=5.0)\nArray([[ 1.617+0.307j,  0.078+2.351j, -0.817+3.812j],\n       [-4.221-0.581j, -3.044+2.898j, -0.668+4.552j]], dtype=complex64)\n</code></pre>"},{"location":"python_api/random/dm.html","title":"dm","text":""},{"location":"python_api/random/dm.html#dynamiqs.random.dm","title":"dq.random.dm","text":"<pre><code>dm(key: PRNGKeyArray, shape: tuple[int, ...]) -&gt; QArray\n</code></pre> <p>Returns a random density matrix (hermitian, positive semi-definite, and unit trace).</p> <p>Parameters:</p> <ul> <li> <code>key</code>         \u2013          <p>A PRNG key used as the random key.</p> </li> <li> <code>shape</code>             (shape of the form (..., n, n))         \u2013          <p>Shape of the returned qarray.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (*shape))           \u2013          <p>Random density matrix.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.dm(key, (2, 2))\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[ 0.198+0.j    -0.044-0.392j]\n [-0.044+0.392j  0.802+0.j   ]]\n</code></pre>"},{"location":"python_api/random/herm.html","title":"herm","text":""},{"location":"python_api/random/herm.html#dynamiqs.random.herm","title":"dq.random.herm","text":"<pre><code>herm(key: PRNGKeyArray, shape: tuple[int, ...]) -&gt; QArray\n</code></pre> <p>Returns a random complex Hermitian matrix.</p> <p>Parameters:</p> <ul> <li> <code>key</code>         \u2013          <p>A PRNG key used as the random key.</p> </li> <li> <code>shape</code>             (shape of the form (..., n, n))         \u2013          <p>Shape of the returned qarray.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (*shape))           \u2013          <p>Random complex Hermitian matrix.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.herm(key, (2, 2))\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[ 0.323+0.j    -0.074-0.146j]\n [-0.074+0.146j -0.844+0.j   ]]\n</code></pre>"},{"location":"python_api/random/ket.html","title":"ket","text":""},{"location":"python_api/random/ket.html#dynamiqs.random.ket","title":"dq.random.ket","text":"<pre><code>ket(key: PRNGKeyArray, shape: tuple[int, ...]) -&gt; QArray\n</code></pre> <p>Returns a random ket with unit norm.</p> <p>Parameters:</p> <ul> <li> <code>key</code>         \u2013          <p>A PRNG key used as the random key.</p> </li> <li> <code>shape</code>             (shape of the form (..., n, 1))         \u2013          <p>Shape of the returned qarray.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (*shape))           \u2013          <p>Random ket.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.ket(key, (2, 1))\nQArray: shape=(2, 1), dims=(2,), dtype=complex64, layout=dense\n[[0.563+0.107j]\n [0.027+0.819j]]\n</code></pre>"},{"location":"python_api/random/psd.html","title":"psd","text":""},{"location":"python_api/random/psd.html#dynamiqs.random.psd","title":"dq.random.psd","text":"<pre><code>psd(key: PRNGKeyArray, shape: tuple[int, ...]) -&gt; QArray\n</code></pre> <p>Returns a random complex positive semi-definite matrix.</p> <p>Parameters:</p> <ul> <li> <code>key</code>         \u2013          <p>A PRNG key used as the random key.</p> </li> <li> <code>shape</code>             (shape of the form (..., n, n))         \u2013          <p>Shape of the returned qarray.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (*shape))           \u2013          <p>Random complex positive semi-definite matrix.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.psd(key, (2, 2))\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[ 0.33 +0.j    -0.074-0.652j]\n [-0.074+0.652j  1.334+0.j   ]]\n</code></pre>"},{"location":"python_api/random/real.html","title":"real","text":""},{"location":"python_api/random/real.html#dynamiqs.random.real","title":"dq.random.real","text":"<pre><code>real(\n    key: PRNGKeyArray,\n    shape: int | tuple[int, ...],\n    *,\n    min: float = 0.0,\n    max: float = 1.0\n) -&gt; Array\n</code></pre> <p>Returns an array of uniformly distributed random real numbers.</p> <p>Each element of the returned array is sampled uniformly in \\([\\text{min}, \\text{max})\\).</p> <p>Parameters:</p> <ul> <li> <code>key</code>         \u2013          <p>A PRNG key used as the random key.</p> </li> <li> <code>shape</code>             (int or tuple of ints)         \u2013          <p>Shape of the returned array.</p> </li> <li> <code>min</code>         \u2013          <p>Minimum (inclusive) value.</p> </li> <li> <code>max</code>         \u2013          <p>Maximum (exclusive) value.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (*shape))           \u2013          <p>Random real number array.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; key = jax.random.PRNGKey(42)\n&gt;&gt;&gt; dq.random.real(key, (2, 5), max=5.0)\nArray([[2.444, 3.399, 3.081, 2.805, 2.253],\n       [2.929, 0.374, 3.876, 3.495, 4.093]], dtype=float32)\n</code></pre>"},{"location":"python_api/time_qarray/TimeQArray.html","title":"TimeQArray","text":""},{"location":"python_api/time_qarray/TimeQArray.html#dynamiqs.time_qarray.TimeQArray","title":"dq.TimeQArray","text":"<pre><code>TimeQArray(*, tstart: float | None = None, tend: float | None = None)\n</code></pre> <p>Base class for time-dependent qarrays.</p> <p>A timeqarray is a callable object that returns a qarray for any time \\(t\\). It is used to define time-dependent operators for Dynamiqs solvers.</p> <p>Attributes:</p> <ul> <li> <code>dtype</code>             (numpy.dtype)         \u2013          <p>Data type.</p> </li> <li> <code>shape</code>             (tuple of int)         \u2013          <p>Shape.</p> </li> <li> <code>ndim</code>             (int)         \u2013          <p>Number of dimensions in the shape.</p> </li> <li> <code>layout</code>             (Layout)         \u2013          <p>Data layout, either <code>dq.dense</code> or <code>dq.dia</code>.</p> </li> <li> <code>dims</code>             (tuple of ints)         \u2013          <p>Hilbert space dimension of each subsystem.</p> </li> <li> <code>mT</code>             (timeqarray)         \u2013          <p>Returns the timeqarray transposed over its last two dimensions.</p> </li> <li> <code>vectorized</code>             (bool)         \u2013          <p>Whether the underlying qarray is non-vectorized (ket, bra or operator) or vectorized (operator in vector form or superoperator in matrix form).</p> </li> <li> <code>tstart</code>             (float | None)         \u2013          <p>The returned qarray is null for all times \\(t &lt; t_{start}\\) (ignored if <code>None</code>).</p> </li> <li> <code>tend</code>             (float | None)         \u2013          <p>The returned qarray is null for all times \\(t \\geq t_{end}\\) (ignored if <code>None</code>).</p> </li> <li> <code>discontinuity_ts</code>             (Array)         \u2013          <p>Times at which there is a discontinuous jump in the timeqarray values (the array is always sorted, but does not necessarily contain unique values).</p> </li> </ul> Arithmetic operation support <p>Timeqarrays support basic arithmetic operations <code>-, +, *</code> with other qarray-likes or timeqarrays.</p>"},{"location":"python_api/time_qarray/TimeQArray.html#dynamiqs.time_qarray.TimeQArray.clip","title":"TimeQArray.clip","text":"<pre><code>clip(tstart: float | None, tend: float | None) -&gt; TimeQArray\n</code></pre> <p>Set the start and/or end time beyond which the returned qarray is null.</p> <p>Parameters:</p> <ul> <li> <code>tstart</code>         \u2013          <p>The returned qarray is null for all times \\(t &lt; t_{start}\\) (ignored if <code>None</code>).</p> </li> <li> <code>tend</code>         \u2013          <p>The returned qarray is null for all times \\(t \\geq t_{end}\\) (ignored if <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>New timeqarray with the given time bounds.</p> </li> </ul>"},{"location":"python_api/time_qarray/TimeQArray.html#dynamiqs.time_qarray.TimeQArray.reshape","title":"TimeQArray.reshape","text":"<pre><code>reshape(*shape: int) -&gt; TimeQArray\n</code></pre> <p>Returns a reshaped copy of a timeqarray.</p> <p>Parameters:</p> <ul> <li> <code>*shape</code>         \u2013          <p>New shape, which must match the original size.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>New timeqarray with the given shape.</p> </li> </ul>"},{"location":"python_api/time_qarray/TimeQArray.html#dynamiqs.time_qarray.TimeQArray.broadcast_to","title":"TimeQArray.broadcast_to","text":"<pre><code>broadcast_to(*shape: int) -&gt; TimeQArray\n</code></pre> <p>Broadcasts a timeqarray to a new shape.</p> <p>Parameters:</p> <ul> <li> <code>*shape</code>         \u2013          <p>New shape, which must be compatible with the original shape.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>New timeqarray with the given shape.</p> </li> </ul>"},{"location":"python_api/time_qarray/TimeQArray.html#dynamiqs.time_qarray.TimeQArray.conj","title":"TimeQArray.conj","text":"<pre><code>conj() -&gt; TimeQArray\n</code></pre> <p>Returns the element-wise complex conjugate of the timeqarray.</p> <p>Returns:</p> <ul> <li> <p>New timeqarray with element-wise complex conjuguated values.</p> </li> </ul>"},{"location":"python_api/time_qarray/TimeQArray.html#dynamiqs.time_qarray.TimeQArray.dag","title":"TimeQArray.dag","text":"<pre><code>dag() -&gt; TimeQArray\n</code></pre> <p>Returns the adjoint (complex conjugate transpose) of the timeqarray.</p> <p>Returns:</p> <ul> <li> <p>New timeqarray with adjoint values.</p> </li> </ul>"},{"location":"python_api/time_qarray/TimeQArray.html#dynamiqs.time_qarray.TimeQArray.squeeze","title":"TimeQArray.squeeze","text":"<pre><code>squeeze(axis: int | None = None) -&gt; TimeQArray\n</code></pre> <p>Squeezes a timeqarray.</p> <p>Parameters:</p> <ul> <li> <code>axis</code>         \u2013          <p>Axis to squeeze. If <code>None</code>, all axes with dimension 1 are squeezed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>New timeqarray with squeezed shape.</p> </li> </ul>"},{"location":"python_api/time_qarray/TimeQArray.html#dynamiqs.time_qarray.TimeQArray.prefactor","title":"TimeQArray.prefactor","text":"<pre><code>prefactor(ts: ArrayLike) -&gt; Array\n</code></pre> <p>Returns the timeqarray prefactor at specific times.</p> <p>Parameters:</p> <ul> <li> <code>ts</code>             (array-like of shape (...))         \u2013          <p>Times at which to evaluate the prefactor.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Prefactor values at times <code>ts</code>.</p> </li> </ul>"},{"location":"python_api/time_qarray/constant.html","title":"constant","text":""},{"location":"python_api/time_qarray/constant.html#dynamiqs.time_qarray.constant","title":"dq.constant","text":"<pre><code>constant(qarray: QArrayLike) -&gt; ConstantTimeQArray\n</code></pre> <p>Instantiate a constant timeqarray.</p> <p>A constant timeqarray is defined by \\(O(t) = O_0\\) for any time \\(t\\), where \\(O_0\\) is a constant qarray.</p> <p>Parameters:</p> <ul> <li> <code>qarray</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Constant qarray \\(O_0\\).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (timeqarray of shape (..., n, n) when called)           \u2013          <p>Callable returning \\(O_0\\) for any time \\(t\\).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; H = dq.constant(dq.sigmaz())\n&gt;&gt;&gt; H(0.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[ 1.+0.j    \u22c5   ]\n [   \u22c5    -1.+0.j]]\n&gt;&gt;&gt; H(1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[ 1.+0.j    \u22c5   ]\n [   \u22c5    -1.+0.j]]\n</code></pre>"},{"location":"python_api/time_qarray/modulated.html","title":"modulated","text":""},{"location":"python_api/time_qarray/modulated.html#dynamiqs.time_qarray.modulated","title":"dq.modulated","text":"<pre><code>modulated(\n    f: callable[[float], Scalar | Array],\n    qarray: QArrayLike,\n    *,\n    discontinuity_ts: ArrayLike | None = None\n) -&gt; ModulatedTimeQArray\n</code></pre> <p>Instantiate a modulated timeqarray.</p> <p>A modulated timeqarray is defined by \\(O(t) = f(t) O_0\\) where \\(f(t)\\) is a time-dependent scalar. The function \\(f\\) is defined by passing a Python function with signature <code>f(t: float) -&gt; Scalar | Array</code> that returns a scalar or an array of shape (...) for any time \\(t\\).</p> <p>Parameters:</p> <ul> <li> <code>f</code>             (function returning scalar or array of shape (...))         \u2013          <p>Function with signature <code>f(t: float) -&gt; Scalar | Array</code> that returns the modulating factor \\(f(t)\\).</p> </li> <li> <code>qarray</code>             (qarray-like of shape (n, n))         \u2013          <p>Constant qarray \\(O_0\\).</p> </li> <li> <code>discontinuity_ts</code>         \u2013          <p>Times at which there is a discontinuous jump in the function values.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (timeqarray of shape (..., n, n) when called)           \u2013          <p>Callable returning \\(O(t)\\) for any time \\(t\\).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = lambda t: jnp.cos(2.0 * jnp.pi * t)\n&gt;&gt;&gt; H = dq.modulated(f, dq.sigmax())\n&gt;&gt;&gt; H(0.5)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n[[   \u22c5    -1.+0.j]\n [-1.+0.j    \u22c5   ]]\n&gt;&gt;&gt; H(1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n[[  \u22c5    1.+0.j]\n [1.+0.j   \u22c5   ]]\n</code></pre>"},{"location":"python_api/time_qarray/pwc.html","title":"pwc","text":""},{"location":"python_api/time_qarray/pwc.html#dynamiqs.time_qarray.pwc","title":"dq.pwc","text":"<pre><code>pwc(times: ArrayLike, values: ArrayLike, qarray: QArrayLike) -&gt; PWCTimeQArray\n</code></pre> <p>Instantiate a piecewise constant (PWC) timeqarray.</p> <p>A PWC timeqarray takes constant values over some time intervals. It is defined by $$     O(t) = \\left(\\sum_{k=0}^{N-1} c_k\\; \\Omega_{[t_k, t_{k+1}[}(t)\\right) O_0 $$ where \\(c_k\\) are constant values, \\(\\Omega_{[t_k, t_{k+1}[}\\) is the rectangular window function defined by \\(\\Omega_{[t_a, t_b[}(t) = 1\\) if \\(t \\in [t_a, t_b[\\) and \\(\\Omega_{[t_a, t_b[}(t) = 0\\) otherwise, and \\(O_0\\) is a constant qarray.</p> Note <p>The argument <code>times</code> must be sorted in ascending order, but does not need to be evenly spaced.</p> Note <p>If the returned timeqarray is called for a time \\(t\\) which does not belong to any time intervals, the returned qarray is null.</p> <p>Parameters:</p> <ul> <li> <code>times</code>             (array-like of shape (N+1,))         \u2013          <p>Time points \\(t_k\\) defining the boundaries of the time intervals, where N is the number of time intervals.</p> </li> <li> <code>values</code>             (array-like of shape (..., N))         \u2013          <p>Constant values \\(c_k\\) for each time interval.</p> </li> <li> <code>qarray</code>             (qarray-like of shape (n, n))         \u2013          <p>Constant qarray \\(O_0\\).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (timeqarray of shape (..., n, n) when called)           \u2013          <p>Callable returning \\(O(t)\\) for any time \\(t\\).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; times = [0.0, 1.0, 2.0]\n&gt;&gt;&gt; values = [3.0, -2.0]\n&gt;&gt;&gt; qarray = dq.sigmaz()\n&gt;&gt;&gt; H = dq.pwc(times, values, qarray)\n&gt;&gt;&gt; H(-0.5)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5      \u22c5   ]\n [  \u22c5      \u22c5   ]]\n&gt;&gt;&gt; H(0.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[ 3.+0.j    \u22c5   ]\n [   \u22c5    -3.+0.j]]\n&gt;&gt;&gt; H(0.5)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[ 3.+0.j    \u22c5   ]\n [   \u22c5    -3.+0.j]]\n&gt;&gt;&gt; H(1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[-2.+0.j    \u22c5   ]\n [   \u22c5     2.+0.j]]\n</code></pre>"},{"location":"python_api/time_qarray/timecallable.html","title":"timecallable","text":""},{"location":"python_api/time_qarray/timecallable.html#dynamiqs.time_qarray.timecallable","title":"dq.timecallable","text":"<pre><code>timecallable(\n    f: callable[[float], QArray], *, discontinuity_ts: ArrayLike | None = None\n) -&gt; CallableTimeQArray\n</code></pre> <p>Instantiate a callable timeqarray.</p> <p>A callable timeqarray is defined by \\(O(t) = f(t)\\) where \\(f(t)\\) is a time-dependent operator. The function \\(f\\) is defined by passing a Python function with signature <code>f(t: float) -&gt; QArray</code> that returns a qarray of shape (..., n, n) for any time \\(t\\).</p> The function <code>f</code> must return a qarray (not a qarray-like!) <p>An error is raised if the function <code>f</code> does not return a qarray. This error concerns any other qarray-likes. This is enforced to avoid costly conversions at every time step of the numerical integration.</p> <p>Parameters:</p> <ul> <li> <code>f</code>             (function returning qarray of shape (..., n, n))         \u2013          <p>Function with signature <code>(t: float) -&gt; QArray</code> that returns the qarray \\(f(t)\\).</p> </li> <li> <code>discontinuity_ts</code>         \u2013          <p>Times at which there is a discontinuous jump in the function values.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (timeqarray of shape (..., n, n) when called)           \u2013          <p>Callable returning \\(O(t)\\) for any time \\(t\\).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; f = lambda t: dq.asqarray([[t, 0], [0, 1 - t]])\n&gt;&gt;&gt; H = dq.timecallable(f)\n&gt;&gt;&gt; H(0.5)\nQArray: shape=(2, 2), dims=(2,), dtype=float32, layout=dense\n[[0.5 0. ]\n [0.  0.5]]\n&gt;&gt;&gt; H(1.0)\nQArray: shape=(2, 2), dims=(2,), dtype=float32, layout=dense\n[[1. 0.]\n [0. 0.]]\n</code></pre>"},{"location":"python_api/utils/general/bloch_coordinates.html","title":"bloch_coordinates","text":""},{"location":"python_api/utils/general/bloch_coordinates.html#dynamiqs.utils.general.bloch_coordinates","title":"dq.bloch_coordinates","text":"<pre><code>bloch_coordinates(x: QArrayLike) -&gt; Array\n</code></pre> <p>Returns the spherical coordinates \\((r, \\theta, \\phi)\\) of a ket or density matrix on the Bloch sphere.</p> <p>The coordinates are such that $$     \\begin{cases}         0\\leq r \\leq 1, \\\\         0\\leq\\theta\\leq\\pi, \\\\         0\\leq\\phi&lt;2\\pi.     \\end{cases} $$</p> <p>By convention, we choose \\(\\phi=0\\) if \\(\\theta=0\\), and \\(\\theta=\\phi=0\\) if \\(r=0\\).</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (2, 1) or (2, 2))         \u2013          <p>Ket or density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (3,))           \u2013          <p>Spherical coordinates \\((r, \\theta, \\phi)\\).</p> </li> </ul> <p>Examples:</p> <p>The state \\(\\ket0\\) is on the north pole at coordinates \\((r,\\theta,\\phi) = (1,0,0)\\):</p> <pre><code>&gt;&gt;&gt; x = dq.basis(2, 0)\n&gt;&gt;&gt; dq.bloch_coordinates(x)\nArray([1., 0., 0.], dtype=float32)\n</code></pre> <p>The state \\(\\ket1\\) is on the south pole at coordinates \\((r,\\theta,\\phi) = (1,\\pi,0)\\):</p> <pre><code>&gt;&gt;&gt; x = dq.basis(2, 1)\n&gt;&gt;&gt; dq.bloch_coordinates(x)\nArray([1.   , 3.142, 0.   ], dtype=float32)\n</code></pre> <p>The state \\(\\ket+=(\\ket0+\\ket1)/\\sqrt2\\) is aligned with the \\(x\\)-axis at coordinates \\((r,\\theta,\\phi) = (1,\\pi/2,0)\\):</p> <pre><code>&gt;&gt;&gt; plus = dq.unit(dq.basis(2, 0) + dq.basis(2, 1))\n&gt;&gt;&gt; dq.bloch_coordinates(plus)\nArray([1.   , 1.571, 0.   ], dtype=float32)\n</code></pre> <p>The state \\(\\ket-=(\\ket0-\\ket1)/\\sqrt2\\) is aligned with the \\(-x\\)-axis at coordinates \\((r,\\theta,\\phi) = (1,\\pi/2,\\pi)\\):</p> <pre><code>&gt;&gt;&gt; minus = dq.unit(dq.basis(2, 0) - dq.basis(2, 1))\n&gt;&gt;&gt; dq.bloch_coordinates(minus)\nArray([1.   , 1.571, 3.142], dtype=float32)\n</code></pre> <p>A fully mixed state \\(\\rho=0.5\\ket0\\bra0+0.5\\ket1\\bra1\\) is at the center of the sphere at coordinates \\((r,\\theta,\\phi) = (0,0,0)\\):</p> <pre><code>&gt;&gt;&gt; x = 0.5 * dq.basis_dm(2, 0) + 0.5 * dq.basis_dm(2, 1)\n&gt;&gt;&gt; dq.bloch_coordinates(x)\nArray([0., 0., 0.], dtype=float32)\n</code></pre> <p>A partially mixed state \\(\\rho=0.75\\ket0\\bra0 + 0.25\\ket1\\bra1\\) is halfway between the sphere center and the north pole at coordinates \\((r,\\theta,\\phi) = (0.5,0,0)\\):</p> <pre><code>&gt;&gt;&gt; x = 0.75 * dq.basis_dm(2, 0) + 0.25 * dq.basis_dm(2, 1)\n&gt;&gt;&gt; dq.bloch_coordinates(x)\nArray([0.5, 0. , 0. ], dtype=float32)\n</code></pre>"},{"location":"python_api/utils/general/braket.html","title":"braket","text":""},{"location":"python_api/utils/general/braket.html#dynamiqs.utils.general.braket","title":"dq.braket","text":"<pre><code>braket(x: QArrayLike, y: QArrayLike) -&gt; Array\n</code></pre> <p>Returns the inner product \\(\\braket{\\psi|\\varphi}\\) between two kets.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1))         \u2013          <p>Left-side ket.</p> </li> <li> <code>y</code>             (qarray-like of shape (..., n, 1))         \u2013          <p>Right-side ket.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Complex-valued inner product.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fock0 = dq.fock(3, 0)\n&gt;&gt;&gt; fock01 = (dq.fock(3, 0) + dq.fock(3, 1)).unit()\n&gt;&gt;&gt; dq.braket(fock0, fock01)\nArray(0.707+0.j, dtype=complex64)\n</code></pre>"},{"location":"python_api/utils/general/cosm.html","title":"cosm","text":""},{"location":"python_api/utils/general/cosm.html#dynamiqs.utils.general.cosm","title":"dq.cosm","text":"<pre><code>cosm(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the cosine of a qarray.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Square matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Cosine of <code>x</code>.</p> </li> </ul> Note <p>This function uses <code>jax.scipy.linalg.expm()</code> to compute the cosine of a matrix \\(A\\): $$     \\cos(A) = \\frac{e^{iA} + e^{-iA}}{2} $$</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.cosm(jnp.pi * dq.sigmax())\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[-1.+0.j  0.+0.j]\n [ 0.+0.j -1.+0.j]]\n</code></pre>"},{"location":"python_api/utils/general/dag.html","title":"dag","text":""},{"location":"python_api/utils/general/dag.html#dynamiqs.utils.general.dag","title":"dq.dag","text":"<pre><code>dag(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the adjoint (complex conjugate transpose) of a matrix.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., m, n))         \u2013          <p>Matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, m))           \u2013          <p>Adjoint of <code>x</code>.</p> </li> </ul> Equivalent syntax <p>This function is equivalent to <code>x.mT.conj()</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.fock(2, 0)\nQArray: shape=(2, 1), dims=(2,), dtype=complex64, layout=dense\n[[1.+0.j]\n [0.+0.j]]\n&gt;&gt;&gt; dq.dag(dq.fock(2, 0))\nQArray: shape=(1, 2), dims=(2,), dtype=complex64, layout=dense\n[[1.-0.j 0.-0.j]]\n</code></pre>"},{"location":"python_api/utils/general/dissipator.html","title":"dissipator","text":""},{"location":"python_api/utils/general/dissipator.html#dynamiqs.utils.general.dissipator","title":"dq.dissipator","text":"<pre><code>dissipator(L: QArrayLike, rho: QArrayLike) -&gt; QArray\n</code></pre> <p>Applies the Lindblad dissipation superoperator to a density matrix.</p> <p>The dissipation superoperator \\(\\mathcal{D}[L]\\) is defined by: $$     \\mathcal{D}[L] (\\rho) = L\\rho L^\\dag - \\frac{1}{2}L^\\dag L \\rho     - \\frac{1}{2}\\rho L^\\dag L. $$</p> <p>Parameters:</p> <ul> <li> <code>L</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Jump operator.</p> </li> <li> <code>rho</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Resulting operator (it is not a density matrix).</p> </li> </ul> See also <ul> <li><code>dq.sdissipator()</code>: returns the dissipation     superoperator in matrix form (vectorized).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; L = dq.destroy(4)\n&gt;&gt;&gt; rho = dq.fock_dm(4, 2)\n&gt;&gt;&gt; dq.dissipator(L, rho)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dense\n[[ 0.+0.j  0.+0.j  0.+0.j  0.+0.j]\n [ 0.+0.j  2.+0.j  0.+0.j  0.+0.j]\n [ 0.+0.j  0.+0.j -2.+0.j  0.+0.j]\n [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j]]\n</code></pre>"},{"location":"python_api/utils/general/entropy_relative.html","title":"entropy_relative","text":""},{"location":"python_api/utils/general/entropy_relative.html#dynamiqs.utils.general.entropy_relative","title":"dq.entropy_relative","text":"<pre><code>entropy_relative(rho: QArrayLike, sigma: QArrayLike) -&gt; Array\n</code></pre> <p>Returns the quantum relative entropy between two kets or density matrices.</p> <p>It is defined by \\(S_{KL}(\\rho || \\sigma) = \\tr{\\rho (\\ln \\rho - \\ln \\sigma)}\\).</p> Note <p>The relative entropy is not symmetric.</p> <p>Parameters:</p> <ul> <li> <code>rho</code>             (qarray-like of shape (..., n, 1) or (..., n, n))         \u2013          <p>Ket or density matrix.</p> </li> <li> <code>sigma</code>             (qarray-like of shape (..., n, 1) or (..., n, n))         \u2013          <p>Ket or density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Real-valued quantum relative entropy.</p> </li> </ul> <p>Examples:</p> <p>State with respect to itself:</p> <pre><code>&gt;&gt;&gt; rho = dq.fock_dm(2, 0)  # |0&gt;&lt;0|\n&gt;&gt;&gt; dq.entropy_relative(rho, rho)\nArray(0., dtype=float32)\n</code></pre> <p>Pure state with respect to a maximally mixed state, and vice versa:</p> <pre><code>&gt;&gt;&gt; pure = dq.fock_dm(2, 0)  # |0&gt;&lt;0|\n&gt;&gt;&gt; maximally_mixed = (dq.fock_dm(2, 0) + dq.fock_dm(2, 1)).unit()  # I/2\n&gt;&gt;&gt; dq.entropy_relative(pure, maximally_mixed)  # ln 2 ~= 0.693\nArray(0.693, dtype=float32)\n&gt;&gt;&gt; dq.entropy_relative(maximally_mixed, pure)  # support mismatch -&gt; +\u221e\nArray(inf, dtype=float32)\n</code></pre> <p>Pure state with respect to diagonal state in same basis:</p> <pre><code>&gt;&gt;&gt; rho = dq.fock_dm(2, 0)  # |0&gt;&lt;0|\n&gt;&gt;&gt; w = 0.3\n&gt;&gt;&gt; sigma = w * dq.fock_dm(2, 0) + (1 - w) * dq.fock_dm(2, 1)\n&gt;&gt;&gt; dq.entropy_relative(rho, sigma)\nArray(1.204, dtype=float32)\n&gt;&gt;&gt; -jnp.log(w)\nArray(1.204, dtype=float32, weak_type=True)\n</code></pre> <p>Orthogonal pure states:</p> <pre><code>&gt;&gt;&gt; rho = dq.fock_dm(2, 1)  # |1&gt;&lt;1|\n&gt;&gt;&gt; sigma = dq.fock_dm(2, 0)  # |0&gt;&lt;0|\n&gt;&gt;&gt; dq.entropy_relative(rho, sigma)\nArray(inf, dtype=float32)\n</code></pre>"},{"location":"python_api/utils/general/entropy_vn.html","title":"entropy_vn","text":""},{"location":"python_api/utils/general/entropy_vn.html#dynamiqs.utils.general.entropy_vn","title":"dq.entropy_vn","text":"<pre><code>entropy_vn(x: QArrayLike) -&gt; Array\n</code></pre> <p>Returns the Von Neumann entropy of a ket or density matrix.</p> <p>It is defined by \\(S(\\rho) = -\\tr{\\rho \\ln \\rho}\\).</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., n, n))         \u2013          <p>Ket or density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Real-valued Von Neumann entropy.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rho = (dq.fock_dm(2, 0) + dq.fock_dm(2, 1)).unit()\n&gt;&gt;&gt; dq.entropy_vn(rho)\nArray(0.693, dtype=float32)\n&gt;&gt;&gt; psis = [dq.fock(16, i) for i in range(5)]\n&gt;&gt;&gt; dq.entropy_vn(psis).shape\n(5,)\n</code></pre>"},{"location":"python_api/utils/general/expect.html","title":"expect","text":""},{"location":"python_api/utils/general/expect.html#dynamiqs.utils.general.expect","title":"dq.expect","text":"<pre><code>expect(O: QArrayLike, x: QArrayLike) -&gt; Array\n</code></pre> <p>Returns the expectation value of an operator or list of operators on a ket, bra or density matrix.</p> <p>The expectation value \\(\\braket{O}\\) of an operator \\(O\\) is computed</p> <ul> <li>as \\(\\braket{O}=\\braket{\\psi|O|\\psi}\\) if <code>x</code> is a ket \\(\\ket\\psi\\) or bra \\(\\bra\\psi\\),</li> <li>as \\(\\braket{O}=\\tr{O\\rho}\\) if <code>x</code> is a density matrix \\(\\rho\\).</li> </ul> Warning <p>The returned array is complex-valued. If the operator \\(O\\) corresponds to a physical observable, it is Hermitian: \\(O^\\dag=O\\), and the expectation value is real. One can then keep only the real values of the returned array using <code>dq.expect(O, x).real</code>.</p> <p>Parameters:</p> <ul> <li> <code>O</code>             (qarray-like of shape (nO?, n, n))         \u2013          <p>Arbitrary operator or list of nO operators.</p> </li> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n) or (..., n, n))         \u2013          <p>Ket, bra or density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (nO?, ...))           \u2013          <p>Complex-valued expectation value.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; O = dq.number(16)\n&gt;&gt;&gt; psi = dq.coherent(16, 2.0)\n&gt;&gt;&gt; dq.expect(O, psi)\nArray(4.+0.j, dtype=complex64)\n&gt;&gt;&gt; psis = [dq.fock(16, i) for i in range(5)]\n&gt;&gt;&gt; dq.expect(O, psis).shape\n(5,)\n&gt;&gt;&gt; Os = [dq.position(16), dq.momentum(16)]\n&gt;&gt;&gt; dq.expect(Os, psis).shape\n(2, 5)\n</code></pre>"},{"location":"python_api/utils/general/expm.html","title":"expm","text":""},{"location":"python_api/utils/general/expm.html#dynamiqs.utils.general.expm","title":"dq.expm","text":"<pre><code>expm(x: QArrayLike, *, max_squarings: int = 16) -&gt; QArray\n</code></pre> <p>Returns the matrix exponential of a qarray.</p> <p>The exponential is computed using the scaling-and-squaring approximation method.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Square matrix.</p> </li> <li> <code>max_squarings</code>         \u2013          <p>Number of squarings.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Matrix exponential of <code>x</code>.</p> </li> </ul> Equivalent JAX syntax <p>This function is equivalent to <code>jnp.scipy.linalg.expm(x, max_squarings=max_squarings)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.expm(dq.sigmaz())\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[2.718+0.j 0.   +0.j]\n [0.   +0.j 0.368+0.j]]\n</code></pre>"},{"location":"python_api/utils/general/fidelity.html","title":"fidelity","text":""},{"location":"python_api/utils/general/fidelity.html#dynamiqs.utils.general.fidelity","title":"dq.fidelity","text":"<pre><code>fidelity(x: QArrayLike, y: QArrayLike) -&gt; Array\n</code></pre> <p>Returns the fidelity of two states, kets or density matrices.</p> <p>The fidelity is computed</p> <ul> <li>as \\(F(\\ket\\psi,\\ket\\varphi)=\\left|\\braket{\\psi|\\varphi}\\right|^2\\) if both   arguments are kets,</li> <li>as \\(F(\\ket\\psi,\\rho)=\\lvert\\braket{\\psi|\\rho|\\psi}\\rvert\\) if one arguments is a   ket and the other is a density matrix,</li> <li>as \\(F(\\rho,\\sigma)=\\tr{\\sqrt{\\sqrt\\rho\\sigma\\sqrt\\rho}}^2\\) if both arguments are   density matrices.</li> </ul> Warning <p>This definition is different from <code>qutip.fidelity()</code> which uses the square root fidelity \\(F_\\text{qutip} = \\sqrt{F}\\).</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., n, n))         \u2013          <p>Ket or density matrix.</p> </li> <li> <code>y</code>             (qarray-like of shape (..., n, 1) or (..., n, n))         \u2013          <p>Ket or density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Real-valued fidelity.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fock0 = dq.fock(3, 0)\n&gt;&gt;&gt; dq.fidelity(fock0, fock0)\nArray(1., dtype=float32)\n&gt;&gt;&gt; fock01_dm = 0.5 * (dq.fock_dm(3, 1) + dq.fock_dm(3, 0))\n&gt;&gt;&gt; dq.fidelity(fock01_dm, fock01_dm)\nArray(1., dtype=float32)\n&gt;&gt;&gt; dq.fidelity(fock0, fock01_dm)\nArray(0.5, dtype=float32)\n</code></pre>"},{"location":"python_api/utils/general/isbra.html","title":"isbra","text":""},{"location":"python_api/utils/general/isbra.html#dynamiqs.utils.general.isbra","title":"dq.isbra","text":"<pre><code>isbra(x: QArrayLike) -&gt; bool\n</code></pre> <p>Returns True if the qarray is in the format of a bra.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (...))         \u2013          <p>Qarray-like.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>True if the second to last dimension of <code>x</code> is 1, False otherwise.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.isbra(jnp.ones((1, 3)))\nTrue\n&gt;&gt;&gt; dq.isbra(jnp.ones((5, 1, 3)))\nTrue\n&gt;&gt;&gt; dq.isbra(jnp.ones((3, 3)))\nFalse\n</code></pre>"},{"location":"python_api/utils/general/isdm.html","title":"isdm","text":""},{"location":"python_api/utils/general/isdm.html#dynamiqs.utils.general.isdm","title":"dq.isdm","text":"<pre><code>isdm(x: QArrayLike) -&gt; bool\n</code></pre> <p>Returns True if the qarray is in the format of a density matrix.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (...))         \u2013          <p>Qarray-like.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>True if the last two dimensions of <code>x</code> are equal, False otherwise.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.isdm(jnp.ones((3, 3)))\nTrue\n&gt;&gt;&gt; dq.isdm(jnp.ones((5, 3, 3)))\nTrue\n&gt;&gt;&gt; dq.isdm(jnp.ones((3, 1)))\nFalse\n</code></pre>"},{"location":"python_api/utils/general/isherm.html","title":"isherm","text":""},{"location":"python_api/utils/general/isherm.html#dynamiqs.utils.general.isherm","title":"dq.isherm","text":"<pre><code>isherm(x: QArrayLike, rtol: float = 1e-05, atol: float = 1e-08) -&gt; bool\n</code></pre> <p>Returns True if the qarray is Hermitian.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Qarray-like.</p> </li> <li> <code>rtol</code>         \u2013          <p>Relative tolerance of the check.</p> </li> <li> <code>atol</code>         \u2013          <p>Absolute tolerance of the check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>True if <code>x</code> is Hermitian, False otherwise.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.isherm(jnp.eye(3))\nArray(True, dtype=bool)\n&gt;&gt;&gt; dq.isherm([[0, 1j], [1j, 0]])\nArray(False, dtype=bool)\n</code></pre>"},{"location":"python_api/utils/general/isket.html","title":"isket","text":""},{"location":"python_api/utils/general/isket.html#dynamiqs.utils.general.isket","title":"dq.isket","text":"<pre><code>isket(x: QArrayLike) -&gt; bool\n</code></pre> <p>Returns True if the qarray is in the format of a ket.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (...))         \u2013          <p>Qarray-like.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>True if the last dimension of <code>x</code> is 1, False otherwise.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.isket(jnp.ones((3, 1)))\nTrue\n&gt;&gt;&gt; dq.isket(jnp.ones((5, 3, 1)))\nTrue\n&gt;&gt;&gt; dq.isket(jnp.ones((3, 3)))\nFalse\n</code></pre>"},{"location":"python_api/utils/general/isop.html","title":"isop","text":""},{"location":"python_api/utils/general/isop.html#dynamiqs.utils.general.isop","title":"dq.isop","text":"<pre><code>isop(x: QArrayLike) -&gt; bool\n</code></pre> <p>Returns True if the qarray is in the format of an operator.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (...))         \u2013          <p>Qarray-like.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>True if the last two dimensions of <code>x</code> are equal, False otherwise.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.isop(jnp.ones((3, 3)))\nTrue\n&gt;&gt;&gt; dq.isop(jnp.ones((5, 3, 3)))\nTrue\n&gt;&gt;&gt; dq.isop(jnp.ones((3, 1)))\nFalse\n</code></pre>"},{"location":"python_api/utils/general/lindbladian.html","title":"lindbladian","text":""},{"location":"python_api/utils/general/lindbladian.html#dynamiqs.utils.general.lindbladian","title":"dq.lindbladian","text":"<pre><code>lindbladian(H: QArrayLike, jump_ops: list[QArrayLike], rho: QArrayLike) -&gt; QArray\n</code></pre> <p>Applies the Lindbladian superoperator to a density matrix.</p> <p>The Lindbladian superoperator \\(\\mathcal{L}\\) is defined by: $$     \\mathcal{L} (\\rho) = -i[H,\\rho] + \\sum_{k=1}^N \\mathcal{D}[L_k] (\\rho), $$</p> <p>where \\(H\\) is the system Hamiltonian, \\(\\{L_k\\}\\) is a set of \\(N\\) jump operators (arbitrary operators) and \\(\\mathcal{D}[L]\\) is the Lindblad dissipation superoperator (see <code>dq.dissipator()</code>).</p> Note <p>This superoperator is also sometimes called Liouvillian.</p> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>jump_ops</code>             (list of qarray-like, each of shape (, ..., n, n))         \u2013          <p>List of jump operators.</p> </li> <li> <code>rho</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Resulting operator (it is not a density matrix).</p> </li> </ul> See also <ul> <li><code>dq.slindbladian()</code>: returns the Lindbladian     superoperator in matrix form (vectorized).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = dq.destroy(4)\n&gt;&gt;&gt; H = a.dag() @ a\n&gt;&gt;&gt; L = [a, a.dag() @ a]\n&gt;&gt;&gt; rho = dq.fock_dm(4, 1)\n&gt;&gt;&gt; dq.lindbladian(H, L, rho)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dense\n[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]\n [ 0.+0.j -1.+0.j  0.+0.j  0.+0.j]\n [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j]\n [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j]]\n</code></pre>"},{"location":"python_api/utils/general/norm.html","title":"norm","text":""},{"location":"python_api/utils/general/norm.html#dynamiqs.utils.general.norm","title":"dq.norm","text":"<pre><code>norm(x: QArrayLike, *, psd: bool = False) -&gt; Array\n</code></pre> <p>Returns the norm of a ket, bra, density matrix, or Hermitian matrix.</p> <p>For a ket or a bra, the returned norm is \\(\\sqrt{\\braket{\\psi|\\psi}}\\). For a Hermitian matrix, the returned norm is the trace norm defined by: $$     \\|A\\|_1 = \\tr{\\sqrt{A^\\dag A}} = \\sum_i |\\lambda_i| $$ where \\(\\lambda_i\\) are the eigenvalues of \\(A\\). If \\(A\\) is positive semi-definite (set <code>psd=True</code>), for example for a density matrix, the expression reduces to \\(\\|A\\|_1 =\\tr{A}\\).</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n) or (..., n, n))         \u2013          <p>Ket, bra, density matrix, or Hermitian matrix.</p> </li> <li> <code>psd</code>         \u2013          <p>Whether <code>x</code> is a positive semi-definite matrix. If <code>True</code>, returns the trace of <code>x</code>, otherwise computes the eigenvalues of <code>x</code> to evaluate the norm.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Real-valued norm of <code>x</code>.</p> </li> </ul> See also <ul> <li><code>dq.unit()</code>: normalize a ket, bra, density matrix, or     Hermitian matrix to unit norm.</li> </ul> <p>Examples:</p> <p>For a ket:</p> <pre><code>&gt;&gt;&gt; psi = dq.fock(4, 0) + dq.fock(4, 1)\n&gt;&gt;&gt; dq.norm(psi)\nArray(1.414, dtype=float32)\n</code></pre> <p>For a density matrix:</p> <pre><code>&gt;&gt;&gt; rho = dq.fock_dm(4, 0) + dq.fock_dm(4, 1) + dq.fock_dm(4, 2)\n&gt;&gt;&gt; dq.norm(rho)\nArray(3., dtype=float32)\n</code></pre>"},{"location":"python_api/utils/general/overlap.html","title":"overlap","text":""},{"location":"python_api/utils/general/overlap.html#dynamiqs.utils.general.overlap","title":"dq.overlap","text":"<pre><code>overlap(x: QArrayLike, y: QArrayLike) -&gt; Array\n</code></pre> <p>Returns the overlap between two quantum states.</p> <p>The overlap is computed</p> <ul> <li>as \\(\\lvert\\braket{\\psi|\\varphi}\\rvert^2\\) if both arguments are kets \\(\\ket\\psi\\)   and \\(\\ket\\varphi\\),</li> <li>as \\(\\lvert\\bra\\psi \\rho \\ket\\psi\\rvert\\) if one argument is a ket \\(\\ket\\psi\\) and   the other is a density matrix \\(\\rho\\),</li> <li>as \\(\\tr{\\rho^\\dag\\sigma}\\) if both arguments are density matrices \\(\\rho\\) and   \\(\\sigma\\).</li> </ul> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., n, n))         \u2013          <p>Ket or density matrix.</p> </li> <li> <code>y</code>             (qarray-like of shape (..., n, 1) or (..., n, n))         \u2013          <p>Ket or density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Real-valued overlap.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fock0 = dq.fock(3, 0)\n&gt;&gt;&gt; dq.overlap(fock0, fock0)\nArray(1., dtype=float32)\n&gt;&gt;&gt; fock01_dm = 0.5 * (dq.fock_dm(3, 0) + dq.fock_dm(3, 1))\n&gt;&gt;&gt; dq.overlap(fock0, fock01_dm)\nArray(0.5, dtype=float32)\n</code></pre>"},{"location":"python_api/utils/general/powm.html","title":"powm","text":""},{"location":"python_api/utils/general/powm.html#dynamiqs.utils.general.powm","title":"dq.powm","text":"<pre><code>powm(x: QArrayLike, n: int) -&gt; QArray\n</code></pre> <p>Returns the \\(n\\)-th matrix power of a qarray.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Square matrix.</p> </li> <li> <code>n</code>         \u2013          <p>Integer exponent.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Matrix power of <code>x</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.powm(dq.sigmax(), 2)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[1.+0.j   \u22c5   ]\n [  \u22c5    1.+0.j]]\n</code></pre>"},{"location":"python_api/utils/general/proj.html","title":"proj","text":""},{"location":"python_api/utils/general/proj.html#dynamiqs.utils.general.proj","title":"dq.proj","text":"<pre><code>proj(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the projection operator onto a pure quantum state.</p> <p>The projection operator onto the state \\(\\ket\\psi\\) is defined as \\(P_{\\ket\\psi} = \\ket\\psi\\bra\\psi\\).</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n))         \u2013          <p>Ket or bra.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Projection operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi = dq.fock(3, 0)\n&gt;&gt;&gt; dq.proj(psi)\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dense\n[[1.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j]]\n</code></pre>"},{"location":"python_api/utils/general/ptrace.html","title":"ptrace","text":""},{"location":"python_api/utils/general/ptrace.html#dynamiqs.utils.general.ptrace","title":"dq.ptrace","text":"<pre><code>ptrace(\n    x: QArrayLike, keep: int | tuple[int, ...], dims: tuple[int, ...] | None = None\n) -&gt; QArray\n</code></pre> <p>Returns the partial trace of a ket, bra or density matrix.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n) or (..., n, n))         \u2013          <p>Ket, bra or density matrix of a composite system.</p> </li> <li> <code>keep</code>             (int or tuple of ints)         \u2013          <p>Dimensions to keep after partial trace.</p> </li> <li> <code>dims</code>             (tuple of ints or None)         \u2013          <p>Dimensions of each subsystem in the composite system Hilbert space tensor product. Defaults to <code>None</code> (<code>x.dims</code> if available, single Hilbert space <code>dims=(n,)</code> otherwise).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., m, m))           \u2013          <p>Density matrix (with <code>m &lt;= n</code>).</p> </li> </ul> Note <p>The returned object is always a density matrix, even if the input is a ket or a bra.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi_abc = dq.fock((3, 4, 5), (0, 2, 1))\n&gt;&gt;&gt; psi_abc.dims\n(3, 4, 5)\n&gt;&gt;&gt; psi_abc.shape\n(60, 1)\n&gt;&gt;&gt; rho_a = dq.ptrace(psi_abc, 0)\n&gt;&gt;&gt; rho_a.dims\n(3,)\n&gt;&gt;&gt; rho_a.shape\n(3, 3)\n&gt;&gt;&gt; rho_bc = dq.ptrace(psi_abc, (1, 2))\n&gt;&gt;&gt; rho_bc.dims\n(4, 5)\n&gt;&gt;&gt; rho_bc.shape\n(20, 20)\n</code></pre> <p>If the input qarray-like <code>x</code> does not hold Hilbert space dimensions, you can specify them with the argument <code>dims</code>. For example, to trace out the second subsystem of the Bell state \\((\\ket{00}+\\ket{11})/\\sqrt2\\):</p> <pre><code>&gt;&gt;&gt; bell_state = np.array([1, 0, 0, 1])[:, None] / np.sqrt(2)\n&gt;&gt;&gt; bell_state.shape\n(4, 1)\n&gt;&gt;&gt; dq.ptrace(bell_state, 0, dims=(2, 2))\nQArray: shape=(2, 2), dims=(2,), dtype=float32, layout=dense\n[[0.5 0. ]\n [0.  0.5]]\n</code></pre>"},{"location":"python_api/utils/general/purity.html","title":"purity","text":""},{"location":"python_api/utils/general/purity.html#dynamiqs.utils.general.purity","title":"dq.purity","text":"<pre><code>purity(x: QArrayLike) -&gt; Array\n</code></pre> <p>Returns the purity of a ket or density matrix.</p> <p>For a ket (a pure state), the purity is \\(1\\). For a density matrix \\(\\rho\\), it is defined by \\(\\tr{\\rho^2}\\).</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., n, n))         \u2013          <p>Ket or density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Real-valued purity.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi = dq.fock(2, 0)\n&gt;&gt;&gt; dq.purity(psi)\nArray(1., dtype=float32)\n&gt;&gt;&gt; rho = (dq.fock_dm(2, 0) + dq.fock_dm(2, 1)).unit()\n&gt;&gt;&gt; dq.purity(rho)\nArray(0.5, dtype=float32)\n</code></pre>"},{"location":"python_api/utils/general/signm.html","title":"signm","text":""},{"location":"python_api/utils/general/signm.html#dynamiqs.utils.general.signm","title":"dq.signm","text":"<pre><code>signm(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the operator sign function of a Hermitian qarray.</p> <p>The operator sign function \\(\\mathrm{sign}(A)\\) of a Hermitian matrix \\(A\\) with eigendecomposition \\(A = U\\, \\text{diag}(\\lambda_1,\\dots,\\lambda_n)\\, U^\\dagger\\), with \\((\\lambda_1,\\dots,\\lambda_n)\\in\\R^n\\) the eigenvalues of \\(A\\), is defined by $$     \\mathrm{sign}(A) = U\\,\\mathrm{diag}(\\mathrm{sign}(\\lambda_1),\\dots,\\mathrm{sign}(\\lambda_n))\\,U^\\dagger, $$ where \\(\\mathrm{sign}(x)\\) is the sign of \\(x\\in\\R\\).</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Square Hermitian matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Operator sign function of <code>x</code>.</p> </li> </ul> Note <p>The operator sign is generally dense, and is different from the element-wise sign of the operator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.signm(dq.sigmax())\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[0.+0.j 1.+0.j]\n [1.+0.j 0.+0.j]]\n&gt;&gt;&gt; dq.position(3)\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dia, ndiags=2\n[[    \u22c5     0.5  +0.j     \u22c5    ]\n [0.5  +0.j     \u22c5     0.707+0.j]\n [    \u22c5     0.707+0.j     \u22c5    ]]\n&gt;&gt;&gt; dq.signm(dq.position(3))\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dense\n[[-0.667+0.j  0.577+0.j  0.471+0.j]\n [ 0.577+0.j  0.   +0.j  0.816+0.j]\n [ 0.471+0.j  0.816+0.j -0.333+0.j]]\n</code></pre>"},{"location":"python_api/utils/general/sinm.html","title":"sinm","text":""},{"location":"python_api/utils/general/sinm.html#dynamiqs.utils.general.sinm","title":"dq.sinm","text":"<pre><code>sinm(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the sine of a qarray.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Square matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Sine of <code>x</code>.</p> </li> </ul> Note <p>This function uses <code>jax.scipy.linalg.expm()</code> to compute the sine of a matrix \\(A\\): $$     \\sin(A) = \\frac{e^{iA} - e^{-iA}}{2i} $$</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.sinm(0.5 * jnp.pi * dq.sigmax())\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[0.-0.j 1.-0.j]\n [1.-0.j 0.-0.j]]\n</code></pre>"},{"location":"python_api/utils/general/tensor.html","title":"tensor","text":""},{"location":"python_api/utils/general/tensor.html#dynamiqs.utils.general.tensor","title":"dq.tensor","text":"<pre><code>tensor(*args: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the tensor product of multiple kets, bras, density matrices or operators.</p> <p>The returned qarray shape is:</p> <ul> <li>\\((..., n, 1)\\) with \\(n=\\prod_k n_k\\) if all input qarrays are kets with shape   \\((..., n_k, 1)\\),</li> <li>\\((..., 1, n)\\) with \\(n=\\prod_k n_k\\) if all input qarrays are bras with shape   \\((..., 1, n_k)\\),</li> <li>\\((..., n, n)\\) with \\(n=\\prod_k n_k\\) if all input qarrays are density matrices or   operators with shape \\((..., n_k, n_k)\\).</li> </ul> <p>Parameters:</p> <ul> <li> <code>*args</code>             (qarray-like of shape (..., n_k, 1) or (..., 1, n_k) or (..., n_k, n_k))         \u2013          <p>Variable length argument list of kets, bras, density matrices or operators.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, 1) or (..., 1, n) or (..., n, n))           \u2013          <p>Tensor product of the input qarrays.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi = dq.tensor(dq.fock(3, 0), dq.fock(4, 2), dq.fock(5, 1))\n&gt;&gt;&gt; psi.shape\n(60, 1)\n</code></pre>"},{"location":"python_api/utils/general/tobra.html","title":"tobra","text":""},{"location":"python_api/utils/general/tobra.html#dynamiqs.utils.general.tobra","title":"dq.tobra","text":"<pre><code>tobra(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the bra representation of a pure quantum state.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n))         \u2013          <p>Ket or bra.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., 1, n))           \u2013          <p>Qarray.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi = dq.fock(3, 0)  # shape: (3, 1)\n&gt;&gt;&gt; psi\nQArray: shape=(3, 1), dims=(3,), dtype=complex64, layout=dense\n[[1.+0.j]\n [0.+0.j]\n [0.+0.j]]\n&gt;&gt;&gt; dq.tobra(psi)  # shape: (1, 3)\nQArray: shape=(1, 3), dims=(3,), dtype=complex64, layout=dense\n[[1.-0.j 0.-0.j 0.-0.j]]\n</code></pre>"},{"location":"python_api/utils/general/todm.html","title":"todm","text":""},{"location":"python_api/utils/general/todm.html#dynamiqs.utils.general.todm","title":"dq.todm","text":"<pre><code>todm(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the density matrix representation of a quantum state.</p> Note <p>This function is an alias of <code>dq.proj()</code>. If <code>x</code> is already a density matrix, it is returned directly.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n) or (..., n, n))         \u2013          <p>Ket, bra or density matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Density matrix.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi = dq.fock(3, 0)  # shape: (3, 1)\n&gt;&gt;&gt; psi\nQArray: shape=(3, 1), dims=(3,), dtype=complex64, layout=dense\n[[1.+0.j]\n [0.+0.j]\n [0.+0.j]]\n&gt;&gt;&gt; dq.todm(psi)  # shape: (3, 3)\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dense\n[[1.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j]]\n</code></pre>"},{"location":"python_api/utils/general/toket.html","title":"toket","text":""},{"location":"python_api/utils/general/toket.html#dynamiqs.utils.general.toket","title":"dq.toket","text":"<pre><code>toket(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the ket representation of a pure quantum state.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n))         \u2013          <p>Ket or bra.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, 1))           \u2013          <p>Ket.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi = dq.fock(3, 0).tobra()  # shape: (1, 3)\n&gt;&gt;&gt; psi\nQArray: shape=(1, 3), dims=(3,), dtype=complex64, layout=dense\n[[1.-0.j 0.-0.j 0.-0.j]]\n&gt;&gt;&gt; dq.toket(psi)  # shape: (3, 1)\nQArray: shape=(3, 1), dims=(3,), dtype=complex64, layout=dense\n[[1.+0.j]\n [0.+0.j]\n [0.+0.j]]\n</code></pre>"},{"location":"python_api/utils/general/trace.html","title":"trace","text":""},{"location":"python_api/utils/general/trace.html#dynamiqs.utils.general.trace","title":"dq.trace","text":"<pre><code>trace(x: QArrayLike) -&gt; Array\n</code></pre> <p>Returns the trace of a qarray along its last two dimensions.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Qarray-like.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Trace of <code>x</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = jnp.ones((3, 3))\n&gt;&gt;&gt; dq.trace(x)\nArray(3., dtype=float32)\n</code></pre>"},{"location":"python_api/utils/general/tracemm.html","title":"tracemm","text":""},{"location":"python_api/utils/general/tracemm.html#dynamiqs.utils.general.tracemm","title":"dq.tracemm","text":"<pre><code>tracemm(x: QArrayLike, y: QArrayLike) -&gt; Array\n</code></pre> <p>Return the trace of a matrix multiplication using a fast implementation.</p> <p>The trace is computed as <code>sum(x * y.T)</code> where <code>*</code> is the element-wise product, instead of <code>trace(x @ y)</code> where <code>@</code> is the matrix product. Indeed, we have:</p> \\[     \\tr{xy} = \\sum_i (xy)_{ii}             = \\sum_{i,j} x_{ij} y_{ji}             = \\sum_{i,j} x_{ij} (y^\\intercal)_{ij}             = \\sum_{i,j} (x * y^\\intercal)_{ij} \\] Note <p>The resulting time complexity for \\(n\\times n\\) matrices is \\(\\mathcal{O}(n^2)\\) instead of \\(\\mathcal{O}(n^3)\\) with the naive formula.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Qarray-like.</p> </li> <li> <code>y</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Qarray-like.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (array of shape (...))           \u2013          <p>Trace of <code>x @ y</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = jnp.ones((3, 3))\n&gt;&gt;&gt; y = jnp.ones((3, 3))\n&gt;&gt;&gt; dq.tracemm(x, y)\nArray(9., dtype=float32)\n</code></pre>"},{"location":"python_api/utils/general/unit.html","title":"unit","text":""},{"location":"python_api/utils/general/unit.html#dynamiqs.utils.general.unit","title":"dq.unit","text":"<pre><code>unit(x: QArrayLike, *, psd: bool = False) -&gt; QArray\n</code></pre> <p>Normalize a ket, bra, density matrix or Hermitian matrix to unit norm.</p> <p>The returned object is divided by its norm (see <code>dq.norm()</code>).</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n) or (..., n, n))         \u2013          <p>Ket, bra or density matrix.</p> </li> <li> <code>psd</code>         \u2013          <p>Whether <code>x</code> is a positive semi-definite matrix (see <code>dq.norm()</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, 1) or (..., 1, n) or (..., n, n))           \u2013          <p>Normalized ket, bra or density matrix.</p> </li> </ul> See also <ul> <li><code>dq.norm()</code>: returns the norm of a ket, bra, density matrix,     or Hermitian matrix.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; psi = dq.fock(4, 0) + dq.fock(4, 1)\n&gt;&gt;&gt; psi.norm()\nArray(1.414, dtype=float32)\n&gt;&gt;&gt; psi = dq.unit(psi)\n&gt;&gt;&gt; psi.norm()\nArray(1., dtype=float32)\n</code></pre>"},{"location":"python_api/utils/general/wigner.html","title":"wigner","text":""},{"location":"python_api/utils/general/wigner.html#dynamiqs.utils.wigner_utils.wigner","title":"dq.wigner","text":"<pre><code>wigner(\n    state: QArrayLike,\n    xmax: float = 6.0,\n    ymax: float = 6.0,\n    npixels: int = 201,\n    xvec: ArrayLike | None = None,\n    yvec: ArrayLike | None = None,\n    g: float = 2.0,\n) -&gt; tuple[Array, Array, Array]\n</code></pre> <p>Compute the Wigner distribution of a ket or density matrix.</p> <p>The Wigner distribution is computed on a grid of coordinates \\((x, y)\\).</p> <p>Parameters:</p> <ul> <li> <code>state</code>             (qarray-like of shape (..., n, 1) or (..., n, n))         \u2013          <p>Ket or density matrix.</p> </li> <li> <code>xmax</code>         \u2013          <p>Maximum absolute value of the \\(x\\) coordinate.</p> </li> <li> <code>ymax</code>         \u2013          <p>Maximum absolute value of the \\(y\\) coordinate.</p> </li> <li> <code>npixels</code>         \u2013          <p>Number of pixels in each direction.</p> </li> <li> <code>xvec</code>             (array-like of shape (nxvec,))         \u2013          <p>\\(x\\) coordinates. If <code>None</code>, defaults to <code>xvec = jnp.linspace(-xmax, xmax, npixels)</code>.</p> </li> <li> <code>yvec</code>             (array-like of shape (nyvec,))         \u2013          <p>\\(y\\) coordinates. If <code>None</code>, defaults to <code>yvec = jnp.linspace(-ymax, ymax, npixels)</code>.</p> </li> <li> <code>g</code>         \u2013          <p>Scaling factor of Wigner quadratures, such that \\(a = g(x + iy)/2\\).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>xvec</code>            (array of shape (npixels,) or (nxvec,))           \u2013          <p>\\(x\\) coordinates, or <code>xvec</code> if specified.</p> </li> <li> <code>yvec</code>            (array of shape (npixels,) or (nyvec,))           \u2013          <p>\\(y\\) coordinates, or <code>yvec</code> if specified.</p> </li> <li> <code>w</code>            (array of shape (..., npixels, npixels) or (..., nyvec, nxvec))           \u2013          <p>Wigner distribution.</p> </li> </ul> See also <ul> <li><code>dq.plot.wigner()</code>: plot the Wigner function of a     state.</li> <li><code>dq.plot.wigner_data()</code>: plot a pre-computed     Wigner function.</li> </ul>"},{"location":"python_api/utils/global_settings/set_device.html","title":"set_device","text":""},{"location":"python_api/utils/global_settings/set_device.html#dynamiqs.utils.global_settings.set_device","title":"dq.set_device","text":"<pre><code>set_device(device: Literal['cpu', 'gpu', 'tpu'], index: int = 0)\n</code></pre> <p>Configure the default device.</p> Equivalent JAX syntax <p>This function is equivalent to </p><pre><code>jax.config.update('jax_default_device', jax.devices(device)[index])\n</code></pre><p></p> <p>See JAX documentation on devices.</p> <p>Parameters:</p> <ul> <li> <code>device</code>             (string 'cpu', 'gpu', or 'tpu')         \u2013          <p>Default device.</p> </li> <li> <code>index</code>         \u2013          <p>Index of the device to use, defaults to 0.</p> </li> </ul>"},{"location":"python_api/utils/global_settings/set_layout.html","title":"set_layout","text":""},{"location":"python_api/utils/global_settings/set_layout.html#dynamiqs.utils.global_settings.set_layout","title":"dq.set_layout","text":"<pre><code>set_layout(layout: Literal['dense', 'dia'])\n</code></pre> <p>Configure the default matrix layout for operators supporting this option.</p> <p>Two layouts are supported by most operators (see the list of available operators in the Python API)):</p> <ul> <li><code>'dense'</code>: JAX native dense layout,</li> <li><code>'dia'</code>: dynamiqs sparse diagonal layout, only non-zero diagonals are stored.</li> </ul> Note <p>The default layout upon importing dynamiqs is <code>'dia'</code>.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>             (string 'dense' or 'dia')         \u2013          <p>Default matrix layout for operators.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.eye(4)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dia, ndiags=1\n[[1.+0.j   \u22c5      \u22c5      \u22c5   ]\n [  \u22c5    1.+0.j   \u22c5      \u22c5   ]\n [  \u22c5      \u22c5    1.+0.j   \u22c5   ]\n [  \u22c5      \u22c5      \u22c5    1.+0.j]]\n&gt;&gt;&gt; dq.set_layout('dense')\n&gt;&gt;&gt; dq.eye(4)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dense\n[[1.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 1.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 1.+0.j]]\n&gt;&gt;&gt; dq.set_layout('dia')  # back to default layout\n</code></pre>"},{"location":"python_api/utils/global_settings/set_matmul_precision.html","title":"set_matmul_precision","text":""},{"location":"python_api/utils/global_settings/set_matmul_precision.html#dynamiqs.utils.global_settings.set_matmul_precision","title":"dq.set_matmul_precision","text":"<pre><code>set_matmul_precision(matmul_precision: Literal['low', 'high', 'highest'])\n</code></pre> <p>Configure the default precision for matrix multiplications on GPUs and TPUs.</p> <p>Some devices allow trading off accuracy for speed when performing matrix multiplications (matmul). Three options are available:</p> <ul> <li><code>'low'</code> reduces matmul precision to <code>bfloat16</code> (fastest but least accurate),</li> <li><code>'high'</code> reduces matmul precision to <code>bfloat16_3x</code> or <code>tensorfloat32</code> if available     (faster but less accurate),</li> <li><code>'highest'</code> keeps matmul precision to <code>float32</code> or <code>float64</code> as applicable     (slowest but most accurate, default setting).</li> </ul> Note <p>This setting applies only to single precision matrices (<code>float32</code> or <code>complex64</code>).</p> Equivalent JAX syntax <p>This function is equivalent to setting <code>jax_default_matmul_precision</code> in <code>jax.config</code>. See JAX documentation on matmul precision and JAX documentation on the different available options.</p> <p>Parameters:</p> <ul> <li> <code>matmul_precision</code>             (string 'low', 'high', or 'highest')         \u2013          <p>Default precision for matrix multiplications on GPUs and TPUs.</p> </li> </ul>"},{"location":"python_api/utils/global_settings/set_precision.html","title":"set_precision","text":""},{"location":"python_api/utils/global_settings/set_precision.html#dynamiqs.utils.global_settings.set_precision","title":"dq.set_precision","text":"<pre><code>set_precision(precision: Literal['single', 'double'])\n</code></pre> <p>Configure the default floating point precision.</p> <p>Two options are available:</p> <ul> <li><code>'single'</code> sets default precision to <code>float32</code> and <code>complex64</code> (default setting),</li> <li><code>'double'</code> sets default precision to <code>float64</code> and <code>complex128</code>.</li> </ul> Equivalent JAX syntax <p>This function is equivalent to </p><pre><code>if precision == 'single':\n    jax.config.update('jax_enable_x64', False)\nelif precision == 'double':\n    jax.config.update('jax_enable_x64', True)\n</code></pre>  See JAX documentation on double precision.<p></p> <p>Parameters:</p> <ul> <li> <code>precision</code>             (string 'single' or 'double')         \u2013          <p>Default precision.</p> </li> </ul>"},{"location":"python_api/utils/global_settings/set_progress_meter.html","title":"set_progress_meter","text":""},{"location":"python_api/utils/global_settings/set_progress_meter.html#dynamiqs.utils.global_settings.set_progress_meter","title":"dq.set_progress_meter","text":"<pre><code>set_progress_meter(progress_meter: AbstractProgressMeter | bool)\n</code></pre> <p>Configure the default progress meter.</p> <p>Parameters:</p> <ul> <li> <code>progress_meter</code>         \u2013          <p>Default progress meter. Set to <code>True</code> for a tqdm progress meter, and <code>False</code> for no output. See other options in dynamiqs/progress_meter.py.</p> </li> </ul>"},{"location":"python_api/utils/operators/cnot.html","title":"cnot","text":""},{"location":"python_api/utils/operators/cnot.html#dynamiqs.utils.operators.cnot","title":"dq.cnot","text":"<pre><code>cnot() -&gt; QArray\n</code></pre> <p>Returns the \\(\\text{CNOT}\\) gate.</p> <p>It is defined by $$     \\text{CNOT} = \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 \\\\         0 &amp; 0 &amp; 1 &amp; 0     \\end{pmatrix} $$</p> <p>Returns:</p> <ul> <li>             (qarray of shape (4, 4))           \u2013          <p>\\(\\text{CNOT}\\) gate.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.cnot()\nQArray: shape=(4, 4), dims=(2, 2), dtype=complex64, layout=dense\n[[1.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 1.+0.j]\n [0.+0.j 0.+0.j 1.+0.j 0.+0.j]]\n</code></pre>"},{"location":"python_api/utils/operators/create.html","title":"create","text":""},{"location":"python_api/utils/operators/create.html#dynamiqs.utils.operators.create","title":"dq.create","text":"<pre><code>create(*dims: int, layout: Layout | None = None) -&gt; QArray | tuple[QArray, ...]\n</code></pre> <p>Returns a bosonic creation operator, or a tuple of creation operators for a multi-mode system.</p> <p>If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_N)\\), it returns a tuple with len(dims) operators \\((A_1^\\dag,\\dots,A_N^\\dag)\\), where \\(A_k^\\dag\\) is the creation operator acting on the \\(k\\)-th subsystem within the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     A_k^\\dag = I_{n_1} \\otimes\\dots\\otimes a_{n_k}^\\dag \\otimes\\dots\\otimes I_{n_N}. $$</p> <p>Parameters:</p> <ul> <li> <code>*dims</code>         \u2013          <p>Hilbert space dimension of each mode.</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray or tuple of qarrays, each of shape (n, n))           \u2013          <p>Creation operator(s), with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode \\(a^\\dag\\):</p> <pre><code>&gt;&gt;&gt; dq.create(4)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dia, ndiags=1\n[[    \u22c5         \u22c5         \u22c5         \u22c5    ]\n [1.   +0.j     \u22c5         \u22c5         \u22c5    ]\n [    \u22c5     1.414+0.j     \u22c5         \u22c5    ]\n [    \u22c5         \u22c5     1.732+0.j     \u22c5    ]]\n</code></pre> <p>Multi-mode \\(a^\\dag\\otimes I_3\\) and \\(I_2\\otimes b^\\dag\\):</p> <pre><code>&gt;&gt;&gt; adag, bdag = dq.create(2, 3)\n&gt;&gt;&gt; adag\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [1.+0.j   \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5    1.+0.j   \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5    1.+0.j   \u22c5      \u22c5      \u22c5   ]]\n&gt;&gt;&gt; bdag\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=1\n[[    \u22c5         \u22c5         \u22c5         \u22c5         \u22c5         \u22c5    ]\n [1.   +0.j     \u22c5         \u22c5         \u22c5         \u22c5         \u22c5    ]\n [    \u22c5     1.414+0.j     \u22c5         \u22c5         \u22c5         \u22c5    ]\n [    \u22c5         \u22c5         \u22c5         \u22c5         \u22c5         \u22c5    ]\n [    \u22c5         \u22c5         \u22c5     1.   +0.j     \u22c5         \u22c5    ]\n [    \u22c5         \u22c5         \u22c5         \u22c5     1.414+0.j     \u22c5    ]]\n</code></pre>"},{"location":"python_api/utils/operators/destroy.html","title":"destroy","text":""},{"location":"python_api/utils/operators/destroy.html#dynamiqs.utils.operators.destroy","title":"dq.destroy","text":"<pre><code>destroy(*dims: int, layout: Layout | None = None) -&gt; QArray | tuple[QArray, ...]\n</code></pre> <p>Returns a bosonic annihilation operator, or a tuple of annihilation operators for a multi-mode system.</p> <p>If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_N)\\), it returns a tuple with len(dims) operators \\((A_1,\\dots,A_N)\\), where \\(A_k\\) is the annihilation operator acting on the \\(k\\)-th subsystem within the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     A_k = I_{n_1} \\otimes\\dots\\otimes a_{n_k} \\otimes\\dots\\otimes I_{n_N}. $$</p> <p>Parameters:</p> <ul> <li> <code>*dims</code>         \u2013          <p>Hilbert space dimension of each mode.</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray or tuple of qarrays, each of shape (n, n))           \u2013          <p>Annihilation operator(s), with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode \\(a\\):</p> <pre><code>&gt;&gt;&gt; dq.destroy(4)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dia, ndiags=1\n[[    \u22c5     1.   +0.j     \u22c5         \u22c5    ]\n [    \u22c5         \u22c5     1.414+0.j     \u22c5    ]\n [    \u22c5         \u22c5         \u22c5     1.732+0.j]\n [    \u22c5         \u22c5         \u22c5         \u22c5    ]]\n</code></pre> <p>Multi-mode \\(a\\otimes I_3\\) and \\(I_2\\otimes b\\):</p> <pre><code>&gt;&gt;&gt; a, b = dq.destroy(2, 3)\n&gt;&gt;&gt; a\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5      \u22c5      \u22c5    1.+0.j   \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5    1.+0.j   \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5    1.+0.j]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]]\n&gt;&gt;&gt; b\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=1\n[[    \u22c5     1.   +0.j     \u22c5         \u22c5         \u22c5         \u22c5    ]\n [    \u22c5         \u22c5     1.414+0.j     \u22c5         \u22c5         \u22c5    ]\n [    \u22c5         \u22c5         \u22c5         \u22c5         \u22c5         \u22c5    ]\n [    \u22c5         \u22c5         \u22c5         \u22c5     1.   +0.j     \u22c5    ]\n [    \u22c5         \u22c5         \u22c5         \u22c5         \u22c5     1.414+0.j]\n [    \u22c5         \u22c5         \u22c5         \u22c5         \u22c5         \u22c5    ]]\n</code></pre>"},{"location":"python_api/utils/operators/displace.html","title":"displace","text":""},{"location":"python_api/utils/operators/displace.html#dynamiqs.utils.operators.displace","title":"dq.displace","text":"<pre><code>displace(dim: int, alpha: ArrayLike) -&gt; DenseQArray\n</code></pre> <p>Returns the displacement operator of complex amplitude \\(\\alpha\\).</p> <p>It is defined by $$     D(\\alpha) = \\exp(\\alpha a^\\dag - \\alpha^* a), $$ where \\(a\\) and \\(a^\\dag\\) are the annihilation and creation operators, respectively.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Dimension of the Hilbert space.</p> </li> <li> <code>alpha</code>             (array-like of shape (...))         \u2013          <p>Displacement amplitude.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., dim, dim))           \u2013          <p>Displacement operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.displace(4, 0.5)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dense\n[[ 0.882+0.j -0.441+0.j  0.156+0.j -0.047+0.j]\n [ 0.441+0.j  0.662+0.j -0.542+0.j  0.27 +0.j]\n [ 0.156+0.j  0.542+0.j  0.442+0.j -0.697+0.j]\n [ 0.047+0.j  0.27 +0.j  0.697+0.j  0.662+0.j]]\n&gt;&gt;&gt; dq.displace(4, [0.1, 0.2]).shape\n(2, 4, 4)\n</code></pre>"},{"location":"python_api/utils/operators/eye.html","title":"eye","text":""},{"location":"python_api/utils/operators/eye.html#dynamiqs.utils.operators.eye","title":"dq.eye","text":"<pre><code>eye(*dims: int, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the identity operator.</p> <p>If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_N)\\), it returns the identity operator of the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     I_n = I_{n_1}\\otimes\\dots\\otimes I_{n_N}. $$</p> <p>Parameters:</p> <ul> <li> <code>*dims</code>         \u2013          <p>Hilbert space dimension of each subsystem.</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (n, n))           \u2013          <p>Identity operator, with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode \\(I_4\\):</p> <pre><code>&gt;&gt;&gt; dq.eye(4)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dia, ndiags=1\n[[1.+0.j   \u22c5      \u22c5      \u22c5   ]\n [  \u22c5    1.+0.j   \u22c5      \u22c5   ]\n [  \u22c5      \u22c5    1.+0.j   \u22c5   ]\n [  \u22c5      \u22c5      \u22c5    1.+0.j]]\n</code></pre> <p>Multi-mode \\(I_2 \\otimes I_3\\):</p> <pre><code>&gt;&gt;&gt; dq.eye(2, 3)\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=1\n[[1.+0.j   \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5    1.+0.j   \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5    1.+0.j   \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5    1.+0.j   \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5    1.+0.j   \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5    1.+0.j]]\n</code></pre> See also <ul> <li><code>dq.eye_like()</code>: returns the identity operator in the Hilbert space of the input.</li> </ul>"},{"location":"python_api/utils/operators/eye_like.html","title":"eye_like","text":""},{"location":"python_api/utils/operators/eye_like.html#dynamiqs.utils.operators.eye_like","title":"dq.eye_like","text":"<pre><code>eye_like(\n    x: QArrayLike, dims: tuple[int, ...] | None = None, layout: Layout | None = None\n) -&gt; QArray\n</code></pre> <p>Returns the identity operator in the Hilbert space of the input.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n) or (..., n, n))         \u2013          <p>Ket, bra or operator.</p> </li> <li> <code>dims</code>             (tuple of ints or None)         \u2013          <p>Dimensions of each subsystem in the composite system Hilbert space tensor product. Defaults to <code>None</code> (<code>x.dims</code> if available, single Hilbert space <code>dims=(n,)</code> otherwise).</p> </li> <li> <code>layout</code>         \u2013          <p>Overrides the returned matrix layout. If <code>None</code>, the layout is the same as <code>x</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (n, n))           \u2013          <p>Identity operator, with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode \\(I_4\\):</p> <pre><code>&gt;&gt;&gt; a = dq.destroy(4)\n&gt;&gt;&gt; dq.eye_like(a)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dia, ndiags=1\n[[1.+0.j   \u22c5      \u22c5      \u22c5   ]\n [  \u22c5    1.+0.j   \u22c5      \u22c5   ]\n [  \u22c5      \u22c5    1.+0.j   \u22c5   ]\n [  \u22c5      \u22c5      \u22c5    1.+0.j]]\n</code></pre> <p>Multi-mode \\(I_2 \\otimes I_3\\):</p> <pre><code>&gt;&gt;&gt; a, b = dq.destroy(2, 3)\n&gt;&gt;&gt; dq.eye_like(a)\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=1\n[[1.+0.j   \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5    1.+0.j   \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5    1.+0.j   \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5    1.+0.j   \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5    1.+0.j   \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5    1.+0.j]]\n</code></pre> See also <ul> <li><code>dq.eye()</code>: returns the identity operator.</li> </ul>"},{"location":"python_api/utils/operators/hadamard.html","title":"hadamard","text":""},{"location":"python_api/utils/operators/hadamard.html#dynamiqs.utils.operators.hadamard","title":"dq.hadamard","text":"<pre><code>hadamard(n: int = 1) -&gt; QArray\n</code></pre> <p>Returns the Hadamard transform on \\(n\\) qubits.</p> <p>For a single qubit, it is defined by $$     H = \\frac{1}{\\sqrt2} \\begin{pmatrix}         1 &amp; 1 \\\\         1 &amp; -1     \\end{pmatrix} $$ For \\(n\\) qubits, it is defined by the tensor product of Hadamard matrices: $$     H_n = \\bigotimes_{k=1}^n H $$</p> <p>Parameters:</p> <ul> <li> <code>n</code>         \u2013          <p>Number of qubits to act on.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (2^n, 2^n))           \u2013          <p>Hadamard transform operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.hadamard()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[ 0.707+0.j  0.707+0.j]\n [ 0.707+0.j -0.707+0.j]]\n&gt;&gt;&gt; dq.hadamard(2)\nQArray: shape=(4, 4), dims=(2, 2), dtype=complex64, layout=dense\n[[ 0.5+0.j  0.5+0.j  0.5+0.j  0.5+0.j]\n [ 0.5+0.j -0.5+0.j  0.5+0.j -0.5+0.j]\n [ 0.5+0.j  0.5+0.j -0.5+0.j -0.5+0.j]\n [ 0.5+0.j -0.5+0.j -0.5+0.j  0.5-0.j]]\n</code></pre>"},{"location":"python_api/utils/operators/momentum.html","title":"momentum","text":""},{"location":"python_api/utils/operators/momentum.html#dynamiqs.utils.operators.momentum","title":"dq.momentum","text":"<pre><code>momentum(dim: int, *, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the momentum operator \\(p = i (a^\\dag - a) / 2\\).</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Dimension of the Hilbert space.</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (dim, dim))           \u2013          <p>Momentum operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.momentum(3)\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dia, ndiags=2\n[[  \u22c5       0.-0.5j     \u22c5      ]\n [0.+0.5j     \u22c5       0.-0.707j]\n [  \u22c5       0.+0.707j   \u22c5      ]]\n</code></pre>"},{"location":"python_api/utils/operators/number.html","title":"number","text":""},{"location":"python_api/utils/operators/number.html#dynamiqs.utils.operators.number","title":"dq.number","text":"<pre><code>number(*dims: int, layout: Layout | None = None) -&gt; QArray | tuple[QArray, ...]\n</code></pre> <p>Returns the number operator of a bosonic mode, or a tuple of number operators for a multi-mode system.</p> <p>For a single mode, it is defined by \\(N = a^\\dag a\\), where \\(a\\) and \\(a^\\dag\\) are the mode annihilation and creation operators, respectively. If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_M)\\), it returns a tuple with len(dims) operators \\((N_1,\\dots,N_M)\\), where \\(N_k\\) is the number operator acting on the \\(k\\)-th subsystem within the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     N_k = I_{n_1} \\otimes\\dots\\otimes a_{n_k}^\\dag a_{n_k} \\otimes\\dots\\otimes I_{n_M}. $$</p> <p>Parameters:</p> <ul> <li> <code>*dims</code>         \u2013          <p>Hilbert space dimension of each mode.</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray or tuple of qarrays, each of shape (n, n))           \u2013          <p>Number operator(s), with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode \\(a^\\dag a\\):</p> <pre><code>&gt;&gt;&gt; dq.number(4)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5    1.+0.j   \u22c5      \u22c5   ]\n [  \u22c5      \u22c5    2.+0.j   \u22c5   ]\n [  \u22c5      \u22c5      \u22c5    3.+0.j]]\n</code></pre> <p>Multi-mode \\(a^\\dag a \\otimes I_3\\) and \\(I_2\\otimes b^\\dag b\\):</p> <pre><code>&gt;&gt;&gt; na, nb = dq.number(2, 3)\n&gt;&gt;&gt; na\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5    1.+0.j   \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5    1.+0.j   \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5    1.+0.j]]\n&gt;&gt;&gt; nb\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5    1.+0.j   \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5    2.+0.j   \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5    1.+0.j   \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5    2.+0.j]]\n</code></pre>"},{"location":"python_api/utils/operators/parity.html","title":"parity","text":""},{"location":"python_api/utils/operators/parity.html#dynamiqs.utils.operators.parity","title":"dq.parity","text":"<pre><code>parity(dim: int, *, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the parity operator of a bosonic mode.</p> <p>It is defined by \\(P = e^{i\\pi a^\\dag a}\\), where \\(a\\) and \\(a^\\dag\\) are the annihilation and creation operators, respectively.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Dimension of the Hilbert space.</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (dim, dim))           \u2013          <p>Parity operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.parity(4)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dia, ndiags=1\n[[ 1.+0.j    \u22c5       \u22c5       \u22c5   ]\n [   \u22c5    -1.+0.j    \u22c5       \u22c5   ]\n [   \u22c5       \u22c5     1.+0.j    \u22c5   ]\n [   \u22c5       \u22c5       \u22c5    -1.+0.j]]\n</code></pre>"},{"location":"python_api/utils/operators/position.html","title":"position","text":""},{"location":"python_api/utils/operators/position.html#dynamiqs.utils.operators.position","title":"dq.position","text":"<pre><code>position(dim: int, *, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the position operator \\(x = (a^\\dag + a) / 2\\).</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Dimension of the Hilbert space.</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (dim, dim))           \u2013          <p>Position operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.position(3)\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dia, ndiags=2\n[[    \u22c5     0.5  +0.j     \u22c5    ]\n [0.5  +0.j     \u22c5     0.707+0.j]\n [    \u22c5     0.707+0.j     \u22c5    ]]\n</code></pre>"},{"location":"python_api/utils/operators/quadrature.html","title":"quadrature","text":""},{"location":"python_api/utils/operators/quadrature.html#dynamiqs.utils.operators.quadrature","title":"dq.quadrature","text":"<pre><code>quadrature(dim: int, phi: float, *, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the quadrature operator of phase angle \\(\\phi\\).</p> <p>It is defined by \\(x_\\phi = (e^{i\\phi} a^\\dag + e^{-i\\phi} a) / 2\\), where \\(a\\) and \\(a^\\dag\\) are the annihilation and creation operators respectively.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Dimension of the Hilbert space.</p> </li> <li> <code>phi</code>         \u2013          <p>Phase angle.</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (dim, dim))           \u2013          <p>Quadrature operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.quadrature(3, 0.0)\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dia, ndiags=2\n[[    \u22c5     0.5  +0.j     \u22c5    ]\n [0.5  +0.j     \u22c5     0.707+0.j]\n [    \u22c5     0.707+0.j     \u22c5    ]]\n&gt;&gt;&gt; dq.quadrature(3, jnp.pi / 2)\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dia, ndiags=2\n[[   \u22c5       -0.-0.5j      \u22c5      ]\n [-0.+0.5j      \u22c5       -0.-0.707j]\n [   \u22c5       -0.+0.707j    \u22c5      ]]\n</code></pre>"},{"location":"python_api/utils/operators/rx.html","title":"rx","text":""},{"location":"python_api/utils/operators/rx.html#dynamiqs.utils.operators.rx","title":"dq.rx","text":"<pre><code>rx(theta: ArrayLike) -&gt; QArray\n</code></pre> <p>Returns the \\(R_x(\\theta)\\) rotation gate.</p> <p>It is defined by $$     R_x(\\theta) = \\begin{pmatrix}         \\cos(\\theta/2)   &amp; -i\\sin(\\theta/2) \\\\         -i\\sin(\\theta/2) &amp; \\cos(\\theta/2)     \\end{pmatrix} $$</p> <p>Parameters:</p> <ul> <li> <code>theta</code>             (array-like of shape (...))         \u2013          <p>Rotation angle \\(\\theta\\) in radians.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>\\(R_x(\\theta)\\) gate.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.rx(jnp.pi)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[-0.+0.j  0.-1.j]\n [ 0.-1.j -0.+0.j]]\n&gt;&gt;&gt; dq.rx([0, jnp.pi/4, jnp.pi/3, jnp.pi/2, jnp.pi]).shape\n(5, 2, 2)\n</code></pre>"},{"location":"python_api/utils/operators/ry.html","title":"ry","text":""},{"location":"python_api/utils/operators/ry.html#dynamiqs.utils.operators.ry","title":"dq.ry","text":"<pre><code>ry(theta: ArrayLike) -&gt; QArray\n</code></pre> <p>Returns the \\(R_y(\\theta)\\) rotation gate.</p> <p>It is defined by $$     R_y(\\theta) = \\begin{pmatrix}         \\cos(\\theta/2) &amp; -\\sin(\\theta/2) \\\\         \\sin(\\theta/2) &amp; \\cos(\\theta/2)     \\end{pmatrix} $$</p> <p>Parameters:</p> <ul> <li> <code>theta</code>             (array-like of shape (...))         \u2013          <p>Rotation angle \\(\\theta\\) in radians.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>\\(R_y(\\theta)\\) gate.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.ry(jnp.pi)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[-0.+0.j -1.+0.j]\n [ 1.+0.j -0.+0.j]]\n&gt;&gt;&gt; dq.ry([0, jnp.pi/4, jnp.pi/3, jnp.pi/2, jnp.pi]).shape\n(5, 2, 2)\n</code></pre>"},{"location":"python_api/utils/operators/rz.html","title":"rz","text":""},{"location":"python_api/utils/operators/rz.html#dynamiqs.utils.operators.rz","title":"dq.rz","text":"<pre><code>rz(theta: ArrayLike) -&gt; QArray\n</code></pre> <p>Returns the \\(R_z(\\theta)\\) rotation gate.</p> <p>It is defined by $$     R_z(\\theta) = \\begin{pmatrix}         e^{-i\\theta/2} &amp; 0 \\\\         0              &amp; e^{i\\theta/2}     \\end{pmatrix} $$</p> <p>Parameters:</p> <ul> <li> <code>theta</code>             (array-like of shape (...))         \u2013          <p>Rotation angle \\(\\theta\\) in radians.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>\\(R_z(\\theta)\\) gate.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.rz(jnp.pi)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[-0.-1.j  0.+0.j]\n [ 0.+0.j -0.+1.j]]\n&gt;&gt;&gt; dq.rz([0, jnp.pi/4, jnp.pi/3, jnp.pi/2, jnp.pi]).shape\n(5, 2, 2)\n</code></pre>"},{"location":"python_api/utils/operators/sgate.html","title":"sgate","text":""},{"location":"python_api/utils/operators/sgate.html#dynamiqs.utils.operators.sgate","title":"dq.sgate","text":"<pre><code>sgate() -&gt; QArray\n</code></pre> <p>Returns the \\(\\text{S}\\) gate.</p> <p>It is defined by \\(\\text{S} = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; i \\end{pmatrix}\\).</p> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>\\(\\text{S}\\) gate.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.sgate()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[1.+0.j 0.+0.j]\n [0.+0.j 0.+1.j]]\n</code></pre>"},{"location":"python_api/utils/operators/sigmam.html","title":"sigmam","text":""},{"location":"python_api/utils/operators/sigmam.html#dynamiqs.utils.operators.sigmam","title":"dq.sigmam","text":"<pre><code>sigmam(*, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the Pauli lowering operator \\(\\sigma_-\\).</p> <p>It is defined by \\(\\sigma_- = \\begin{pmatrix} 0 &amp; 0 \\\\ 1 &amp; 0 \\end{pmatrix}\\).</p> <p>Parameters:</p> <ul> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>Pauli \\(\\sigma_-\\) operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.sigmam()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5      \u22c5   ]\n [1.+0.j   \u22c5   ]]\n</code></pre>"},{"location":"python_api/utils/operators/sigmap.html","title":"sigmap","text":""},{"location":"python_api/utils/operators/sigmap.html#dynamiqs.utils.operators.sigmap","title":"dq.sigmap","text":"<pre><code>sigmap(*, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the Pauli raising operator \\(\\sigma_+\\).</p> <p>It is defined by \\(\\sigma_+ = \\begin{pmatrix} 0 &amp; 1 \\\\ 0 &amp; 0 \\end{pmatrix}\\).</p> <p>Parameters:</p> <ul> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>Pauli \\(\\sigma_+\\) operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.sigmap()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[  \u22c5    1.+0.j]\n [  \u22c5      \u22c5   ]]\n</code></pre>"},{"location":"python_api/utils/operators/sigmax.html","title":"sigmax","text":""},{"location":"python_api/utils/operators/sigmax.html#dynamiqs.utils.operators.sigmax","title":"dq.sigmax","text":"<pre><code>sigmax(*, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the Pauli \\(\\sigma_x\\) operator.</p> <p>It is defined by \\(\\sigma_x = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}\\).</p> <p>Parameters:</p> <ul> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>Pauli \\(\\sigma_x\\) operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.sigmax()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n[[  \u22c5    1.+0.j]\n [1.+0.j   \u22c5   ]]\n</code></pre>"},{"location":"python_api/utils/operators/sigmay.html","title":"sigmay","text":""},{"location":"python_api/utils/operators/sigmay.html#dynamiqs.utils.operators.sigmay","title":"dq.sigmay","text":"<pre><code>sigmay(*, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the Pauli \\(\\sigma_y\\) operator.</p> <p>It is defined by \\(\\sigma_y = \\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix}\\).</p> <p>Parameters:</p> <ul> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>Pauli \\(\\sigma_y\\) operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.sigmay()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=2\n[[  \u22c5    0.-1.j]\n [0.+1.j   \u22c5   ]]\n</code></pre>"},{"location":"python_api/utils/operators/sigmaz.html","title":"sigmaz","text":""},{"location":"python_api/utils/operators/sigmaz.html#dynamiqs.utils.operators.sigmaz","title":"dq.sigmaz","text":"<pre><code>sigmaz(*, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the Pauli \\(\\sigma_z\\) operator.</p> <p>It is defined by \\(\\sigma_z = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix}\\).</p> <p>Parameters:</p> <ul> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>Pauli \\(\\sigma_z\\) operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.sigmaz()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=1\n[[ 1.+0.j    \u22c5   ]\n [   \u22c5    -1.+0.j]]\n</code></pre>"},{"location":"python_api/utils/operators/squeeze.html","title":"squeeze","text":""},{"location":"python_api/utils/operators/squeeze.html#dynamiqs.utils.operators.squeeze","title":"dq.squeeze","text":"<pre><code>squeeze(dim: int, z: ArrayLike) -&gt; DenseQArray\n</code></pre> <p>Returns the squeezing operator of complex squeezing amplitude \\(z\\).</p> <p>It is defined by $$     S(z) = \\exp\\left(\\frac{1}{2}\\left(z^* a^2 - z a^{\\dag 2}\\right)\\right), $$ where \\(a\\) and \\(a^\\dag\\) are the annihilation and creation operators, respectively.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Dimension of the Hilbert space.</p> </li> <li> <code>z</code>             (array-like of shape (...))         \u2013          <p>Squeezing amplitude.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., dim, dim))           \u2013          <p>Squeezing operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.squeeze(4, 0.5)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dense\n[[ 0.938+0.j  0.   +0.j  0.346+0.j  0.   +0.j]\n [ 0.   +0.j  0.818+0.j  0.   +0.j  0.575+0.j]\n [-0.346+0.j  0.   +0.j  0.938+0.j  0.   +0.j]\n [ 0.   +0.j -0.575+0.j  0.   +0.j  0.818+0.j]]\n&gt;&gt;&gt; dq.squeeze(4, [0.1, 0.2]).shape\n(2, 4, 4)\n</code></pre>"},{"location":"python_api/utils/operators/tgate.html","title":"tgate","text":""},{"location":"python_api/utils/operators/tgate.html#dynamiqs.utils.operators.tgate","title":"dq.tgate","text":"<pre><code>tgate() -&gt; QArray\n</code></pre> <p>Returns the \\(\\text{T}\\) gate.</p> <p>It is defined by \\(\\text{T} = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\frac{\\pi}{4}} \\end{pmatrix}\\).</p> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>\\(\\text{T}\\) gate.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.tgate()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[1.   +0.j    0.   +0.j   ]\n [0.   +0.j    0.707+0.707j]]\n</code></pre>"},{"location":"python_api/utils/operators/toffoli.html","title":"toffoli","text":""},{"location":"python_api/utils/operators/toffoli.html#dynamiqs.utils.operators.toffoli","title":"dq.toffoli","text":"<pre><code>toffoli() -&gt; QArray\n</code></pre> <p>Returns the \\(\\text{Toffoli}\\) gate.</p> <p>It is defined by $$     \\text{Toffoli} = \\begin{pmatrix}         1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0     \\end{pmatrix} $$</p> <p>Returns:</p> <ul> <li>             (qarray of shape (8, 8))           \u2013          <p>\\(\\text{Toffoli}\\) gate.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.toffoli()\nQArray: shape=(8, 8), dims=(2, 2, 2), dtype=complex64, layout=dense\n[[1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j]]\n</code></pre>"},{"location":"python_api/utils/operators/xyz.html","title":"xyz","text":""},{"location":"python_api/utils/operators/xyz.html#dynamiqs.utils.operators.xyz","title":"dq.xyz","text":"<pre><code>xyz(*, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the Pauli \\(\\sigma_x\\), \\(\\sigma_y\\) and \\(\\sigma_z\\) operators.</p> <p>Parameters:</p> <ul> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (3, 2, 2))           \u2013          <p>Pauli \\(\\sigma_x\\), \\(\\sigma_y\\) and \\(\\sigma_z\\) operators.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.xyz()\nQArray: shape=(3, 2, 2), dims=(2,), dtype=complex64, layout=dia, ndiags=3\n[[[   \u22c5     1.+0.j]\n  [ 1.+0.j    \u22c5   ]]\n\n [[   \u22c5     0.-1.j]\n  [ 0.+1.j    \u22c5   ]]\n\n [[ 1.+0.j    \u22c5   ]\n  [   \u22c5    -1.+0.j]]]\n</code></pre>"},{"location":"python_api/utils/operators/zeros.html","title":"zeros","text":""},{"location":"python_api/utils/operators/zeros.html#dynamiqs.utils.operators.zeros","title":"dq.zeros","text":"<pre><code>zeros(*dims: int, layout: Layout | None = None) -&gt; QArray\n</code></pre> <p>Returns the null operator.</p> <p>If multiple dimensions are provided \\(\\mathtt{dims}=(n_1,\\dots,n_N)\\), it returns the null operator of the composite Hilbert space of dimension \\(n=\\prod n_k\\): $$     0_n = 0_{n_1}\\otimes\\dots\\otimes 0_{n_N}. $$</p> <p>Parameters:</p> <ul> <li> <code>*dims</code>         \u2013          <p>Hilbert space dimension of each subsystem.</p> </li> <li> <code>layout</code>         \u2013          <p>Matrix layout (<code>dq.dense</code>, <code>dq.dia</code> or <code>None</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (n, n))           \u2013          <p>Null operator, with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode \\(0_4\\):</p> <pre><code>&gt;&gt;&gt; dq.zeros(4)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dia, ndiags=0\n[[  \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5   ]]\n</code></pre> <p>Multi-mode \\(0_2 \\otimes 0_3\\):</p> <pre><code>&gt;&gt;&gt; dq.zeros(2, 3)\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=0\n[[  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]]\n</code></pre> See also <ul> <li><code>dq.zeros_like()</code>: returns the null operator in the Hilbert space of the input.</li> </ul>"},{"location":"python_api/utils/operators/zeros_like.html","title":"zeros_like","text":""},{"location":"python_api/utils/operators/zeros_like.html#dynamiqs.utils.operators.zeros_like","title":"dq.zeros_like","text":"<pre><code>zeros_like(\n    x: QArrayLike, dims: tuple[int, ...] | None = None, layout: Layout | None = None\n) -&gt; QArray\n</code></pre> <p>Returns the null operator in the Hilbert space of the input.</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, 1) or (..., 1, n) or (..., n, n))         \u2013          <p>Ket, bra or operator.</p> </li> <li> <code>dims</code>             (tuple of ints or None)         \u2013          <p>Dimensions of each subsystem in the composite system Hilbert space tensor product. Defaults to <code>None</code> (<code>x.dims</code> if available, single Hilbert space <code>dims=(n,)</code> otherwise).</p> </li> <li> <code>layout</code>         \u2013          <p>Overrides the returned matrix layout. If <code>None</code>, the layout is the same as <code>x</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (n, n))           \u2013          <p>Null operator, with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode \\(0_4\\):</p> <pre><code>&gt;&gt;&gt; a = dq.destroy(4)\n&gt;&gt;&gt; dq.zeros_like(a)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dia, ndiags=0\n[[  \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5   ]]\n</code></pre> <p>Multi-mode \\(0_2 \\otimes 0_3\\):</p> <pre><code>&gt;&gt;&gt; a, b = dq.destroy(2, 3)\n&gt;&gt;&gt; dq.zeros_like(a)\nQArray: shape=(6, 6), dims=(2, 3), dtype=complex64, layout=dia, ndiags=0\n[[  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]\n [  \u22c5      \u22c5      \u22c5      \u22c5      \u22c5      \u22c5   ]]\n</code></pre> See also <ul> <li><code>dq.zeros()</code>: returns the null operator.</li> </ul>"},{"location":"python_api/utils/optimal_control/cd_gate.html","title":"cd_gate","text":""},{"location":"python_api/utils/optimal_control/cd_gate.html#dynamiqs.utils.optimal_control.cd_gate","title":"dq.cd_gate","text":"<pre><code>cd_gate(dim: int, alpha: ArrayLike) -&gt; QArray\n</code></pre> <p>Returns a conditional displacement gate.</p> <p>The conditional displacement (CD) gate displaces an oscillator conditioned on the state of a coupled two-level system (TLS) state. It is defined by $$    \\mathrm{CD}(\\alpha) = D(\\alpha/2)\\ket{g}\\bra{g} + D(-\\alpha/2)\\ket{e}\\bra{e}, $$ where \\(\\ket{g}\\) (defined by <code>dq.ground()</code>) and \\(\\ket{e}\\) (defined by <code>dq.excited()</code>) are the ground and excited states of the TLS.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Dimension of the oscillator Hilbert space.</p> </li> <li> <code>alpha</code>             (array-like of shape (...))         \u2013          <p>Displacement amplitude.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>CD gate operator (acting on the oscillator + TLS system of dimension n = 2 x dim).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.cd_gate(2, 0.1)\nQArray: shape=(4, 4), dims=(2, 2), dtype=complex64, layout=dense\n[[ 0.999+0.j  0.   +0.j  0.05 +0.j  0.   +0.j]\n [ 0.   +0.j  0.999+0.j  0.   +0.j -0.05 +0.j]\n [-0.05 +0.j  0.   +0.j  0.999+0.j  0.   +0.j]\n [ 0.   +0.j  0.05 +0.j  0.   +0.j  0.999+0.j]]\n&gt;&gt;&gt; dq.cd_gate(3, [0.1, 0.2]).shape\n(2, 6, 6)\n</code></pre>"},{"location":"python_api/utils/optimal_control/snap_gate.html","title":"snap_gate","text":""},{"location":"python_api/utils/optimal_control/snap_gate.html#dynamiqs.utils.optimal_control.snap_gate","title":"dq.snap_gate","text":"<pre><code>snap_gate(phase: ArrayLike) -&gt; QArray\n</code></pre> <p>Returns a SNAP gate.</p> <p>The selective number-dependent arbitrary phase (SNAP) gate imparts a different phase \\(\\theta_k\\) to each Fock state \\(\\ket{k}\\bra{k}\\). It is defined by $$     \\mathrm{SNAP}(\\theta_0,\\dots,\\theta_{n-1}) =     \\sum_{k=0}^{n-1} e^{i\\theta_k} \\ket{k}\\bra{k}. $$</p> <p>Parameters:</p> <ul> <li> <code>phase</code>             (array-like of shape (..., n))         \u2013          <p>Phase for each Fock state. The last dimension of the array n defines the Hilbert space dimension.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>SNAP gate operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.snap_gate([0, 1, 2])\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dense\n[[ 1.   +0.j     0.   +0.j     0.   +0.j   ]\n [ 0.   +0.j     0.54 +0.841j  0.   +0.j   ]\n [ 0.   +0.j     0.   +0.j    -0.416+0.909j]]\n&gt;&gt;&gt; dq.snap_gate([[0, 1, 2], [2, 3, 4]]).shape\n(2, 3, 3)\n</code></pre>"},{"location":"python_api/utils/states/basis.html","title":"basis","text":""},{"location":"python_api/utils/states/basis.html#dynamiqs.utils.states.basis","title":"dq.basis","text":"<pre><code>basis(dim: int | tuple[int, ...], number: ArrayLike) -&gt; QArray\n</code></pre> <p>Alias of <code>dq.fock()</code>.</p>"},{"location":"python_api/utils/states/basis_dm.html","title":"basis_dm","text":""},{"location":"python_api/utils/states/basis_dm.html#dynamiqs.utils.states.basis_dm","title":"dq.basis_dm","text":"<pre><code>basis_dm(dim: int | tuple[int, ...], number: ArrayLike) -&gt; QArray\n</code></pre> <p>Alias of <code>dq.fock_dm()</code>.</p>"},{"location":"python_api/utils/states/coherent.html","title":"coherent","text":""},{"location":"python_api/utils/states/coherent.html#dynamiqs.utils.states.coherent","title":"dq.coherent","text":"<pre><code>coherent(dim: int | tuple[int, ...], alpha: ArrayLike | list[ArrayLike]) -&gt; QArray\n</code></pre> <p>Returns the ket of a coherent state or a tensor product of coherent states.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Hilbert space dimension of each mode.</p> </li> <li> <code>alpha</code>             (array-like of shape (...) or (len(dim), ...))         \u2013          <p>Coherent state amplitude for each mode. If <code>dim</code> is a tuple, the first dimension of <code>alpha</code> should match the length of <code>dim</code>.</p> </li> </ul> Note <p>If you provide argument <code>alpha</code> as a list, all elements must be broadcastable.</p> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, 1))           \u2013          <p>Ket of the coherent state or tensor product of coherent states, with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode coherent state \\(\\ket{\\alpha}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent(4, 0.5)\nQArray: shape=(4, 1), dims=(4,), dtype=complex64, layout=dense\n[[0.882+0.j]\n [0.441+0.j]\n [0.156+0.j]\n [0.047+0.j]]\n</code></pre> <p>Batched single-mode coherent states \\(\\{\\ket{\\alpha_0}\\!, \\ket{\\alpha_1}\\}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent(4, [0.5, 0.5j])\nQArray: shape=(2, 4, 1), dims=(4,), dtype=complex64, layout=dense\n[[[ 0.882+0.j   ]\n  [ 0.441+0.j   ]\n  [ 0.156+0.j   ]\n  [ 0.047+0.j   ]]\n\n [[ 0.882+0.j   ]\n  [ 0.   +0.441j]\n  [-0.156+0.j   ]\n  [ 0.   -0.047j]]]\n</code></pre> <p>Multi-mode coherent state \\(\\ket{\\alpha}\\otimes\\ket{\\beta}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent((2, 3), (0.5, 0.5j))\nQArray: shape=(6, 1), dims=(2, 3), dtype=complex64, layout=dense\n[[ 0.775+0.j   ]\n [ 0.   +0.386j]\n [-0.146+0.j   ]\n [ 0.423+0.j   ]\n [ 0.   +0.211j]\n [-0.08 +0.j   ]]\n</code></pre> <p>Batched multi-mode coherent states \\(\\{\\ket{\\alpha_0}\\otimes\\ket{\\beta_0}\\!, \\ket{\\alpha_1}\\otimes\\ket{\\beta_1}\\}\\):</p> <pre><code>&gt;&gt;&gt; alpha1 = np.linspace(0, 1, 5)\n&gt;&gt;&gt; alpha2 = np.linspace(0, 1, 7)\n&gt;&gt;&gt; dq.coherent((8, 8), (alpha1[None, :], alpha2[:, None])).shape\n(7, 5, 64, 1)\n</code></pre>"},{"location":"python_api/utils/states/coherent_dm.html","title":"coherent_dm","text":""},{"location":"python_api/utils/states/coherent_dm.html#dynamiqs.utils.states.coherent_dm","title":"dq.coherent_dm","text":"<pre><code>coherent_dm(dim: int | tuple[int, ...], alpha: ArrayLike) -&gt; QArray\n</code></pre> <p>Returns the density matrix of a coherent state or a tensor product of coherent states.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Hilbert space dimension of each mode.</p> </li> <li> <code>alpha</code>             (array-like of shape (...) or (..., len(dim)))         \u2013          <p>Coherent state amplitude for each mode. If <code>dim</code> is a tuple, the last dimension of <code>alpha</code> should match the length of <code>dim</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Density matrix of the coherent state or tensor product of coherent states, with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode coherent state \\(\\ket{\\alpha}\\bra{\\alpha}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent_dm(4, 0.5)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dense\n[[0.779+0.j 0.389+0.j 0.137+0.j 0.042+0.j]\n [0.389+0.j 0.195+0.j 0.069+0.j 0.021+0.j]\n [0.137+0.j 0.069+0.j 0.024+0.j 0.007+0.j]\n [0.042+0.j 0.021+0.j 0.007+0.j 0.002+0.j]]\n</code></pre> <p>Batched single-mode coherent states \\(\\{\\ket{\\alpha_0}\\bra{\\alpha_0}\\!, \\ket{\\alpha_1}\\bra{\\alpha_1}\\}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent_dm(4, [0.5, 0.5j]).shape\n(2, 4, 4)\n</code></pre> <p>Multi-mode coherent state \\(\\ket{\\alpha}\\bra{\\alpha}\\otimes\\ket{\\beta}\\bra{\\beta}\\):</p> <pre><code>&gt;&gt;&gt; dq.coherent_dm((2, 3), (0.5, 0.5j)).shape\n(6, 6)\n</code></pre> <p>Batched multi-mode coherent states \\(\\{\\ket{\\alpha_0}\\bra{\\alpha_0}\\otimes\\ket{\\beta_0}\\bra{\\beta_0}\\!, \\ket{\\alpha_1}\\bra{\\alpha_1}\\otimes\\ket{\\beta_1}\\bra{\\beta_1}\\}\\):</p> <pre><code>&gt;&gt;&gt; alpha = [(0.5, 0.5j), (0.5j, 0.5)]\n&gt;&gt;&gt; dq.coherent_dm((4, 6), alpha).shape\n(2, 24, 24)\n</code></pre>"},{"location":"python_api/utils/states/excited.html","title":"excited","text":""},{"location":"python_api/utils/states/excited.html#dynamiqs.utils.states.excited","title":"dq.excited","text":"<pre><code>excited() -&gt; QArray\n</code></pre> <p>Returns the eigenvector with eigenvalue \\(+1\\) of the Pauli \\(\\sigma_z\\) operator.</p> <p>It is defined by \\(\\ket{e} = \\begin{pmatrix}1\\\\0\\end{pmatrix}\\).</p> Note <p>This function is named <code>excited</code> because \\(\\ket{e}\\) is the higher energy state of a two-level-system with Hamiltonian \\(H=\\omega \\sigma_z\\).</p> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 1))           \u2013          <p>Ket \\(\\ket{e}\\).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.excited()\nQArray: shape=(2, 1), dims=(2,), dtype=complex64, layout=dense\n[[1.+0.j]\n [0.+0.j]]\n</code></pre>"},{"location":"python_api/utils/states/excited_dm.html","title":"excited_dm","text":""},{"location":"python_api/utils/states/excited_dm.html#dynamiqs.utils.states.excited_dm","title":"dq.excited_dm","text":"<pre><code>excited_dm() -&gt; QArray\n</code></pre> <p>Returns the projector on the eigenvector with eigenvalue \\(+1\\) of the Pauli \\(\\sigma_z\\) operator.</p> <p>It is defined by \\(\\ket{e}\\bra{e} = \\begin{pmatrix}1 &amp; 0\\\\0 &amp; 0\\end{pmatrix}\\).</p> Note <p>This function is named <code>excited_dm</code> because \\(\\ket{e}\\) is the higher energy state of a two-level-system with Hamiltonian \\(H=\\omega \\sigma_z\\).</p> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>Density matrix \\(\\ket{e}\\bra{e}\\).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.excited_dm()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[1.+0.j 0.+0.j]\n [0.+0.j 0.+0.j]]\n</code></pre>"},{"location":"python_api/utils/states/fock.html","title":"fock","text":""},{"location":"python_api/utils/states/fock.html#dynamiqs.utils.states.fock","title":"dq.fock","text":"<pre><code>fock(dim: int | tuple[int, ...], number: ArrayLike) -&gt; QArray\n</code></pre> <p>Returns the ket of a Fock state or a tensor product of Fock states.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Hilbert space dimension of each mode.</p> </li> <li> <code>number</code>             (array-like of shape (...) or (..., len(dim)))         \u2013          <p>Fock state number for each mode, of integer type. If <code>dim</code> is a tuple, the last dimension of <code>number</code> should match the length of <code>dim</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, 1))           \u2013          <p>Ket of the Fock state or tensor product of Fock states, with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode Fock state \\(\\ket{1}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock(3, 1)\nQArray: shape=(3, 1), dims=(3,), dtype=complex64, layout=dense\n[[0.+0.j]\n [1.+0.j]\n [0.+0.j]]\n</code></pre> <p>Batched single-mode Fock states \\(\\{\\ket{0}\\!, \\ket{1}\\!, \\ket{2}\\}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock(3, [0, 1, 2])\nQArray: shape=(3, 3, 1), dims=(3,), dtype=complex64, layout=dense\n[[[1.+0.j]\n  [0.+0.j]\n  [0.+0.j]]\n\n [[0.+0.j]\n  [1.+0.j]\n  [0.+0.j]]\n\n [[0.+0.j]\n  [0.+0.j]\n  [1.+0.j]]]\n</code></pre> <p>Multi-mode Fock state \\(\\ket{1,0}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock((3, 2), (1, 0))\nQArray: shape=(6, 1), dims=(3, 2), dtype=complex64, layout=dense\n[[0.+0.j]\n [0.+0.j]\n [1.+0.j]\n [0.+0.j]\n [0.+0.j]\n [0.+0.j]]\n</code></pre> <p>Batched multi-mode Fock states \\(\\{\\ket{0,0}\\!, \\ket{0,1}\\!, \\ket{1,1}\\!, \\ket{2,0}\\}\\):</p> <pre><code>&gt;&gt;&gt; number = [(0, 0), (0, 1), (1, 1), (2, 0)]\n&gt;&gt;&gt; dq.fock((3, 2), number).shape\n(4, 6, 1)\n</code></pre>"},{"location":"python_api/utils/states/fock_dm.html","title":"fock_dm","text":""},{"location":"python_api/utils/states/fock_dm.html#dynamiqs.utils.states.fock_dm","title":"dq.fock_dm","text":"<pre><code>fock_dm(dim: int | tuple[int, ...], number: ArrayLike) -&gt; QArray\n</code></pre> <p>Returns the density matrix of a Fock state or a tensor product of Fock states.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Hilbert space dimension of each mode.</p> </li> <li> <code>number</code>             (array-like of shape (...) or (..., len(dim)))         \u2013          <p>Fock state number for each mode, of integer type. If <code>dim</code> is a tuple, the last dimension of <code>number</code> should match the length of <code>dim</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Density matrix of the Fock state or tensor product of Fock states, with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode Fock state \\(\\ket{1}\\bra{1}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock_dm(3, 1)\nQArray: shape=(3, 3), dims=(3,), dtype=complex64, layout=dense\n[[0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 1.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j]]\n</code></pre> <p>Batched single-mode Fock states \\(\\{\\ket{0}\\bra{0}\\!, \\ket{1}\\bra{1}\\!, \\ket{2}\\bra{2}\\}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock_dm(3, [0, 1, 2])\nQArray: shape=(3, 3, 3), dims=(3,), dtype=complex64, layout=dense\n[[[1.+0.j 0.+0.j 0.+0.j]\n  [0.+0.j 0.+0.j 0.+0.j]\n  [0.+0.j 0.+0.j 0.+0.j]]\n\n [[0.+0.j 0.+0.j 0.+0.j]\n  [0.+0.j 1.+0.j 0.+0.j]\n  [0.+0.j 0.+0.j 0.+0.j]]\n\n [[0.+0.j 0.+0.j 0.+0.j]\n  [0.+0.j 0.+0.j 0.+0.j]\n  [0.+0.j 0.+0.j 1.+0.j]]]\n</code></pre> <p>Multi-mode Fock state \\(\\ket{1,0}\\bra{1,0}\\):</p> <pre><code>&gt;&gt;&gt; dq.fock_dm((3, 2), (1, 0))\nQArray: shape=(6, 6), dims=(3, 2), dtype=complex64, layout=dense\n[[0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]]\n</code></pre> <p>Batched multi-mode Fock states \\(\\{\\ket{0,0}\\bra{0,0}\\!, \\ket{0,1}\\bra{0,1}\\!, \\ket{1,1}\\bra{1,1}\\!, \\ket{2,0}\\bra{2,0}\\}\\):</p> <pre><code>&gt;&gt;&gt; number = [(0, 0), (0, 1), (1, 1), (2, 0)]\n&gt;&gt;&gt; dq.fock_dm((3, 2), number).shape\n(4, 6, 6)\n</code></pre>"},{"location":"python_api/utils/states/ground.html","title":"ground","text":""},{"location":"python_api/utils/states/ground.html#dynamiqs.utils.states.ground","title":"dq.ground","text":"<pre><code>ground() -&gt; QArray\n</code></pre> <p>Returns the eigenvector with eigenvalue \\(-1\\) of the Pauli \\(\\sigma_z\\) operator.</p> <p>It is defined by \\(\\ket{g} = \\begin{pmatrix}0\\\\1\\end{pmatrix}\\).</p> Note <p>This function is named <code>ground</code> because \\(\\ket{g}\\) is the lower energy state of a two-level system with Hamiltonian \\(H=\\omega \\sigma_z\\).</p> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 1))           \u2013          <p>Ket \\(\\ket{g}\\).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.ground()\nQArray: shape=(2, 1), dims=(2,), dtype=complex64, layout=dense\n[[0.+0.j]\n [1.+0.j]]\n</code></pre>"},{"location":"python_api/utils/states/ground_dm.html","title":"ground_dm","text":""},{"location":"python_api/utils/states/ground_dm.html#dynamiqs.utils.states.ground_dm","title":"dq.ground_dm","text":"<pre><code>ground_dm() -&gt; QArray\n</code></pre> <p>Returns the projector on the eigenvector with eigenvalue \\(-1\\) of the Pauli \\(\\sigma_z\\) operator.</p> <p>It is defined by \\(\\ket{g}\\bra{g} = \\begin{pmatrix}0 &amp; 0\\\\0 &amp; 1\\end{pmatrix}\\).</p> Note <p>This function is named <code>ground_dm</code> because \\(\\ket{g}\\) is the lower energy state of a two-level system with Hamiltonian \\(H=\\omega \\sigma_z\\).</p> <p>Returns:</p> <ul> <li>             (qarray of shape (2, 2))           \u2013          <p>Density matrix \\(\\ket{g}\\bra{g}\\).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.ground_dm()\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[0.+0.j 0.+0.j]\n [0.+0.j 1.+0.j]]\n</code></pre>"},{"location":"python_api/utils/states/thermal_dm.html","title":"thermal_dm","text":""},{"location":"python_api/utils/states/thermal_dm.html#dynamiqs.utils.states.thermal_dm","title":"dq.thermal_dm","text":"<pre><code>thermal_dm(dim: int | tuple[int, ...], nth: ArrayLike) -&gt; QArray\n</code></pre> <p>Returns the density matrix of a thermal state or a tensor product of thermal states.</p> <p>For a single mode, it is defined for a thermal photon number \\(n_{th}\\) by:</p> \\[     \\rho = \\sum_k \\frac{(n_{th})^k}{(1+n_{th})^{1+k}} \\ket{k}\\bra{k}. \\] <p>Parameters:</p> <ul> <li> <code>dim</code>         \u2013          <p>Hilbert space dimension of each mode.</p> </li> <li> <code>nth</code>             (array-like of shape (...) or (..., len(dim)))         \u2013          <p>Thermal photon number for each mode. If <code>dim</code> is a tuple, the last dimension of <code>nth</code> should match the length of <code>dim</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Density matrix of the thermal state or tensor product of thermal states, with n = prod(dims).</p> </li> </ul> <p>Examples:</p> <p>Single-mode thermal state with thermal photon number \\(n_{th}=0.1\\):</p> <pre><code>&gt;&gt;&gt; dq.thermal_dm(4, 0.1)\nQArray: shape=(4, 4), dims=(4,), dtype=complex64, layout=dense\n[[0.909+0.j 0.   +0.j 0.   +0.j 0.   +0.j]\n [0.   +0.j 0.083+0.j 0.   +0.j 0.   +0.j]\n [0.   +0.j 0.   +0.j 0.008+0.j 0.   +0.j]\n [0.   +0.j 0.   +0.j 0.   +0.j 0.001+0.j]]\n</code></pre> <p>Batched single-mode thermal states:</p> <pre><code>&gt;&gt;&gt; dq.thermal_dm(4, [0.1, 0.2, 0.3]).shape\n(3, 4, 4)\n</code></pre> <p>Multi-mode thermal state:</p> <pre><code>&gt;&gt;&gt; dq.thermal_dm((4, 3), (0.1, 0.2)).shape\n(12, 12)\n</code></pre> <p>Batched multi-mode thermal states:</p> <pre><code>&gt;&gt;&gt; nth = [(0.1, 0.2), (0.2, 0.1), (0.2, 0.2)]\n&gt;&gt;&gt; dq.thermal_dm((4, 3), nth).shape\n(3, 12, 12)\n</code></pre>"},{"location":"python_api/utils/vectorization/sdissipator.html","title":"sdissipator","text":""},{"location":"python_api/utils/vectorization/sdissipator.html#dynamiqs.utils.vectorization.sdissipator","title":"dq.sdissipator","text":"<pre><code>sdissipator(L: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the Lindblad dissipation superoperator (in matrix form).</p> <p>The dissipation superoperator \\(\\mathcal{D}[L]\\) is defined by: $$     \\mathcal{D}[L] (\\rho) = L\\rho L^\\dag - \\frac{1}{2}L^\\dag L \\rho     - \\frac{1}{2}\\rho L^\\dag L. $$</p> <p>The vectorized form of this superoperator is: $$     L^* \\otimes L     - \\frac{1}{2} (I_n \\otimes L^\\dag L)     - \\frac{1}{2} (L^\\mathrm{T} L^* \\otimes I_n). $$</p> <p>Parameters:</p> <ul> <li> <code>L</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Jump operator.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n^2, n^2))           \u2013          <p>Dissipation superoperator.</p> </li> </ul> See also <ul> <li><code>dq.dissipator()</code>: applies the dissipation     superoperator to a state using only \\(n\\times n\\) matrix multiplications.</li> </ul>"},{"location":"python_api/utils/vectorization/slindbladian.html","title":"slindbladian","text":""},{"location":"python_api/utils/vectorization/slindbladian.html#dynamiqs.utils.vectorization.slindbladian","title":"dq.slindbladian","text":"<pre><code>slindbladian(H: QArrayLike, jump_ops: list[QArrayLike]) -&gt; QArray\n</code></pre> <p>Returns the Lindbladian superoperator (in matrix form).</p> <p>The Lindbladian superoperator \\(\\mathcal{L}\\) is defined by: $$     \\mathcal{L} (\\rho) = -i[H,\\rho] + \\sum_{k=1}^N \\mathcal{D}[L_k] (\\rho), $$</p> <p>where \\(H\\) is the system Hamiltonian, \\(\\{L_k\\}\\) is a set of \\(N\\) jump operators (arbitrary operators) and \\(\\mathcal{D}[L]\\) is the Lindblad dissipation superoperator (see <code>dq.sdissipator()</code>).</p> <p>The vectorized form of this superoperator is: $$     -i (I_n \\otimes H) + i (H^\\mathrm{T} \\otimes I_n) + \\sum_{k=1}^N \\left(         L_k^* \\otimes L_k         - \\frac{1}{2} (I_n \\otimes L_k^\\dag L_k)         - \\frac{1}{2} (L_k^\\mathrm{T} L_k^* \\otimes I_n)     \\right). $$</p> Note <p>This superoperator is also sometimes called Liouvillian.</p> <p>Parameters:</p> <ul> <li> <code>H</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Hamiltonian.</p> </li> <li> <code>jump_ops</code>             (list of qarray-like, each of shape (..., n, n))         \u2013          <p>List of jump operators.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n^2, n^2))           \u2013          <p>Lindbladian superoperator.</p> </li> </ul> See also <ul> <li><code>dq.lindbladian()</code>: applies the Lindbladian     superoperator to a state using only \\(n\\times n\\) matrix multiplications.</li> </ul>"},{"location":"python_api/utils/vectorization/spost.html","title":"spost","text":""},{"location":"python_api/utils/vectorization/spost.html#dynamiqs.utils.vectorization.spost","title":"dq.spost","text":"<pre><code>spost(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the superoperator formed from post-multiplication by an operator.</p> <p>Post-multiplication by matrix \\(A\\) is defined by the superoperator \\(A^\\mathrm{T} \\otimes I_n\\) in vectorized form: $$     XA \\to (A^\\mathrm{T} \\otimes I_n) \\kett{X}. $$</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Operator.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n^2, n^2))           \u2013          <p>Post-multiplication superoperator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.spost(dq.destroy(3)).shape\n(9, 9)\n</code></pre>"},{"location":"python_api/utils/vectorization/spre.html","title":"spre","text":""},{"location":"python_api/utils/vectorization/spre.html#dynamiqs.utils.vectorization.spre","title":"dq.spre","text":"<pre><code>spre(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the superoperator formed from pre-multiplication by an operator.</p> <p>Pre-multiplication by matrix \\(A\\) is defined by the superoperator \\(I_n \\otimes A\\) in vectorized form: $$     AX \\to (I_n \\otimes A) \\kett{X}. $$</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Operator.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n^2, n^2))           \u2013          <p>Pre-multiplication superoperator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.spre(dq.destroy(3)).shape\n(9, 9)\n</code></pre>"},{"location":"python_api/utils/vectorization/sprepost.html","title":"sprepost","text":""},{"location":"python_api/utils/vectorization/sprepost.html#dynamiqs.utils.vectorization.sprepost","title":"dq.sprepost","text":"<pre><code>sprepost(x: QArrayLike, y: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the superoperator formed from pre- and post-multiplication by operators.</p> <p>Pre-multiplication by matrix \\(A\\) and post-multiplication by matrix \\(B\\) is defined by the superoperator \\(B^\\mathrm{T} \\otimes A\\) in vectorized form: $$     AXB \\to (B^\\mathrm{T} \\otimes A) \\kett{X}. $$</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Operator for pre-multiplication.</p> </li> <li> <code>y</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Operator for post-multiplication.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (Qarray of shape (..., n^2, n^2))           \u2013          <p>Pre- and post-multiplication superoperator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dq.sprepost(dq.destroy(3), dq.create(3)).shape\n(9, 9)\n</code></pre>"},{"location":"python_api/utils/vectorization/unvectorize.html","title":"unvectorize","text":""},{"location":"python_api/utils/vectorization/unvectorize.html#dynamiqs.utils.vectorization.unvectorize","title":"dq.unvectorize","text":"<pre><code>unvectorize(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the operator version of a vectorized operator.</p> <p>The matrix \\(A\\) (shape \\(n\\times n\\)) is obtained by stacking horizontally next to each other each group of \\(n\\) elements of the vectorized column vector \\(\\kett{A}\\) (shape \\(n^2\\times 1\\)): $$     \\kett{A} = \\begin{pmatrix} a \\\\ b \\\\ c \\\\ d \\end{pmatrix}     \\to     A = \\begin{pmatrix} a &amp; c \\\\ b &amp; d \\end{pmatrix}. $$</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n^2, 1))         \u2013          <p>Vectorized operator.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n, n))           \u2013          <p>Operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Avec = jnp.array([[1 + 1j], [2 + 2j], [3 + 3j], [4 + 4j]])\n&gt;&gt;&gt; Avec\nArray([[1.+1.j],\n       [2.+2.j],\n       [3.+3.j],\n       [4.+4.j]], dtype=complex64)\n&gt;&gt;&gt; dq.unvectorize(Avec)\nQArray: shape=(2, 2), dims=(2,), dtype=complex64, layout=dense\n[[1.+1.j 3.+3.j]\n [2.+2.j 4.+4.j]]\n</code></pre>"},{"location":"python_api/utils/vectorization/vectorize.html","title":"vectorize","text":""},{"location":"python_api/utils/vectorization/vectorize.html#dynamiqs.utils.vectorization.vectorize","title":"dq.vectorize","text":"<pre><code>vectorize(x: QArrayLike) -&gt; QArray\n</code></pre> <p>Returns the vectorized version of an operator.</p> <p>The vectorized column vector \\(\\kett{A}\\) (shape \\(n^2\\times 1\\)) is obtained by stacking the columns of the matrix \\(A\\) (shape \\(n\\times n\\)) on top of one another: $$     A = \\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix}     \\to     \\kett{A} = \\begin{pmatrix} a \\\\ c \\\\ b \\\\ d \\end{pmatrix}. $$</p> <p>Parameters:</p> <ul> <li> <code>x</code>             (qarray-like of shape (..., n, n))         \u2013          <p>Operator.</p> </li> </ul> <p>Returns:</p> <ul> <li>             (qarray of shape (..., n^2, 1))           \u2013          <p>Vectorized operator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; A = jnp.array([[1 + 1j, 2 + 2j], [3 + 3j, 4 + 4j]])\n&gt;&gt;&gt; A\nArray([[1.+1.j, 2.+2.j],\n       [3.+3.j, 4.+4.j]], dtype=complex64)\n&gt;&gt;&gt; dq.vectorize(A)\nQArray: shape=(4, 1), dims=(2,), dtype=complex64, layout=dense, vectorized=True\n[[1.+1.j]\n [3.+3.j]\n [2.+2.j]\n [4.+4.j]]\n</code></pre>"}]}